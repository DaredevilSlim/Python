#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# http://aliev.me/runestone/

# Приступая к работе с данными
print('Приступая к работе с данными:')
# Как мы уже отмечали выше, Python поддерживает парадигму объектно-ориентированного программирования. Это означает,
# что в фокус процесса решения задачи им ставятся данные. В Python, как и в любом другом объектно-ориентированном языке
# программирования, мы определяем класс, являющийся описанием того, как, собственно, выглядят данные (состояние) и что
# они могут делать (поведение). Классы аналогичны абстрактным типам данных, поскольку пользователь видит только
# состояние и поведение единицы данных. Такие единицы в объектно-ориентированной парадигме называются объектами. Объект
# является экземпляром класса.


# Встроенные элементарные типы данных
print('Встроенные элементарные типы данных:')
# Начнем наш обзор с рассмотрения элементарных типов данных. У Python есть два основных встроенных числовых класса,
# реализующих типы для целых чисел и чисел с плавающей запятой. Они называются int и float. Стандартные арифметические
# операции +, -, *, /, и ** (возведение в степень) могут использоваться со скобками, задающими порядок операций,
# отличный от обусловленного обычным приоритетом операторов. Другими полезными операциями являются операторы получения
# остатка от деления % и собственно целочисленного деления //. Обратите внимание, что при делении двух целых чисел
# результат - число с плавающей запятой. Оператор целочисленного деления возвращает целую часть частного путем отсечения
# от нее дробной части.
print(2 + 3 * 4)
print((2 + 3) * 4)
print(2 ** 10)
print(6 / 3)
print(7 / 3)
print(7 // 3)
print(7 % 3)
print(3 / 6)
print(3 // 6)
print(3 % 6)
print(2 ** 100)
# Логический тип данных, реализованный в Python как класс bool, будет весьма полезен для представления значений
# истинности. Возможными значениями для логического объекта являются True и False со стандартными булевыми операторами
# and, or и not.
print(True)
print(False)
print(False or True)
print(not (False or True))
print(True and True)
# Объекты булева типа данных также используются в качестве результатов операций сравнения (например, "равно" (==) и
# "больше, чем" (>)). Кроме того, операторы отношений и логических операций могут быть скомбинированы вместе в форме
# сложных логических вопросов.
# Операторы отношений и логические операторы:
print('Операторы отношений и логические операторы:')
# <   - Меньше           - Оператор "меньше"
# >   - Больше           - Оператор "больше"
# <=  - Меньше или равно - Оператор "меньше или равно"
# >=  - Больше или равно - Оператор "больше или равно"
# ==  - Равно            - Оператор равенства
# !=  - Не равно         - Оператор неравенства
# and - Логическое "И"   - Если оба операнда истинны, то результат тоже истина
# or  - Логическое "ИЛИ" - Если хотя бы один из операндов истина, то результат - истина
# not - Логическое "НЕ"  - Инвертирует значение: False становится True и наоборот
print(5 == 10)
print(10 > 5)
print((5 >= 1) and (5 <= 10))
# В качестве имен в языках программирования используются идентификаторы. В Python они начинаются с буквы или символа
# подчеркивания (_), чувствительны к регистру и могут быть произвольной длины. Не забывайте о том, что давать имена,
# отражающие смысл переменной, - всегда здравая идея, делающая ваш код более простым для чтения и понимания.
# В Python переменная создается при первом использовании имени с левой стороны от оператора присваивания. Присваивание
# предоставляет возможность ассоциировать имя со значением. Переменная будет содержать ссылку на кусочек данных, а не
# сами данные.
the_sum = 0
print(the_sum)
the_sum = the_sum + 1
print(the_sum)
the_sum = True
print(the_sum)
# Присваивание theSum = 0 создает переменную с именем theSum, содержащую ссылку на объект данных 0. В целом, когда
# правая часть оператора присваивания вычисляется, ссылка на результат "назначается" имени в левой части. В данный
# момент в нашем примере тип переменной - целое, и это тип данных, на которые сейчас ссылается theSum. Если он
# изменится, как показано выше, на булево значение True, то изменится и тип переменной (сейчас theSum имеет тип bool).
# Оператор присваивания меняет ссылки, хранящиеся в переменной. Это динамическая характеристика Python. Одна и та же
# переменная может ссылаться на различные типы данных.


# Встроенные составные типы данных
print('Встроенные составные типы данных:')
# Кроме числовых и булева типов у Python есть несколько мощных встроенных составных классов. Списки, строки и кортежи
# являются упорядоченными коллекциями. Они весьма схожи по общей структуре, но имеют специфические различия, понимать
# которые необходимо для уместного их использования. К неупорядоченным коллекциям относятся множества и словари.

# Список - это упорядоченная коллекция из нуля или более ссылок на объекты данных Python. Списки записываются как
# разделенные запятыми значения, заключенные в квадратные скобки. Пустой список выглядит просто []. Списки гетерогенны.
# Это означает, что их объекты не обязательно должны иметь один и тот же тип, и коллекция может быть присвоена
# переменной, как показано ниже. Следующий фрагмент показывает различные объекты данных Python, объединенные в список.
print('Список:')
print([1, 3, True, 6.5])
my_list = [1, 3, True, 6.5]
print(my_list)
# Обратите внимание, что результатом вычисления списка в Python является он сам. Тем не менее, чтобы запомнить список
# для последующей обработки, ссылка на него должна быть присвоена переменной. Поскольку списки считаются последовательно
# упорядоченными, то они поддерживают ряд операций, которые могут быть применены к любой Python-последовательности.
# Операции для любой последовательности в Python:
print('Операции для любой последовательности в Python:')
# []  - Индексирование          - Доступ к элементу последовательности
# +   - Конкатенация            - Объединение двух последовательностей
# *   - Повторение              - Конкатенация повторений заданное количество раз
# in  - Принадлежность элемента	- Запрос о принадлежности элемента данной последовательности
# len - Длина                   - Запрос количества элементов в последовательности
# [:] - Срез                    - Выделение части последовательности
# Обратите внимание, что индексы элементов списка начинаются с 0. Операция среза my_list[1:3] возвращает список,
# начинающийся с элемента под индексом 1, но при этом не включает в себя элемент под индексом 3.
# Иногда у вас может возникнуть желание проинициализировать список. Этого легко достичь, используя повторения.
my_list = [0] * 6
print(my_list)
# Одно важное отступление, касающееся оператора повторения: его результатом будет последовательность повторений ссылок
# на объект данных. Это хорошо видно в следующем примере:
my_list = [1, 2, 3, 4]
A = [my_list] * 3
print(A)
my_list[2] = 45
print(A)
# Переменная А содержит коллекцию из трех ссылок на оригинальный список my_list. Обратите внимание, что изменение одного
# элемента в my_list отражается на всех трех вхождениях в А. Списки поддерживают ряд методов, которые будут
# использоваться для построения структур данных.
# Методы, предусмотренные для списков в Python
print('Методы, предусмотренные для списков в Python:')
# append  - a_list.append(item)   - Добавить новый элемент в конец списка
# insert  - a_list.insert(i,item) - Вставить элемент в i-ую позицию списка
# pop     - a_list.pop()          - Удалить из списка и вернуть последний элемент
# pop     - a_list.pop(i)         - Удалить из списка и вернуть i-й элемент
# sort    - a_list.sort()         - Отсортировать список (изменяет оригинал)
# reverse - a_list.reverse()      - Изменить список, чтобы элементы шли в обратном порядке
# del     - del a_list[i]         - Удалить элемент на i-й позиции
# index   - a_list.index(item)    - Вернуть индекс первого вхождения item
# count   - a_list.count(item)    - Вернуть число вхождений item в список
# remove  - a_list.remove(item)   - Удалить первое вхождения item
my_list = [1024, 3, True, 6.5]
my_list.append(False)
print(my_list)
my_list.insert(2, 4.5)
print(my_list)
print(my_list.pop())
print(my_list)
print(my_list.pop(1))
print(my_list)
my_list.pop(2)
print(my_list)
my_list.sort()
print(my_list)
my_list.reverse()
print(my_list)
print(my_list.count(6.5))
print(my_list.index(4.5))
my_list.remove(6.5)
print(my_list)
del my_list[0]
print(my_list)
# Как вы можете видеть, некоторые методы (например, pop) возвращают значение и при этом модифицируют список. Другие
# (как reverse) просто изменяют список. По умолчанию pop применяется к концу списка, но может также удалять и возвращать
# конкретное значение. Для всех этих методов индексация по прежнему начинается с нуля. Вы также могли отметить знакомую
# "dot"-нотацию, запрашивающую у объекта вызов метода. myList.append(False) можно прочитать как "запросить у объекта
# myList, выполнить его метод append, с чей помощью добавить в список значение False". Даже такие простые объекты
# данных, как целые числа, могут вызывать свои методы подобным образом.
print((54).__add__(21))
# В этом фрагменте мы просим объект целочисленного типа 54 выполнить его метод add (в Python называется __add__),
# передав в него 21, как число, которое нужно прибавить. Результатом будет сумма 75. Конечно, обычно мы это пишем как
# 54+21. Подробнее об этих методах мы поговорим чуть позже.
# Еще одной распространенной функцией, часто обсуждаемой в связке со списками, является функция range. Она производит
# объект "диапазон", представляющий из себя последовательность значений. Используя функцию list, можно представить
# значение такого объекта в виде списка. Это проиллюстрировано ниже:
print(range(10))
print(list(range(10)))
print(range(5, 10))
print(list(range(5, 10)))
print(list(range(5, 10, 2)))
print(list(range(10, 1, -1)))
# Объект "диапазон" представляет из себя последовательность целых чисел. По умолчанию он начинается с нуля. Если вы
# предоставите больше параметров, то он будет начинаться и заканчиваться в конкретных точках и сможет даже пропускать
# некоторые элементы. В нашем первом примере - range(10) - последовательность начинается с 0 и продолжается до 9 (не
# включая 10). Во втором примере - range(5,10) - начинается с 5 и заканчивается 9 (опять же, не включая 10).
# range(5,10,2) работает аналогично, но пропускает каждый второй элемент (10 по прежнему не включается).

# Строки - представляют собой коллекции с последовательным доступом из нуля или более букв, чисел и прочих знаков. Мы
# называем все эти элементы символами. Строковый литерал отличается от идентификатора использованием кавычек (одинарных
# или двойных).
print('Строки:')
print('David')
my_name = 'David'
print(my_name[3])
print(my_name * 2)
print(len(my_name))
# Поскольку строки - это последовательности, то все описанные выше операции будут с ними работать так, как ожидается.
my_name = 'David'
print(my_name.upper())
print(my_name.center(10))
print(my_name.find('v'))
print(my_name.split('v'))
# Из них очень полезным для обработки данных является метод split. Он принимает строку и возвращает список строк,
# используя расщепляющий символ как точку разделения. В нашем примере таковым является v. Если разделитель не указан,
# то split ищет пробельные символы (табуляции, переходы на новую строку и пробелы).
# Методы, предусмотренные для строк в Python
print('Методы, предусмотренные для строк в Python:')
# center - a_string.center(w)    - Возвращает строку, центрированную в поле размера w
# count  - a_string.count(item)  - Возвращает число вхождений item в строку
# ljust  - a_string.ljust(w)     - Возвращает строку с выравниванием по левому краю поля размером w
# lower  - a_string.lower()      - Возвращает строку из символов в нижнем регистре
# rjust  - a_string.rjust(w)     - Возвращает строку с выравниванием по правому краю поля размером w
# find   - a_string.find(item)   - Возвращает индекс первого вхождения item
# split  - a_string.split(schar) - Разбивает строку на подстроки по символу schar
# Основное различие между списками и строками заключается в том, что списки можно изменять, а строки - нет. Это
# свойство называется изменяемостью. Списки изменяемы, строки неизменяемы. Например, вы легко можете изменить элемент
# списка, используя индексацию и присваивание. Для строк такие операции не допускаются.

# Кортежи - очень похожи на списки тем, что также являются гетерогенными последовательностями данных. Различие
# заключается в неизменяемости кортежей подобно строкам. Они не могут быть изменены. Кортежи записываются как
# разделенные запятыми значения, заключенные в круглые скобки. Будучи последовательностями, они могут использовать
# любые операции, описанные выше.
print('Кортежи:')
my_tuple = (2, True, 4.96)
print(my_tuple)
print(len(my_tuple))
print(my_tuple[0])
print(my_tuple * 3)
print(my_tuple[0:2])
# Однако, если вы попытаетесь изменить элемент кортежа, то получите сообщение об ошибке. Обратите внимание, что такое
# сообщение содержит место и причину возникновения проблемы.

# Множество - это неупорядоченная коллекция из нуля или более неизменяемых объектов данных Python. Множества не
# допускают дубликатов и записываются как разделенные запятыми значения, заключенные в фигурные скобки. Пустое множество
# обозначается как set(). Множества гетерогенны и могут присваиваться переменным, как показано ниже.
print('Множество:')
print({3, 6, 'cat', 4.5, False})
my_set = {3, 6, 'cat', 4.5, False}
print(my_set)
# Не смотря на то, что множества не считаются последовательностями, они поддерживают некоторые знакомые операции из
# рассмотренных выше.
print('Операции, предусмотренные для множеств в Python:')
# membership - in               - Принадлежность множеству
# length     - len              - Возвращает количество элементов множества
# |          - a_set | otherset  - Возвращает новое множество, содержащее все элементы обоих множеств
# &          - a_set & otherset  - Возвращает новое множество из элементов, общих для обоих множеств
# -          - a_set - otherset  - Возвращает новое множество из элементов первого множества, не входящих во второе
# <=         - a_set <= otherset - Спрашивает, все ли элементы первого множества входят во второе
print(my_set)
print(len(my_set))
print(False in my_set)
print('dog' in my_set)
# Множества поддерживают некоторые операции, которые будут знакомы тем, кто работал с ними в области математики.
# Обратите внимание, что union, intersection, issubset и difference имеют специальные операторы, которые можно
# использовать вместо них.
# Методы, предусмотренные для множеств в Python
print('Методы, предусмотренные для множеств в Python:')
# union        - a_set.union(otherset)        - Возвращает новое множество, состоящее из всех элементов обоих исходных
#                                              множеств
# intersection - a_set.intersection(otherset) - Возвращает новое множество, состоящее только из элементов, общих для
#                                              обоих исходных множеств
# difference   - a_set.difference(otherset)   - Возвращает новое множество, содержащее все элементы первого множества,
#                                              не принадлежащие второму
# issubset     - a_set.issubset(otherset)     - Спрашивает, все ли элементы первого множества входят во второе
# add          - a_set.add(item)              - Добавляет новый элемент в множество
# remove       - a_set.remove(item)           - Удаляет элемент из множества
# pop          - a_set.pop()                  - Удаляет произвольный элемент из множества
# clear        - a_set.clear()                - Удаляет все элементы из множества
print(my_set)
your_set = {99, 3, 100}
print(my_set.union(your_set))
print(my_set | your_set)
print(my_set.intersection(your_set))
print(my_set & your_set)
print(my_set.difference(your_set))
print(my_set - your_set)
print({3, 100}.issubset(your_set))
print({3, 100} <= your_set)
my_set.add('house')
print(my_set)
my_set.remove(4.5)
print(my_set)
print(my_set.pop())
print(my_set)
my_set.clear()
print(my_set)

# Словари - это коллекции ассоциированных пар элементов, каждая из которых состоит из ключа и значения. Эти пары обычно
# записываются как ключ: значение. Словари выглядят, как разделенные запятыми пары ключ:значение, заключенные в фигурные
# скобки.
print('Словари:')
capitals = {'Iowa': 'DesMoines', 'Wisconsin': 'Madison'}
print(capitals)
# Мы можем манипулировать словарем с помощью доступа к значению по его ключу или добавляя еще одну пару ключ-значение.
# Синтаксис доступа выглядит очень похоже на аналогичный для последовательностей, за исключением того момента, что
# вместо индекса элемента, мы используем его ключ. Добавление новых элементов тоже похоже.
capitals = {'Iowa': 'DesMoines', 'Wisconsin': 'Madison'}
print(capitals['Iowa'])
capitals['Utah'] = 'SaltLakeCity'
print(capitals)
capitals['California'] = 'Sacramento'
print(len(capitals))
for k in capitals:
    print(capitals[k], 'is the capital of', k)
# Тут очень важно обратить внимание, что словари не поддерживают какого-то определенного порядка для своих ключей.
# Первая добавленная пара ('Utah': 'SaltLakeCity') будет помещена на первое место в словаре, вторая
# ('California': 'Sacramento') - на последнее. Размещение ключей зависит от идеи "хэширования". Бонусом мы
# продемонстрировали, что функция определения длины последовательности работает также, как и для предыдущих коллекций.
# Словари имеют и методы, и операторы. Методы keys, values и items возвращают объекты, содержащие интересующие нас
# значения. Вы можете использовать функцию list, чтобы конвертировать их в списки. Также показаны два варианта метода
# get. Если ключ не представлен в словаре, то get вернет None. Однако, второй (опциональный) параметр может определять
# другое значение, возвращаемое в этом случае.
# Операторы для работы со словарями в Python
print('Операторы для работы со словарями в Python:')
# []  - myDict[k]      - Возвращает значение, ассоциированное с k, или ошибку, если такового не существует
# in  - key in a_dict   - Возвращает True, если значение есть в словаре, False в противном случае
# del - del a_dict[key] - Удаляет запись из словаря
phoneext = {'david': 1410, 'brad': 1137}
print(phoneext)
print(phoneext.keys())
print(list(phoneext.keys()))
print(phoneext.values())
print(list(phoneext.values()))
print(phoneext.items())
print(list(phoneext.items()))
print(phoneext.get('kent'))
print(phoneext.get('kent', 'NO ENTRY'))
# Методы, предусмотренные для словарей в Python
print('Методы, предусмотренные для словарей в Python:')
# keys   - a_dict.keys()     - Возвращает ключи словаря как объект dict_keys
# values - a_dict.values()   - Возвращает значения словаря как объект dict_values
# items  - a_dict.items()    - Возвращает пары ключ-значение как объект dict_items
# get    - a_dict.get(k)     - Возвращает значение, ассоциированное с k, или None, если таковое не найдено
# get    - a_dict.get(k,alt) - Возвращает значение, ассоциированное с k, или alt, если такое не найдено


# Ввод и вывод
print('Ввод и вывод:')
# У нас часто возникает необходимость взаимодействовать с пользователями: получать от них данные или предоставлять им
# какой-либо результат. Большинство программ в наши дни использует диалоговые окна в качестве способа запроса у клиента
# каких-либо входных данных. Хотя Python умеет создавать такие окна, мы будем использовать более простой способ. Python
# предоставляет нам функцию, позволяющую просить пользователя ввести какую-то информацию и возвращать ему ссылку на
# данные в строковом формате. Эта функция называется input.
# Она принимает в качестве своего единственного параметра строку, которую часто называют "приглашением ввода", поскольку
# она содержит вспомогательную текстовую подсказку для пользователя о том, что ему надо ввести. Например, вы можете
# вызвать input следующим образом:
# a_name = input('Please enter your name: ')
# Теперь, что бы пользователь ни написал после приглашения, оно будет сохранено в переменной a_name. Используя функцию
# ввода, мы легко можем писать инструкции, которые будут подсказывать, какие данные вводить, и включать их в дальнейшую
# обработку. Например, в следующих двух строках в первой у пользователя спрашивается его имя, а вторая печатает
# результат простейшей обработки полученной строки.
# a_name = input('Please enter your name: ')
a_name = 'Sergio'
print('Your name in all capitals is', a_name.upper(), 'and has length', len(a_name))
# Очень важно обратить внимание на то, что значение, возвращаемое input, представляет собой строку, состоящую из точно
# тех символов, которые были введены после приглашения. Если вы хотите, чтобы она интерпретировалась как другой тип, то
# вам следует осуществить явное преобразование типов. В коде ниже строка, введенная пользователем, преобразовывается в
# число с плавающей запятой, что может быть использовано в дальнейших арифметических вычислениях.
# s_radius = input('Please enter the radius of the circle ')
# radius = float(s_radius)
# diameter = 2 * radius


# Форматирование строки
print('Форматирование строки:')
# Мы уже видели, что функция print предоставляет очень простой способ для вывода значений в программе на Python. Она
# принимает нуль или более параметров и выводит их, используя пробелы в качестве разделителей по умолчанию. Символ
# разделителя можно изменить по своему вкусу, установив аргумент sep. Так же каждый вывод print заканчивается
# автоматическим переходом на новую строку. Это поведение можно изменить, задав аргумент end. Оба этих варианта
# продемонстрированы в коде ниже:
print('Hello')
print('Hello', 'World')
print('Hello', 'World', sep='***')
print('Hello', 'World', end='***')
print()
# Часто бывает полезно иметь больше способов управления внешним видом вашего вывода. К счастью, Python предоставляет
# нам альтернативу под названием "форматированная строка". Она представляет из себя шаблон, содержащий слова и пробелы,
# остающиеся неизменными, и заменители для переменных, которые будут подставлены в строку. Например, следующий код
a_name = 'Sergio'
age = 34
print(a_name, 'is', age, 'years old.')
# содержит слова is и years old, но имя и возраст будут меняться в зависимости от значений переменных во время
# выполнения программы. Используя форматирование строк, мы можем записать этот код как
print('%s is %d years old.' % (a_name, age))
# Этот простой пример наглядно иллюстрирует новой выражение для строк. % является строковым оператором и называется
# "оператор форматирования". Левая часть выражения содержит шаблон или строку формата, а правая - коллекцию значений,
# которые будут в нее подставлены. Заметьте, что число значений в правой коллекции равно количеству символов % в строке
# форматирования. Эти значения будут по порядку (слева направо) извлекаться из коллекции и подставляться в строку
# форматирования.
# Давайте рассмотрим обе части выражения для форматирования более детально. Строка форматирования может содержать один
# или более спецификаторов преобразования. Символ преобразования говорит оператору форматирования о типе значения,
# которое будет подставлено в эту позицию. В примере выше %s означает строку, в то время как %d - целое число. Другие
# возможные типы спецификаторов включают i, u, f, e, g, c или %.
# Символы преобразования для строк форматирования
print('Символы преобразования для строк форматирования:')
# d, i - Целое
# u    - Беззнаковое целое
# f    - Вещественное с плавающей запятой в формате m.ddddd
# e    - Вещественное с плавающей запятой в формате m.ddddde+/-xx
# E    - Вещественное с плавающей запятой в формате m.dddddE+/-xx
# g    - Использует %e для степеней меньше -4 и больше +5. В остальных случаях работает как %f
# c    - Одиночный символ
# s    - Строка или любой объект данных Python, который может быть конвертирован в строку с помощью функции str
# %    - Вставляет символ %
# В дополнение к символу форматирования вы также можете включать модификатор формата между % и символом форматирования.
# Модификаторы формата могут использоваться для задания левому или правому краю значения определенной длины. Также их
# можно использовать, чтобы задать ширину поля вместе с количеством цифр после запятой.
# Дополнительные опции форматирования
print('Дополнительные опции форматирования:')
# number - %20d     - Помещает значение в поле шириной 20 символов
# -      - %-20d    - Помещает значение в поле шириной 20 символов выровненным по левому краю
# +      - %+20d    - Помещает значение в поле шириной 20 символов выровненным по правому краю
# 0      - %020d    - Помещает значение в поле шириной 20 символов, изначально заполненное нулями
# .      - %20.2f   - Помещает значение в поле шириной 20 символов с двумя символами справа от десятичной точки
# (name) - %(name)d - Берет значение из прилагаемого словаря, используя name в качестве ключа
# Правая часть оператора форматирования представляет собой коллекцию значений, которые будут подставлены в строку
# форматирования. Такой коллекцией могут быть кортеж или словарь. Если коллекция - кортеж, то значения вставляются по
# порядку. Т.е. первый элемент кортежа соответствует первому символу форматирования в строке формата. Если коллекция -
# словарь, то значения вставляются в соответствии с их ключами. В этом случае все символы форматирования должны
# использовать модификатор (name), определяющий имя ключа.
price = 24
item = 'banana'
print('The %s costs %d cents' % (item, price))
print('The %+10s costs %5.2f cents' % (item, price))
print('The %+10s costs %10.2f cents' % (item, price))
itemdict = {'item': 'banana', 'cost': 24}
print('The %(item)s costs %(cost)7.1f cents' % itemdict)
# В дополнение к строкам форматирования, использующим символы и модификаторы форматирования, тип string в Python также
# имеет метод format, который может использоваться совместно с новым классом Formatter для сложного строкового
# форматирования. Больше об этих особенностях вы сможете найти по ссылке на руководство для библиотек Python.


# Управляющие структуры
print('Управляющие структуры:')
# Как мы уже отмечали ранее, алгоритмам требуются две важные управляющие структуры: для итераций и для выбора. Обе они
# поддерживаются в Python в различных формах. Программисты могут выбирать тот способ, который будет более уместным в
# данных обстоятельствах.
# Для итераций Python предлагает стандартный оператор while и очень мощный оператор for. Первый из них повторяет тело
# кода столько раз, сколько остается истинным его условие.
counter = 1
while counter <= 5:
    print('Hello, world')
    counter = counter + 1
# Напечатает фразу "Hello, world" пять раз. Условие оператора while вычисляется каждый раз в начале итерации. Если оно
# истинно, то будет выполнено тело оператора. Структуру while в Python легко увидеть через обязательные шаблоны
# отступов, которые навязывает этот язык.
# Оператор while представляет собой итерационную структуру очень общего назначения, которая может использоваться во
# многих различных алгоритмах. Очень часто итерации контролирует составное условие.
# Код приведет к тому, что тело оператора будет вычисляться только в случае, когда будут выполнены обе части условия.
# while counter <= 10 and not done:
# ...
# Значение переменной counter должно быть меньше или равно 10, а значение переменной done - быть равным False (not False
# - это True), чтобы результат True and True тоже был истиной.
# Несмотря на то, что этот тип конструкции широко применяется во многих ситуациях, другая итеративная структура -
# оператор for - может быть использована в связке со многими коллекциями Python. for можно пользоваться для итерации по
# членам коллекции, если она является последовательной.
for item in [1, 3, 6, 2, 5]:
    print(item)
# присваивает переменной item каждое последующее значение из списка [1, 3, 6, 2, 5], после чего выполняется тело цикла.
# Этот способ работает для любой последовательной коллекции (списков, кортежей и строк).
# Общее применение оператора for заключается в том, чтобы реализовывать определенную итерацию на диапазоне значений.
# Оператор выполнит функцию print пять раз. Функция range вернет диапазон, представляющий собой последовательность
# 0, 1, 2, 3, 4, и каждое из этих значений будет присвоено переменной item. Затем они будут возведены в квадрат и
# напечатаны
for item in range(5):
    print(item ** 2)
# Другой очень полезной версией использования этой итерационной структуры является обработка каждого символа строки.
# Следующий фрагмент кода проходит по списку строк, обрабатывая каждый символ в них присоединением его к списку.
# Результатом будет список символов из всех слов.
word_list = ['cat', 'dog', 'rabbit']
letter_list = []
for a_word in word_list:
    for a_letter in a_word:
        letter_list.append(a_letter)
print(letter_list)
# Операторы выбора позволяют программистам задавать вопросы и выполнять различные действия, основываясь на ответе.
# Большинство языков программирования предоставляют две версии полезных конструкций: ifelse и if. Простой пример
# бинарного использования оператора ifelse:
# if n < 0:
#    print('Sorry, value is negative')
# else:
#    print(math.sqrt(n))
# В этом примере объект, ссылающийся на n, проверяется на условие "меньше нуля". Если это так, то печатается сообщение,
# что n - отрицательное число. В противном случае выполняется ветка else, в которой вычисляется квадратный корень.
# Операторы выбора, как и любые управляющие конструкции, могут быть вложенными, чтобы результат одного ответа помогал
# определить, как ответить на следующий. Например, предположим, что score - это переменная, содержащая ссылку на
# результат теста по информатике.
# if score >= 90:
#    print('A')
# else:
#    if score >= 80:
#       print('B')
#    else:
#       if score >= 70:
#          print('C')
#       else:
#          if score >= 60:
#             print('D')
#          else:
#             print('F')
# Этот фрагмент будет классифицировать значение переменной score с помощью вывода на печать буквы заработанной оценки.
# Если счет выше или равен 90, то оператор напечатает А. Если это не так (else), то проверяется следующее условие. Если
# счет выше или равен 80, то он должен лежать между 80 и 89, поскольку ответ на предыдущий вопрос был ложью. В этом
# случае печатается В. Вы можете видеть, как шаблоны отступов в Python помогают ассоциировать if и else без
# использования дополнительных синтаксических элементов.
# Альтернативным синтаксисом для вложенного таким образом выбора является использование ключевого слова elif. else и
# последующий if комбинируются, исключая дополнительные уровни. Заметьте, конечное else по-прежнему необходимо, чтобы
# предоставить случай по умолчанию, если все остальные условия не выполнятся.
# if score >= 90:
#    print('A')
# elif score >= 80:
#    print('B')
# elif score >= 70:
#    print('C')
# elif score >= 60:
#    print('D')
# else:
#    print('F')
# Python также имеет вариант единичной конструкции выбора - оператор if. Для него при истинности условия происходит
# выполнение действия. В противном случае процесс обработки просто переходит на следующий после if оператор. Например,
# в коде ниже сначала проверяется на отрицательность значение n. Если условие выполнено, то n заменяют абсолютным
# значением. Но в любом случае следующее действие - это извлечение квадратного корня.
# if n < 0:
#    n = abs(n)
# print(math.sqrt(n))
# Самопроверка
# Проверьте свое понимание изложенного материала, попробовав решить следующее упражнение. Измените код из переменной
# letter_list таким образом, чтобы итоговый список содержал единственную копию каждой буквы.
word_list = ['cat', 'dog', 'rabbit']
letter_list = []
for a_word in word_list:
    for a_letter in a_word:
        if a_letter not in letter_list:
            letter_list.append(a_letter)
print(letter_list)
# Возвращаясь к спискам, приведем альтернативный метод их создания с использованием итерационных конструкций и
# конструкций выбора. Он известен, как генератор списков, и позволяет легко создавать списки, основываясь на неких
# критериях обработки и выбора. Например, если мы захотим получить список из первых десяти идеальных квадратов, то можем
# воспользоваться оператором for:
sqlist = []
for x in range(1, 11):
    sqlist.append(x * x)
print(sqlist)
# А с использованием генератора списков это делается одной строкой:
sqlist = [x * x for x in range(1, 11)]
print(sqlist)
# Переменная x принимает значения от 1 до 10, как это определено для конструкции for. Затем вычисляется величина x * x
# и присоединяется к создаваемому списку. Общий синтаксис генераторов списков также разрешает использовать критерий
# выбора, чтобы добавлялись только подходящие элементы.
sqlist = [x * x for x in range(1, 11) if x % 2 != 0]
print(sqlist)
# Этот генератор создает список, содержащий квадраты только нечетных чисел в диапазоне от 1 до 10. Совместно с
# генераторами списков можно использовать любые последовательности, поддерживающие итерации. Результатом будет новый
# список.
print([ch.upper() for ch in 'comprehension' if ch not in 'aeiou'])
# Самопроверка
# Проверьте свое понимание генераторов списков, переделав переменную letter_list с их использованием. Дополнительное
# задание: придумайте, как можно удалить дубликаты.
word_list = ['cat', 'dog', 'rabbit']
letter_list = []
for a_word in ''.join(word_list):
    if a_word not in letter_list:
        letter_list.append(a_word)
print(letter_list)


# Обработка исключений
print('Обработка исключений:')
# Существует два типа ошибок, которые обычно возникают при написании программы. Первый известен как синтаксические
# ошибки, когда программист ошибается в написании структуры оператора или выражения. Вот пример неправильно написанного
# оператора и пропущенного двоеточия:
# >>> for i in range(10)
# SyntaxError: invalid syntax (<pyshell#61>, line 1)
# В этом случае интерпретатор Python находит, что не может выполнить эту инструкцию до тех пор, пока она не будет
# удовлетворять языковым правилам. Чаще всего синтаксические ошибки встречаются, когда вы только начинаете изучать новый
# язык программирования.
# Другой тип, известный как логические ошибки, имеет отношение к тем ситуациям, когда код выполняется, но выдает
# неправильный результат. Причиной может быть ошибка в основном алгоритме или неверная трансляция вами этого алгоритма.
# В некоторых случаях логические ошибки приводят к очень плохим ситуациям: делению на нуль или попыткам получить доступ
# к элементу списка, чей индекс выходит за границы списка. В таком случае логическая ошибка влечет за собой ошибку
# времени выполнения, которая вызывает завершение программы. Ошибки такого типа во время выполнения обычно называют
# исключениями.
# Большую часть времени начинающие программисты думают об исключениях, как о фатальных ошибках во время выполнения,
# приводящих экстренному завершению программы. Однако, большинство языков программирования предоставляют способ иметь
# дело с вещами такого рода, что позволяет программисту вмешиваться в процесс, если он того пожелает. Более того,
# программисты могут создавать свои собственные исключения, если они обнаруживают в программе ситуацию, когда это может
# быть оправдано.
# Когда возникает исключение, мы говорим, что оно "вызывается". Вы можете "обработать" вызванное исключение, используя
# оператор try. Рассмотрим, например, следующий код, который запрашивает у пользователя целое число, а затем вызывает
# функцию извлечения квадратного корня из математической библиотеки. Если пользователь вводит значение, которое больше
# или равно нулю, print выведет квадратный корень. Однако, если пользователь введет отрицательное значение, то функция
# квадратного корня сообщит об исключении ValueError.
# a_number = int(input("Please enter an integer "))
# Please enter an integer -23
# print(math.sqrt(a_number))
# Traceback (most recent call last):
#   File "<pyshell#102>", line 1, in <module>
#     print(math.sqrt(a_number))
# ValueError: math domain error
# Мы можем обработать это исключение, вызвав функцию print внутри блока try. Соответствующий except-блок "поймает"
# исключение и напечатает сообщение пользователю, в котором сообщит о возникновении исключения.
# try:
#   print(math.sqrt(a_number))
# except:
#   print("Bad Value for square root")
#   print("Using absolute value instead")
#   print(math.sqrt(abs(a_number)))
# Поймает тот факт, что при выполнении sqrt возникло исключение, напечатает сообщение об этом пользователю и возьмет
# абсолютное значение аргумента, чтобы быть уверенным в его неотрицательности. Все вместе это означает, что программа
# не завершится, а продолжит выполнение следующих операторов.
# У программиста также существует возможность искусственно вызвать исключение во время выполнения, используя оператор
# raise. Например, вместо вызова функции квадратного корня для отрицательного числа, мы прежде можем проверить значение
# и вызвать наше собственное исключение. Код ниже показывает результат создания нового исключения RuntimeError.
# Заметьте, что программа по-прежнему будет завершаться, но теперь исключением, вызывающим такое поведение, является
# нечто явно созданное программистом.
# if a_number < 0:
#   raise RuntimeError("You can't use a negative number")
# else:
#   print(math.sqrt(a_number))
# Traceback (most recent call last):
#   File "<stdin>", line 2, in <module>
# RuntimeError: You can't use a negative number
# Существует множество типов исключений кроме показанного выше RuntimeError , которые могут быть вызваны. Смотрите
# ссылку на руководство по Python, где представлены список всех доступных типов исключений и инструкция по созданию
# своих собственных.


# Определение функций
print('Определение функций:')
# Предыдущим примером вызова процедурной абстракции Python была функция sqrt для вычисления квадратного корня из модуля
# math. Вообще говоря, мы можем скрывать детали любого вычисления с помощью определения функции. Оно требует ее имя,
# группу параметров и тело. Также функция может явно возвращать значение. Например, простая функция, определенная ниже,
# возвращает квадрат значения, которое вы в нее помещаете.


def square(n):
    return n**2


print(square(3))
print(square(square(3)))
# Синтаксис этого определения включает имя (square) и заключенный в скобки список формальных параметров. Для этой
# функции n - всего лишь формальный параметр, предполагающий, что square необходим только один элемент данных для ее
# работы. Детали, скрытые "внутри ящика", просто вычисляют результат n**2 и возвращают его. Мы можем вызвать функцию
# square, попросив среду разработки Python вычислить ее и поместив внутрь актуальное значение параметра (3 в данном
# случае). Заметьте, что вызов square возвращает целое, которое потом может быть передано другому вызову.
# Мы можем реализовать нашу собственную функцию извлечения квадратного корня, используя хорошо известную технологию под
# названием "метод Ньютона". Этот метод получения приблизительного значения квадратного корня представляет собой
# итеративное вычисление, сходящееся к правильному значению. Уравнение new_guess = 1 / 2 ∗ (old_guess + n / old_guess)
# принимает значение n и в цикле угадывает квадратный корень, создавая каждую new_guess из old_guess, полученной на
# предыдущей итерации. Первоначальная догадка равна n2. Еще раз, детали метода Ньютона скрыты внутри определения
# функции, и пользователь ничего не знает о реализации, когда использует функцию по ее прямому назначению.
# Демонстрация использования символа #, как маркера комментария. Любые символы, идущие в строке после #, игнорируются.


def square_root(n):
    root = n/2    # первоначальная догадка должна составлять 1/2 от n
    for i in range(20):
        root = (1 / 2) * (root + n / root)
    return root


print(square_root(9))
print(square_root(4563))
# Самопроверка
# Это задание охватывает весь изложенный выше материал. Вы когда-нибудь слышали про теорему о бесконечных обезьянах? В
# ней утверждается, что если обезьяна будет беспорядочно нажимать на клавиши клавиатуры бесконечное количество времени,
# то рано или поздно напечатает заданный текст (например, полное собрание сочинений Вильяма Шекспира). Что ж,
# предположим, что мы заменяем обезьяну функцией на Python. Как вы думаете, сколько она потратит времени на
# генерирование хотя бы одного предложения из Шекспира? Выберем для проверки фразу "methinks it is like a weasel".
# Вам наверняка не захочется запускать эту программу в браузере, так что запускайте вашу любимую Python IDE. Симуляция
# будет выполняться с помощью функции, генерирующей строку из двадцати семи символов путем случайного выбора из
# двадцати шести букв алфавита + пробел. Мы напишем еще одну функцию, которая будет оценивать каждую сгенерированную
# строку, сравнивая ее с целью.
# Третья функция будет циклично вызывать генератор и оценщик до тех пор, пока не совпадет 100% букв. В случае
# несовпадения будет генерироваться новая строка целиком. Чтобы было проще следить за прогрессом программы, эта третья
# функция должна печатать лучшую из уже сгенерированных строк и ее оценку каждые тысячу попыток.
# Усложненное задание для самопроверки
# Посмотрите, сможете ли вы улучшить программу из самопроверки, сохраняя правильно стоящие буквы и изменяя всего лишь
# одну из оставшихся, чтобы приблизиться к результату. Алгоритм такого типа относится к классу "поиска с восхождением к
# вершине", в котором результат сохраняется только в том случае, если он лучше предыдущего.


# Объектно-ориентированное программирование в Python: определение классов
print('Объектно-ориентированное программирование в Python: определение классов:')
# Ранее уже говорилось, что Python является объектно-ориентированным языком. До сих пор мы использовали только несколько
# встроенных классов для демонстрации типов данных и управляющих структур. Одной из наиболее мощных черт
# объектно-ориентированного языка является его способность предоставить программисту возможность создавать новые классы,
# моделирующие данные, необходимые для решения задачи.
# Не забывайте: мы используем абстрактные типы данных, чтобы предоставить логическое описание того, как выглядят объекты
# данных (их состояние) и что они могут делать (их методы). Создавая класс, воплощающий АТД, программист пользуется
# преимуществами абстракции процесса и в то же время предоставляет детали, необходимые для конкретного использования ее
# в программе. Всякий раз, когда мы хотим реализовать абстрактный тип данных, мы делаем это через новый класс.


# Класс Fraction
print('Класс Fraction:')
# Очень распространенным примером для демонстрации деталей реализации пользовательского класса является разработка
# класса, воплощающего АТД Fraction. Мы уже видели, что Python предоставляет в наше пользование несколько числовых
# классов. Однако, бывают моменты, когда более подходящим является создание объекта данных лишь "выглядящего как" дробь.
# Дробь (например, ) состоит из двух частей. Верхнее значение, называемое числитель, может быть
# любым целым числом. Нижнее значение (знаменатель) - любым целым, большим нуля (отрицательные дроби имеют отрицательный
# числитель). Также для любой дроби можно создать приближение с плавающей запятой. В этом случае мы хотели бы
# представлять дробь как точное значение.
# Операции для типа Fraction будут позволять его объектам данных вести себя подобно любым другим числовым значениям.
# Мы должны быть готовы складывать, вычитать, умножать и делить дроби. Также необходима возможность показывать дроби в
# их стандартной "слэш"-форме (например, ). Все методы дробей должны возвращать результат в
# своей сокращенной форме таким образом, чтобы, вне зависимости от вида вычислений, в конце мы всегда имели наиболее
# общепринятую форму.
# В Python мы определяем новый класс предоставлением его имени и набора определений методов, которые синтаксически
# подобны определениям функций. В этом примере нам дан каркас для определения методов. Первым из них (его должны
# предоставлять все классы) является конструктор. Он определяет способ создания объекта данных. Чтобы создать объект
# Fraction, нам нужно предоставить два элемента данных - числитель и знаменатель. В Python метод конструктора всегда
# называется __init__ (по два подчеркивания до и после init).


def gcd(m, n):
    while m % n != 0:
        old_m = m
        old_n = n
        m = old_n
        n = old_m % old_n
    return n


class Fraction:
    def __init__(self, top, bottom):
        self.num = top
        self.den = bottom

    def __str__(self):
        return str(self.num) + '/' + str(self.den)

    def show(self):
        print(self.num, '/', self.den)

    def __add__(self, other_fraction):
        new_num = self.num * other_fraction.den + self.den * other_fraction.num
        new_den = self.den * other_fraction.den
        common = gcd(new_num, new_den)
        return Fraction(new_num // common, new_den // common)

    def __eq__(self, other):
        first_num = self.num * other.den
        second_num = other.num * self.den
        return first_num == second_num


# Обратите внимание, что список формальных параметров содержит три элемента (self, top, bottom). self - это специальный
# параметр, который используется, как обратная ссылка на сам объект. Он всегда должен быть первым формальным параметром,
# однако, при вызове конструктора в него никогда не передается актуальное значение. Как было написано ранее, дробям
# нужны данные для двух частей - числителя и знаменателя. Нотация self.num конструктора определяет, что объект fraction
# имеет внутренний объект данных, именуемый num, как часть своего состояния. Аналогично, self.den создает знаменатель.
# Значения этих двух формальных параметров изначально устанавливаются в состояние, позволяющее новому объекту fraction
# знать свое начальное значение.
# Чтобы создать сущность класса Fraction, мы должны вызвать конструктор. Это произойдет при использовании имени класса
# с подстановкой актуальных значений в необходимое состояние (заметьте, что мы никогда не вызываем непосредственно
# __init__).
my_fraction = Fraction(3, 5)
print(my_fraction)
# Следующее, чем мы займемся, это реализация поведения, требуемого абстрактным классом. Для начала рассмотрим, что
# происходит, когда мы пытаемся напечатать объект Fraction.
myf = Fraction(3, 5)
print(myf)
# Объект fraction, myf не знает, как ему отвечать на запрос о печати. Функция print требует, чтобы объект конвертировал
# самого себя в строку, которая будет записана на выходе. Единственный выбор, который имеет myf, - это показать
# актуальную ссылку, хранящуюся в переменной (непосредственный адрес). Это явно не то, что мы хотим.
# Существует два пути решения этой проблемы. Первый - определить метод под названием show, который позволит объекту
# Fraction печать самого себя как строку. Если создавать объект Fraction как и раньше, то можно попросить его показать
# себя (другими словами, напечатать себя) в подходящем формате. К сожалению, в общем случае это не будет работать. Для
# того, чтобы организовать печать должным образом, нам необходимо сообщить классу Fraction, как ему конвертировать себя
# в строку. Это то, что необходимо функции print для нормальной работы.
myf = Fraction(3, 5)
print(myf.show())
# В Python у всех классов имеется набор стандартных методов, которые предоставляются по умолчанию, но могут не работать
# должным образом. Один из них, __str__, - метод преобразования объекта в строку. Реализация по умолчанию для этого
# метода, как мы уже могли видеть, возвращает строку адреса экземпляра класса. Что нам необходимо сделать, так это
# предоставить для него "лучшую" реализацию. Мы будем говорить, что она перегружает предыдущую (или переопределяет
# поведение метода).
# Для этого просто определим метод с именем __str__ и зададим ему новую реализацию. Это определение не нуждается ни в
# какой дополнительной информации, кроме специального параметра self. В свою очередь, метод будет создавать строковое
# представление конвертированием каждого кусочка внутренних данных состояния в строку и конкатенацией этих строк с
# помощью символа / между ними. Результирующая строка будет возвращаться всякий раз, как объект Fraction попросит
# преобразовать себя в строку. Обратите внимание на различные способы использования этой функции.
myf = Fraction(3, 5)
print(myf)
print('I ate', myf, 'of the pizza')
print(myf.__str__())
print(str(myf))
# Мы можем перегрузить множество других методов для нашего нового класса Fraction. Одними из наиболее важных из них
# являются основные арифметические операции. Мы хотели бы иметь возможность создать два объекта Fraction, а затем
# сложить их вместе, используя стандартную запись "+". На данный момент, складывая две дроби, мы получаем следующее:
f1 = Fraction(1, 4)
f2 = Fraction(1, 2)
print(f1 + f2)
# Если вы внимательнее посмотрите на сообщение об ошибке, то заметите - загвоздка в том, что оператор "+" не понимает
# операндов Fraction.
# Мы можем исправить это, предоставив классу Fraction метод, перегружающий сложение. В Python он называется __add__ и
# принимает два параметра. Первый - self- необходим всегда, второй представляет из себя второй операнд выражения
# Будет запрашивать у Fraсtion объекта f1 прибавить к нему Fraction объект f2. Это может быть записано и в стандартной
# нотации f1 + f2.
# Для того, чтобы сложить две дроби, их нужно привести к общему знаменателю. Простейший способ увериться, что у них
# одинаковый знаменатель, - это использовать в его качестве произведение знаменателей дробей. Функция сложения
# возвращает новый объект Fraction с числителем и знаменателем суммарной дроби. Мы можем использовать этот метод при
# написании стандартных арифметических выражений с дробями, присваивая результату суммарную дробь и выводя ее на экран.
f1 = Fraction(1, 4)
f2 = Fraction(1, 2)
f3 = f1 + f2
print(f3)
# Метод сложения работает, как мы того и хотели, но одну вещь можно было бы улучшить. Заметьте, что 6/8 - это правильный
# результат вычисления (1/4 + 1/2), но это не сокращенная форма. Лучшим представлением будет 3/4. Для того, чтобы быть
# уверенными, что результат всегда имеет сокращенный вид, нам понадобится вспомогательная функция, умеющая сокращать
# дроби. В ней нужно будет находить наибольший общий делитель, или НОД. Затем мы сможем разделить числитель и
# знаменатель на НОД, а результат и будет сокращением до наименьших членов.
# Наиболее известный алгоритм нахождения наибольшего общего делителя - это алгоритм Евклида, который будет детально
# обсуждаться в главе 8. Он устанавливает, что наибольшим общим делителем двух чисел m и n будет n, если m делится на
# n нацело. Однако, если этого не происходит, то ответом будет НОД n и остатка деления m на n. Мы просто предоставим
# здесь итеративную реализацию этого алгоритма. Обратите внимание, что она работает только при положительном
# знаменателе. Это допустимо для нашего класса дробей, поскольку мы говорили, что отрицательные дроби будут
# представляться отрицательным числителем.
# def gcd(m, n):
#     while m % n != 0:
#         oldm = m
#         oldn = n
#         m = oldn
#         n = oldm % oldn
#     return n
#
# print gcd(20, 10)
# Теперь можно использовать эту функцию для сокращения любой дроби. Чтобы представить дробь в сокращенном виде, мы будем
# делить числитель и знаменатель на их наибольший общий делитель. Итак, для дроби НОД равен 2. Разделив верх и низ на 2,
# мы получим новую дробь.
f1 = Fraction(1, 4)
f2 = Fraction(1, 2)
f3 = f1 + f2
print(f3)
# Сейчас наш объект Fraction имеет два очень полезных метода. Группа дополнительных методов, которые нам понадобится
# включить в класс Fraction, содержит способ сравнивать две дроби. Предположим, что у нас есть два объекта Fraction f1
# и f2. f1 == f2 будет истиной, если они ссылаются на один и тот же объект. Два разных объекта с одинаковыми числителями
# и знаменателями в этой реализации равны не будут. Это называется поверхностным равенством
# Мы можем создать глубокое равенство - по одинаковому значению, а не по одинаковой ссылке - перегрузив метод __eq__.
# Это еще один стандартный метод, доступный в любом классе. Он сравнивает два объекта и возвращает True, если их
# значения равны, или False в противном случае.
# В классе Fraction мы можем реализовать метод __eq__, вновь представив обе дроби в виде с одинаковым знаменателем и
# затем сравнив их числители. Здесь также важно отметить другие операторы отношений, которые могут быть перегружены.
# Например, метод __le__ предоставляет функционал "меньше или равно".
# Самопроверка
# Чтобы убедиться, что вы понимаете, как в классах Python реализовываются операторы и как корректно писать методы,
# напишите реализацию операций *, / и -. Также реализуйте операторы сравнения > и <.

# Наследование: логические вентили и схемы
print('Наследование: логические вентили и схемы')
# Наш финальный раздел будет посвящен другому важному аспекту объектно-ориентированного программирования. Наследование
# - это способность одного класса быть связанным с другим классом подобно тому, как бывают связаны между собой люди.
# Дети наследуют черты своих родителей. Аналогично, в Python класс-потомок наследует характеристики данных и поведения
# от класса-предка. Такие классы часто называют субклассами и суперклассами, соответственно. Такого рода структуру
# отношений называют иерархией наследования. Например, список является потомком коллекций с последовательным доступом.
# В данном случае мы назовем список "наследником", а коллекцию - "родителем" (или список - субклассом, коллекцию -
# суперклассом). Такая зависимость часто называется отношением IS-A (список является (is a) коллекцией с
# последовательным доступом). Это подразумевает, что списки наследуют важнейшие характеристики коллекций, в частности
# - упорядочение исходных данных, и такие операции, как конкатенация, повторение и индексация.
# И списки, и кортежи, и строки представляют из себя коллекции с последовательным доступом, наследуя общую организацию
# данных и операции. Однако, они различны по гомогенности данных и изменяемости наборов. Все потомки наследуют своим
# родителям, но различаются между собой включением дополнительных характеристик.
# Организовывая классы в иерархическом порядке, объектно-ориентированные языки программирования позволяют расширять
# ранее написанный код под вновь возникающие потребности. В дополнение, организовывая данные в иерархической манере, мы
# лучше понимаем существующие между ними взаимоотношения. Мы можем создавать более эффективное абстрактное
# представление.
# Чтобы глубже исследовать эту идею, мы напишем симуляцию - приложение, симулирующее цифровые цепи. Ее основными
# строительными блоками будут логические элементы. Эти электронные переключатели представляют собой соотношения булевой
# алгебры между их входом и выходом. В общем случае вентили имеют единственную линию выхода. Значение на ней зависит от
# значений, подаваемых на входные линии.
# Вентиль "И" (AND) имеет два входа, на каждый из которых может подаваться нуль или единица (кодирование False или True,
# соответственно). Если на оба входа подана единица, то значение на выходе тоже 1. Однако, если хотя бы один из входов
# установлен в нуль, то результатом будет 0. Вентиль "ИЛИ" также имеет два входа и выдает единицу, если хотя бы на одном
# из них 1. В случае, когда обе входные линии в нуле, результат тоже 0.
# Вентиль "НЕ" (NOT) отличается от предыдущих тем, что имеет всего один вход. Значение на выходе будет просто обратным
# входному значению. Т.е., если на входе 0, то на выходе 1, и наоборот. Так же каждый из них имеет свою таблицу
# истинности значений, отражающую отображение вентилем входа на выход.

