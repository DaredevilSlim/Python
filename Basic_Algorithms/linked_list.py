#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# https://ru.hexlet.io/courses/basic-algorithms/lessons/linked-list/theory_unit


# Связной список
# В этом уроке мы начнем изучать структуры данных и связанные с ними алгоритмы. Чтобы разобраться во всех деталях, мы
# рассмотрим два примера из реальной жизни — склад и библиотеку.
# На складе кладовщик записывает все пришедшие товары в специальный журнал. Рабочий день кладовщика состоит из приема и
# выдачи товаров. Очень важно записывать прием и выдачу как можно быстрее, поэтому кладовщик просто пишет все операции
# друг за другом, подряд.
# Из-за специфики работы склада кладовщик составляет базу данных, в которой:
# - Сложно найти товар на складе.
# - Просто сделать новую запись в журнале.
# Ситуация в библиотеке совсем другая. Основная работа библиотекаря — поиск книг по фамилии автора, по названию книги
# или по тематике. Для быстрого поиска книг библиотекари используют картотеку. Для каждой книги заводятся несколько
# карточек и размещаются в разных ящиках. В одном они упорядочены по фамилии автора, в другом — по названию. Благодаря
# порядку карточки ищутся очень быстро.
# Так в библиотеке составляется база данных с совсем другими свойствами:
# - Просто найти книгу в библиотеке.
# - Сложно сделать новую запись в картотеке.
# И на складе, и в библиотеке нам приходится записывать и искать похожую информацию, однако скорость записи и поиска
# получается разная:
#           Журнал      Картотека
# Запись    Быстро      Медленно
# Поиск     Медленно    Быстро
# Как видите, мы не можем выбрать один универсальный способ записи, который подойдет для всех случаев. Для склада больше
# подходит Журнал, а для библиотеки — Картотека.
# В обоих примерах своя структура данных — то есть способ хранения данных в памяти компьютера. Для каждой структуры
# существует набор основных операций — добавление, поиск, удаление. Из-за особенностей структуры, добавление и поиск
# могут быть быстрыми или медленными.
# Программисты изучают основные структуры данных и запоминают скорость основных операций. Это помогает им выбирать самые
# подходящие структуры для решения задач пользователя. В этом уроке мы познакомимся со связным списком и сравним его с
# массивом.


# Как устроен массив.
# Чтобы освоиться с понятием структуры данных и ее операциями, давайте исследуем структуру, которая нам хорошо известна
# — массив.
# В Python все данные относятся к примитивным или ссылочным типам. Числа и булевы значения хранятся непосредственно в
# переменных:
a = 1
b = False
# Массивы и объекты — это ссылочные типы, которые хранятся в памяти отдельно. Область хранения называется кучей, и в
# начале работы программы она пуста:
# Название «куча» когда-то было сленговым, но прижилось и сейчас используется как официальный термин. Каждая ячейка в
# куче — это обычная переменная, которая может хранить одно значение. У каждой ячейки есть адрес — ее порядковый номер.
# Когда мы создаем новый массив, интерпретатор Python размещает его в свободном месте кучи и записывает в переменную
# адрес массива:
items = [5, 8, 12, 3]
# На рисунке вы видите, как хранится массив в памяти. В ячейках с номерами 00, 01 и 02 уже есть какие-то данные — они
# «заняты», поэтому массив начинается с ячейки 03.
# В самой первой ячейке массива хранится его длина или количество элементов, то есть 4. Затем последовательно хранятся
# сами значения 5, 8, 12 и 3.
# Поскольку элементы массива хранятся последовательно, процессор легко определяет адрес элемента по его порядковому
# номеру в массиве:
print(items[2])  # 12
# Массив начинается с адреса 03, где хранится длина массива. Нулевой элемент массива items[0] имеет адрес 04, а второй
# элемент items[2] — адрес 04 + 2, то есть 06. В этой ячейке находится число 12.
# Подобные рассуждения могут запутать, поскольку в ячейках хранятся числа, а адреса ячеек — тоже числа. Если чувствуете,
# что потеряли нить рассуждений, вернитесь немного назад и повторите.
# Порядковый номер элемента в массиве обычно называют индексом — это название пришло из математики.
# Определение длины массива и обращение к элементу по индексу — две простые операции, которые мы постоянно используем
# при работе с массивами. Возьмем для примера функцию, которая вычисляет сумму элементов массива:


def sum_n(items):
    result = 0
    for i in range(len(items)):
        result += items[i]
    return result


print(sum_n([1, 2, 3, 4]))  # 10
# Иногда мы хотим расширить массив и добавить к нему несколько элементов. В Python для этого используют метод append():
items.append(7)
items.append(20)
# В простом случае, если сразу за массивом есть свободное место, новые элементы попадут туда:
# Мы видим, что длина массива теперь равна шести, и в его конце появились числа 7 и 20. А теперь представим, что
# программист создал после массива еще несколько объектов и свободной памяти сразу за массивом нет:
items = [5, 8, 12, 3]
point = {'x': -5, 'y': 7}
items.append(7)
items.append(20)
# На рисунке сразу за массивом items в куче находится объект point. Кажется, что в этом случае мы не можем расширить
# массив, ведь элементы должны располагаться в памяти подряд. На самом деле при вызове метода append() интерпретатор
# копирует весь массив в свободную область памяти и добавляет к ней несколько элементов. Исходная область памяти
# помечается как свободная:
# Расширение массива может привести к копированию большого объема данных и замедлению программы. Есть несколько способов
# борьбы с таким поведением, но копирование все равно случается. Как быть, если нам предстоит часто добавлять и удалять
# элементы? Можно применить связный список.


# Связный список
# Это структура, которая решает проблему производительности, если нам приходится часто добавлять и удалять данные.
# Данные в связном списке хранятся не подряд, а вразброс.
# Каждое значение хранится в отдельном объекте, который называется узлом. Помимо значения, объект хранит ссылку на
# следующий узел списка. В самом последнем узле вместо ссылки на следующий элемент хранится значение null.
# Опишем класс, содержащий значение (value) и ссылку на следующий узел (next):
class LinkedListNode:
    def __init__(self, value, next):
        self.value = value
        self.next = next


# Список из элементов 5, 8, 12 и 3 может быть создан так:
head = LinkedListNode(
    5, LinkedListNode(
        8, LinkedListNode(
            12, LinkedListNode(
                3, None
            )
        )
    )
)
# Оператор new не только создает объект, но и выделяет для него место в памяти. Самый первый элемент односвязного списка
# часто называют головой (head), поэтому и переменную со ссылкой на голову мы назвали head.
# В поле next самого последнего узла находится null — значит, узлов больше нет. В отличие от массива, узлы списка не
# размещаются в памяти подряд:
# На рисунке узлы списка занимают две ячейки. В первой хранится значение, а во второй — адрес следующего узла или null.
# Иногда узлы могут располагаться рядом (на рисунке это 12 и 3), но в общем случае это не так.
# Вся работа со списком производится через ссылку на его первый элемент, так что переменная head — единственное, что нам
# нужно для реализации алгоритмов.
# Поскольку мы пишем на языке Python, который поддерживает объектно-ориентированное программирование, мы объединим поле
# head и все наши функции в один класс. Он будет называться LinkedList, что в переводе с английского означает связный
# список. При создании нового списка в поле head хранится значение null, что означает, что список пустой:


class LinkedList:
    def __init__(self):
        self.head = None


# Вставка элемента в начало списка.
# В простейшем случае, мы вставляем элемент в пустой список. В самом начале значение поля head равно null:
# После вставки head указывает на единственный элемент списка:
# Мы не рисуем кучу целиком, потому что в реальной программе трудно предугадать, по какому адресу разместится то или
# иное значение. Конкретные адреса могут сбить с толку.
# Поэтому мы просто отмечаем факт, что для нового узла списка в куче были выделены две ячейки, и head указывает на этот
# узел. Адрес первого узла мы запишем, как addr(1), это позволит нам отличать адреса друг от друга.
# После вставки второго узла в начало списка, картина примет такой вид:
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

