#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from collections.abc import Iterable

# Отсортируйте данный список таким образом, чтобы его элементы оказались в порядке убывания частоты их появления, то
# есть по количеству раз, которое они появляются в элементах. Если два элемента имеют одинаковую частоту, они должны
# оказаться в своем естественном порядке. Например, [5, 2, 4, 1, 1, 1, 3] ==> [1, 1, 1, 2, 3, 4, 5].
# Если ты хочешь больше попрактиковаться с подобным заданием, попробуй миссию Sort Array by Element Frequency.
# Входные данные: Список целых чисел.
# Выходные данные: Список или другой итерируемый обьект (кортеж, итератор, генератор) целых чисел.
# Как это используется: Для анализа данных с помощью математической статистики и мат.анализа, а также для нахождения
# тенденций и предсказания будущих изменений (систем, явлений и т.д.)
# Предусловия:
# длина списка <= 100
# max number <= 100


def frequency_sorting(numbers: list[int]) -> Iterable[int]:
    numbers = [(numbers.count(i), i) for i in set(numbers)]
    new = []
    for i, j in sorted(sorted(numbers, key=lambda x: x[1]), key=lambda x: x[0], reverse=True):
        new += [j] * i
    return new


print(list(frequency_sorting([1, 2, 3, 4, 5])))                   # [1, 2, 3, 4, 5]
print(list(frequency_sorting([3, 4, 11, 13, 11, 4, 4, 7, 3])))    # [4, 4, 4, 3, 3, 11, 11, 7, 13,]
print(list(frequency_sorting([99, 99, 55, 55, 21, 21, 10, 10])))  # [10, 10, 21, 21, 55, 55, 99, 99]
