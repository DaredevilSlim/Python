#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import builtins  # Подключаем модуль builtins
import sys  # Подключаем модуль sys
from keyword import kwlist  # Подключаем функцию kwlist из модуля keyword

# ГЛАВА 2
print('ГЛАВА 2')
# Переменные и типы данных
print('Переменные и типы данных')


# 2.1. Переменные
print('2.1. Переменные')
# Переменная - это ячейка в оперативной памяти компьютера, предназначенная для хранения какого-либо значения и имеющая
# уникальное имя. Обращение к переменной с целью извлечь хранящееся в ней значение или занести в нее другое значение
# выполняется по имени этой переменной.
# Чтобы создать переменную в языке Python, достаточно лишь занести в нее какое-либо значение. Впоследствии в эту же
# переменную можно заносить любые другие значения. Если занести в переменную другое значение, хранившееся в ней ранее
# будет потеряно.
# Операция занесения значения в переменную называется присваиванием. Она выполняется посредством оператора присваивания
# = (знак равенства), слева от которого ставится имя нужной переменной, а справа - присваиваемое значение. Примеры:
print("Присваиваем переменной language_name строковое значение 'Python'")
language_name = 'Python'
print(language_name)
print('Присваиваем переменной n число 123')
n = 123
# Чтобы извлечь из переменной хранящееся в ней значение для использования его в вычислениях, следует просто указать имя
# этой переменной:
print('Выводим результат сложения числа из переменной n и 321')
print(n + 321)
# Имя переменной должно состоять из букв (можно использовать буквы любых алфавитов, но традиционно применяется лишь
# латиница), цифр и знаков подчеркивания, причем имя переменной не может начинаться с цифры. Кроме того, следует
# избегать указания символа подчеркивания в начале имени, поскольку идентификаторам с таким символом определено
# специальное назначение.
# В качестве имен переменной нельзя использовать ключевые слова - слова, посредством которых в Python составляются
# всевозможные языковые конструкции. Получить список всех ключевых слов позволяет такой код:
print(kwlist)
# Помимо ключевых слов, следует избегать совпадений со встроенными идентификаторами (именами функций, классов и модулей,
# встроенных в язык). Получить полный список встроенных идентификаторов позволяет следующий код:
print(dir(builtins))
# Правильные имена переменных: х, yl, strName, str_name.
# Неправильные имена переменных: ly, ! important_value ! , global.
# Python принимает во внимание регистр букв, используемых в именах переменных. Например, х и X - разные переменные:
x = 10
X = 20
print(x, X)


# 2.2. Типы данных. Понятие объекта и ссылки
print('2.2. Типы данных. Понятие объекта и ссылки')
# Тип данных - это разновидность значения, обрабатываемого Python, и набор действий, которые могут быть выполнены с этим
# значением. Поддерживаются следующие типы данных:

# int - целое число. Размер числа ограничен лишь объемом оперативной памяти. Пример (функция type() позволяет определить
# тип значения):
print(type(2147483647))
print(type(999999999999999999999999))

# float - дробное, или вещественное, число:
print(type(5.1))
print(type(8.5e-3))

# bool - логическая величина. Поддерживаются значения True ('истина') и False ('ложь'). Пример:
print(type(True))
print(type(False))

# str - строка (последовательность произвольных символов):
print(type('Строка'))

# list - список (набор пронумерованных значений, называемых элементами, которые могут быть произвольными, списки можно
# изменять, добавляя, изменяя и удаляя находящиеся в них значения):
print(type([1, 2, 3]))
# Как говорилось ранее, списки можно изменять:
l = [1, 2, 3]  # Создаем список из трех чисел
print(l)
l[1] = 40      # Изменяем второй элемент
print(l)       # Нумерация элементов в списке начинается с О

# tuple - кортеж (аналогичен списку, но не может быть изменен):
print(type((1, 2, 3)))
# Попытка изменить кортеж вызовет программную ошибку:
t = (1, 2, 3)  # Создаем кортеж из трех чисел
print(t)
# t[2] = 60    # Попытка замены элемента вызовет ошибку - TypeError: 'tuple' object does not support item assignment

# range - диапазон (последовательность целых чисел с заданными начальным, конечным значениями и разницей между
# отдельными числами):
print(type(range(1, 10)))

# sеt - множество (аналогично списку, но хранит лишь уникальные значения):
print(type({'a', 'b', 'c'}))

# frozenset - неизменяемое множество:
print(type(frozenset({'a', 'b', 'c'})))

# bytes - неизменяемая последовательность байтов:
print(type(bytes('Строка', 'utf-8')))

# bytearray - изменяемая последовательность байтов:
print(type(bytearray('Строка', 'utf-8')))

# Типы list, tuple, range, set, frozenset, bytes и bytearray носят общее название последовательностей, поскольку
# содержащиеся в них элементы можно перебрать последовательно, один за другим (например, в цикле), и выполнить над ними
# какие-либо действия. К последовательностям относятся и строки - отдельные символы в них также можно перебрать;

# dict - словари (наборы значений, каждое из которых связано с уникальным ключом, по которому зто значение можно
# извлечь):
print(type({'х': 5, 'у': 20}))
# Тип dict называется отображением, поскольку в нем каждый ключ отображается на связанное с ним значение;

# NoneType - "пустой" тип. Поддерживается единственное значение None, обозначающий отсутствие любого "значащего"
# значения:
print(type(None))

# complex - комплексные числа:
print(type(2+2j))

# function - функции:


def func():
    pass


print(type(func))

# module - модули:
print(type(sys))

# type - классы и типы данных:


class C: pass


print(type(C))
print(type(type('')))

# Значение каждого типа хранится в оперативной памяти в виде довольно сложной структуры, называемой объектом. Помимо
# собственно значения, в объекте содержатся всевозможные данные, описывающие это значение (например, у строкового
# значения также хранится количество символов, содержащихся в строке).
# А теперь - важный момент! При присваивании значения, представленного объектом, какой-либо переменной в последнюю
# заносится не само это значение, а ссылка на него (ссылку можно рассматривать как особый компактный указатель на
# определенный объект). Поэтому, если, например, список присвоить одной переменной, а потом значение этой переменной
# присвоить другой переменной, обе переменные будут содержать ссылки на один и тот же список.
a = [1, 2, 3]  # Присваиваем список переменной а
b = a          # Присваиваем значение переменной а (список) переменной b
print(a, b)
a[1] = 40      # Изменяем второй элемент списка из переменной a
print(a, b)    # Как видим, обе переменные ссылаются на один и тот же список

# Типы делятся на изменяемые и неизменяемые. Значения изменяемых типов, к которым относятся list, set, bytearray и dict,
# можно изменять (так, можно изменить значение элемента списка или байт из последовательности). Значения неизменяемых
# типов изменить нельзя (например, невозможно изменить значение элемента кортежа и символ в строке).
# К неизменяемым типам относятся также числа и логические величины. То есть, если присвоить число переменной, а потом
# присвоить этой же переменной другое число, интерпретатор не станет заменять значение, хранящееся в существующем
# числовом объекте, а создаст новый числовой объект, который и занесет в переменную. Старый объект при этом будет удален
# из памяти.


# 2.3. Присваивание значений переменным
print('2.3. Присваивание значений переменным')
# Присваивание - это занесение в переменную какого-либо значения (при этом значение, хранившееся в переменной ранее,
# теряется). Оно выполняется с помощью оператора присваивания = (знак равенства). Имя переменной, которой присваивается
# значение, ставится слева от оператора, а само присваиваемое значение - справа.
x = 7          # Присваивание целого числа (тип int)
print(x)
y = 7.8        # Присваивание вещественного числа (тип float)
print(y)
s1 = "Строка"  # Присваивание строки (тип string)
print(s1)
s2 = 'Строка'  # Также присваивание строки
print(s2)
b = True       # Присваивание логической величины True (тип bool)
print(b)
# В одной строке можно присвоить значение сразу нескольким переменным (групповое присваивание):
x = y = 10  # Переменным х и у присвоено число 10
print(x, y)
# Не забываем, что при этом все переменные получат ссылку на один и тот же объект. Поэтому групповое присваивание не
# рекомендуется использовать для значений изменяемых типов.
x = y = [1, 2]  # Якобы создали два списка
print(x, y)
y[1] = 100      # Изменяем второй элемент списка
print(x, y)
# Проверить, ссылаются ли две переменные на один и тот же объект, позволяет оператор is. Если переменные ссылаются на
# один и тот же объект, оператор is возвращает значение True, в противном случае - False.
x = y = [1, 2]  # Один объект
print(x is y)
x = [1, 2]      # Разные объекты
y = [1, 2]      # Разные объекты
print(x is y)
# Следует заметить, что в целях повышения производительности интерпретатор производит кеширование малых целых чисел и
# небольших строк. Это означает, что если ста переменным присвоено число 2, то, скорее всего, в этих переменных будет
# сохранена ссылка на один и тот же объект.
x = 2
y = 2
z = 2
print(x is y, y is z)
# Посмотреть количество ссылок на указанный объект позволяет функция getrefcount(<Объект>) из модуля sys:
print(sys.getrefcount(2))
# Когда число ссылок на объект становится равно нулю, объект автоматически удаляется из оперативной памяти. Исключением
# являются объекты, которые подлежат кешированию. Помимо группового, Python поддерживает позиционное присваивание.
# В этом случае переменные записываются через запятую слева от оператора =, а присваивание им значения - через запятую
# справа.
x, y, z = 1, 2, 3
print(x, y, z)
# С помощью позиционного присваивания можно поменять значения двух переменных местами:
x, y = 1, 2
print(x, y)
x, y = y, x
print(x, y)
# По обе стороны оператора = могут быть указаны последовательности, к каковым относятся строки, списки, кортежи,
# диапазоны, типы bytes и bytearray:
x, y, z = '123'        # Строка
print(x, y, z)
x, y, z = [1, 2, 3]    # Список
print(x, y, z)
x, y, z = (1, 2, 3)    # Кортеж
print(x, y, z)
[x, y, z] = (1, 2, 3)  # Список слева, кортеж справа
print(x, y, z)
# Обратите внимание на то, что количество переменных и значений справа и слева от оператора = должно совпадать, иначе
# будет выведено сообщение об ошибке:
# x, y, z = (1, 2, 3, 4)
# print(x, y, z)
# Traceback (most recent, last):
#   File "Chapter_02.py", line 217, in <module>
#     х, у, z = (1, 2, 3, 4)
# ValueError: too many values to unpack (expected 3)
# Python при несоответствии количества переменных и значений справа и слева от оператора = позволяет сохранить в одной
# из переменных список, состоящий из 'лишних' значений. Для этого перед именем нужной переменной указывается
# звездочка (*).
x, y, *z = (1, 2, 3, 4)
print(x, y, z)
x, *y, z = (1, 2, 3, 4)
print(x, y, z)
*x, y, z = (1, 2, 3, 4)
print(x, y, z)
x, y, *z = (1, 2, 3)
print(x, y, z)
x, y, *z = (1, 2)
print(x, y, z)
# Как видно из примера, переменная, перед которой указана звездочка, всегда получает в качестве значения список. Если
# для этой переменной не хватило значений, то ей присваивается пустой список. Следует помнить, что звездочку можно
# указать только перед одной переменной, в противном случае возникнет неоднозначность и интерпретатор выведет сообщение
# об ошибке.
# *х, у, *z = (1, 2, 3, 4)
# SyntaxError: two starred expressions in assignment


# 2.4. Проверка типа данных
print('2.4. Проверка типа данных')
# Выяснить тип данных, к которому относится заданное значение, позволяет функция type(<Значение>). В качестве результата
# она возвращает ссылку на объект типа.
print(type(a))
# Проверить, принадлежит ли какое-либо значение указанному типу данных, можно следующими способами:
# сравнить значение, возвращаемое функцией type(), с нужным типом данных:
x = 10
if type(x) == int:
    print('Этo целое число (тип int)')
# использовать функцию isinstance(<Значение>, <Тип>):
s = 'Строка'
if isinstance(s, str):
    print('Этo строка (тип str)')


# 2.5. Преобразование типов данных
print('2.5. Преобразование типов данных')
# Над значением, относящимся к определенному типу, можно производить лишь операции, допустимые для этого типа. Например,
# можно складывать друг с другом числа, но строку сложить с числом нельзя - это приведет к выводу сообщения об ошибке:
# print(2 + '25')
# Traceback (most recent call last):
#   File "Chapter_02.py", line 262, in <module>
#     print(2 + '25')
# TypeError: unsupported operand type(s) for +: 'int' and 'str'
# Для преобразования значения из одного типа данных в другой предназначены следующие функции:
# bool([<Значение>]) - преобразует заданное значение в логический тип данных:
print(bool(0), bool(l), bool(''), bool('Строка'), bool([l, 2]), bool([]))

# int([<Значение>[, <Система счисления>]]) - преобразует заданное значение в число. Во втором параметре можно указать
# систему счисления (по умолчанию 1О).
print(int(7.5), int('71'))
print(int('71', 10), int('71', 8), int('0o71', 8), int('A', 16))
# Если преобразование невозможно, то генерируется исключение:
# print(int('71s'))
# Traceback (most recent call last):
#   File "Chapter_02.py", line 275, in <module>
#     print(int('71s'))
# ValueError: invalid literal for int() with base 10: '71s'

# float([<Число или строка>]) - преобразует указанное целое число или строку в вещественное число:
print(float(7), float('7.1'))
print(float('Infinity'), float('-inf'))
print(float('Infinity') + float('-inf'))
# str([<Значение>]) - преобразует указанное значение в строку:
print(str(125), str([1, 2, 3]))
print(str((1, 2, 3)), str({'x': 5, 'у': 10}))
print(str(bytes('строка', 'utf-8')))
print(str(bytearray('строка', 'utf-8')))

# str(<Значение>[, <Кодировка>[, <Обработка ошибок>]]) - преобразует заданное значение типа bytes или bytearray в строку
# в указанной кодировке. В третьем параметре можно указать значение "strict" (при ошибке возбуждается исключение
# UnicodeDecodeError - значение по умолчанию), "replace" (неизвестный символ заменяется символом, имеющим код \uFFFD)
# или "ignore" (неизвестные символы игнорируются).
obj1 = bytes('строка1', 'utf-8')
obj2 = bytearray('строка2', 'utf-8')
print(str(obj1, 'utf-8'), str(obj2, 'utf-8'))
# print(str(obj1, 'ascii', 'strict'))
# Traceback (most recent call last):
#   File "Chapter_02.py", line 296, in <module>
#     print(str(obj1, 'ascii', 'strict'))
# UnicodeDecodeError: 'ascii' codec can't decode byte 0xd1 in position 0: ordinal not in range(128)
print(str(obj1, 'ascii', 'ignore'))

# bytes(<Строка>, <Кодировка>[, <Обработка ошибок>] ) - преобразует указанную строку в объект типа bytes в заданной
# кодировке. В третьем параметре могут быть заданы значения "strict" (по умолчанию), "replace" или "ignore".
print(bytes('строка', 'ср1251'))
print(bytes('строка123', 'ascii', 'ignore'))
# bytes(<Последовательность>) - преобразует указанную последовательность целых чисел от О до 255 в объект типа bytes.
# Если какое-либо число из последовательности не попадает в диапазон, возбуждается исключение ValueError.
b = bytes([225, 226, 224, 174, 170, 160])
print(b)
print(str(b, 'cp866'))

# bytearray(<Строка>, <Кодировка>[, <Обработка ошибок>] ) - преобразует заданную строку в объект типа bytearray в
# указанной кодировке. В третьем параметре могут быть указаны значения "strict" (по умолчанию), "replace" или "ignore".
print(bytearray('строка', 'ср1251'))
# bytearray(<Последовательность>) - преобразует заданную последовательность целых чисел от О до 255 в объект типа
# bytearray. Если какое-либо число из последовательности не попадает в диапазон, возбуждается исключение valueError.
b = bytearray([225, 226, 224, 174, 170, 160])
print(b)
print(str(b, 'cp866'))

# list (<Последовательность>) - преобразует элементы заданной последовательности в список:
print(list('12345'))          # Преобразование строки
print(list((1, 2, 3, 4, 5)))  # Преобразование кортежа

# tuple(<Последовательность>) - преобразует элементы заданной последовательности в кортеж:
print(tuple('12345'))          # Преобразование строки
print(tuple([1, 2, 3, 4, 5]))  # Преобразование кортежа
# В качестве примера рассмотрим возможность сложения двух чисел, введенных пользователем (test_00012.py).
# Результатом выполнения этой программы будет не число, а строка "512". Как видим, функция input() возвращает результат
# в виде строки. Чтобы просуммировать два числа, необходимо преобразовать полученные строки в числа (test_00013.py).
# В этом случае мы получим число 17, как и должно быть. Однако если пользователь вместо числа введет строку, то
# программа завершится с фатальной ошибкой.


# 2.6. Удаление переменных
print('2.6. Удаление переменных')
# Удалить переменную можно с помощью инструкции следующего формата:
# del <Переменная 1>[, . . . , <Переменная N>]
# Пример удаления одной переменной:
x = 10
print(x)
del x
# print(x)
# Traceback (most recent call last):
#   File "Chapter_02.py", line 346, in <module>
#     print(x)
# NameError: name 'x' is not defined. Did you mean: 'X'?
# Пример удаления нескольких переменных:
x, y = 10, 20
del x, y
