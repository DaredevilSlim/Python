#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math     # Подключаем модуль math
import locale   # Подключаем модуль locale
import keyword  # Подключаем модуль keyword
import pickle   # Подключаем модуль pickle
import hashlib  # Подключаем модуль hashlib

# ГЛАВА 6
# Строки и двоичные данные
# Строка - это неизменяемая последовательность произвольных символов в кодировке Unicode. Длина строки ограничена лишь
# объемом оперативной памяти компьютера.
# Двоичные данные - это последовательность байтов (чисел от О до 255), которая может быть как неизменяемой, так и
# изменяемой. Длина такой последовательности также ограничена лишь объемом оперативной памяти. В виде двоичных данных
# может быть сохранена информация любого рода: строка, графическое изображение, архив и др.


# 6.1. Создание строк
print('6.1. Создание строк')
# Создать строку можно следующими способами:
# - записав составляющие строку символы между одинарными или двойными кавычками:
print('строка', 'строка')
# Строки, созданные с применением одинарных и двойных кавычек, ничем не отличаются друг от друга.
# В строках, созданных одинарными кавычками, можно размещать двойные кавычки, а в строках, созданных двойными кавычками,
# - одинарные кавычки:
print('Группа "Кино"', "О'Брайен")
# Попытка вставить одинарную кавычку в строку, созданную одинарными кавычками, или двойную кавычку в строку в двойных
# кавычках приведет к ошибке:
# print('Группа 'КИно'')
# SyntaxError: invalid syntax
# В строках можно указать специальные символы - символы, обрабатываемые особым образом. Обозначение специального символа
# начинается со знака обратного слеша (\).
# Например, специальный символ \n обозначает разрыв строки, специальный символ \' - одинарную кавычку, символ \' -
# двойную кавычку, а \\ - обратный слеш. Более подробно специальные символы будут описаны в разд. 6.1.1. Примеры:
print('Строка1\\nСтрока2')
print('Группа \'КИно\'', 'О\'Брайен')
# Специальный символ \\ обычно применяется для вставки символа обратного слеша в конец строки:
print('string\\')
# Если же использовать единичный символ обратного слеша, интерпретатор посчитает его и следующую за ним кавычку
# специальным символом и выведет сообщение о синтаксической ошибке:
# print('string\')
# SyntaxError: unterminated string literal (detected at line 36)
# Нельзя разбивать строковый объект, созданный с помощью кавычек, на несколько строк - это вызовет синтаксическую
# ошибку:
# print('string)
# SyntaxError: unterminated string literal (detected at line 40)
# Чтобы расположить строковое значение на нескольких строках, следует либо перед символом перевода строки указать
# символ \, либо поместить отдельные части строки внутри круглых скобок, либо выполнить конкатенацию строк также внутри
# круглых скобок:
print('string1\
      string2')  # После \ не должно быть никаких символов
print('string1'
      'string2')  # Неявная конкатенация строк
print('string1' +
      'string2')  # Явная конкатенация строк
#
#
#
# - указав строку между утроенными одинарными или двойными кавычками. Такие строковые объекты могут размещаться на
# нескольких строках, содержать одинарные и двойные кавычки. Примеры:
print('''Строка1
      Строка2''')
print('''Строка1
      Строка2''')
# - с помощью функции str([<Значение>[, <Кодировка>[, <Обработка ошибок>]]]). Если указан только первый параметр,
# функция возвращает строковое представление указанного значения. Если параметры не указаны вообще, возвращается пустая
# строка. Примеры:
print(str(), str([1, 2]), str((3, 4)), str({'x': 1}))
# При попытке преобразовать двоичные данные типа byte или bytearray в строку будет выдано строковое представление
# двоичных данных:
print(str(b'\xf1\xf2\xf0\xee\xea\xe0'))
# Чтобы получить строку, следует указать кодировку:
print(str(b'\xf1\xf2\xf0\xee\xea\xe0', 'cp1251'))
# В третьем параметре могут быть указаны значения 'strict' (при ошибке возбуждается исключение UnicodeDecodeError - 
# значение по умолчанию), 'replace' (неизвестный символ заменяется символом с кодом \uFFFD) или 'ignore' (неизвестные
# символы игнорируются):
obj1 = bytes('строка1', 'utf-8')
print(obj1)
obj2 = bytearray('строка2', ':utf-8')
print(obj2)
print(str(obj1, 'utf-8'), str(obj2, 'utf-8'))
# str(obj1, 'ascii', 'strict')
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 77, in <module>
#     str(obj1, 'ascii', 'strict')
# UnicodeDecodeError: 'ascii' codec can't decode byte 0xd1 in position 0: ordinal not in range(128)
print(str(obj1, 'ascii', 'ignore'))


# Если строка не присваивается переменной, то она считается строкой документирования.
# Такая строка сохраняется в атрибуте _doc_ того объекта, в котором расположена. В качестве примера создадим функцию со
# строкой документирования, а затем выведем содержимое строки:


def test():
    """Это описание функции"""
    pass


print(test.__doc__)


# 6.1.1. Специальные символы
print('6.1.1. Специальные символы')
# Специальные символы, как говорилось ранее, имеют особое значение и обрабатываются особым образом. Python поддерживает
# следующие специальные символы:
# - \n - перевод строки;
# - \r - возврат каретки;
# - \t - знак табуляции;
# - \v - вертикальная табуляция;
# - \а - звонок;
# - \b - забой;
# - \f - перевод формата;
# - \0 - нулевой символ;
# - \" - двойная кавычка;
# - \' - одинарная кавычка (апостроф);
# - \\ - обратный слеш;
# - \<N> - символ с восьмеричным кодом <N>. Например, \74 соответствует символу <;
# - \x<N> - символ с шестнадцатеричным кодом <N>. Например, \x6a соответствует символу j;
# - \u<nnnn> - символ с 16-битным Unicode-кодом <nnnn>. Например, \u04За соответствует русской букве к;
# - \U<nnnnnnnn> - символ с 32-битным Unicode-кодом <nnnnnnnn>;
# - \N{<name>} - символ с Unicode-именем <name>. Например, \N{Registered Sign} соответствует знаку зарегистрированной
# торговой марки ®·
# Комбинация обратного слеша с любым другим символом выводится как есть:
print('Этот символ \не специальный')
# Тем не менее для вставки обратного слеша лучше использовать специальный символ \\:
print('Этот символ \\не специальный')
# Этот символ \не специальный


# 6.1.2. Необрабатываемые строки
print('6.1.2. Необрабатываемые строки')
# В необрабатываемых строках специальные символы не обрабатываются, а выводятся как есть. Чтобы превратить строку в
# необрабатываемую, достаточно предварить ее модификатором r или R. Примеры:
print('Строка1\nСтрока2')
print(r'Строка1\nСтрока2')
print(R'Строка1\nСтрока2')
print(r"""Строка1\nСтрока2""")
# Необрабатываемые строки удобно использовать в шаблонах регулярных выражений и при записи файловых путей:
print(r'C:\Python310\lib\site-packages')
# В обычных строках все обратные слеши придется заменять на специальные символы \\:
print('C:\\Python310\\lib\\site-packages')
# Если в конце необрабатываемой строки должен располагаться слеш, следует использовать специальный символ \\. Однако
# этот символ будет добавлен в строку. Пример:
# print(r'C:\Python310\lib\site-packages\')
# File "/Chapter_06.py", line 140
#     print(r'C:\Python310\lib\site-packages\')
# SyntaxError: unterminated string literal (detected at line 140)
print(r'C:\Python310\lib\site-packages\\')
# Избавиться от лишнего слеша можно, использовав конкатенацию строк, обычные строки
# или удалив слеш явно:
print(r'C:\Python310\lib\site-packages' + '\\')  # Конкатенация
print('С:\\Python310\\lib\\site-packages\\')     # Обычная строка
print(r'C:\PythonЗlO\lib\site-packages\\'[:-1])  # Удаление слеша


# 6.2. Операции над строками
print('6.2. Операции над строками')
# Строки относятся к последовательностям и, соответственно, поддерживают все операции, выполняемые над
# последовательностями.
# Можно извлечь любой символ строки, указав индекс этого символа в квадратных скобках. Нумерация символов начинается
# с нуля. Пример:
s = 'Python'
print(s[0], s[1], s[2], s[3], s[4], s[5])
# При обращении к символу с несуществующим индексом возбуждается исключение IndexError:
# s = "Python"
# print(s[10])
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 162, in <module>
#     print(s[10])
# IndexError: string index out of range
# Можно указать отрицательный индекс - он будет отсчитываться от конца строки:
s = 'Python'
print(s[-1], s[-4])
# Так как строки относятся к неизменяемым типам данных, то изменить символ с указанным индексом нельзя:
# s = "Python"
# s[0] = 'J'
# Traceback (most recent call last):
#   File "Chapter_06.py", line 172, in <module>
#     s[0] = 'J'
# TypeError: 'str' object does not support item assignment
# Чтобы выполнить изменение, можно воспользоваться операцией извлечения среза - фрагмента последовательности, также
# представляющего собой последовательность. Формат записи среза:
# [<Начало>:<Конец>:<Шаг>]
# Все параметры здесь не являются обязательными. Если параметр <Начало> не указан, то используется значение О. Если
# параметр <Конец> не указан, то возвращается фрагмент до конца строки. Символ с индексом, указанным в этом параметре,
# не входит в возвращаемый фрагмент. Если параметр <Шаг> не указан, то используется значение 1. В качестве значения
# параметров можно указать отрицательные значения. Примеры:
# - получение копии строки:
s = 'Python'
print(s[:])         # Возвращается фрагмент от позиции 0 до конца строки
# - вывод символов в обратном порядке:
print(s[::-1])      # Указываем отрицательное значение в параметре <Шаг>
# - замена первого символа в строке:
print('J' + s[1:])  # Извлекаем фрагмент от символа 1 до конца строки
# - удаление последнего символа:
print(s[:-1])       # Возвращается фрагмент от 0 до len(s)-1
# - получение первого символа в строке:
print(s[0:1])       # Символ с индексом 1 не входит в диапазон
# - получение последнего символа:
print(s[-1:])       # Получаем фрагмент от len(s)-1 до конца строки
# - вывод символов с индексами 2, 3 и 4:
print(s[2:5])       # Возвращаются символы с индексами 2, З и 4
# Узнать длину строки (количество символов в ней) позволяет функция len():
print(len('Python'), len('\r\n\t'), len(r'\r\n\t'))
# Можно перебрать все символы в строке с помощью цикла перебора последовательности:
s = 'Python'
for i in s:
    print(i, end=' ')
print('')
# Выполнить конкатенацию строк позволяет оператор +:
print('Строка1' + 'Строка2')
s = 'Строка1'
print(s + 'Строка2')
# Кроме того, можно выполнить неявную конкатенацию строк, записав их через пробел:
print('Строка1' 'Строка2')
# Однако выполнить неявную конкатенацию переменной и строки нельзя - это вызовет ошибку:
# print(s 'Строка2')
# File '/Chapter_06.py', line 213
#     print(s 'Строка2')
# SyntaxError: invalid syntax
# При необходимости объединить строку со значением другого типа (например, с числом) следует произвести явное
# преобразование типов с помощью функции str():
print('string' + str(10))
# Еще строки поддерживают операцию повторения, проверки на вхождение и невхождение.
# Повторить строку указанное количество раз можно с помощью оператора *, выполнить проверку на вхождение фрагмента в
# строку позволяет оператор in, а проверить на невхождение - оператор not in:
print('-' * 20)
print('yt' in 'Python')       # Найдено
print('yt' in 'Perl')         # Не найдено
print('PHP' not in 'Python')  # Не найдено


# 6.3. Форматирование строк
print('6.3. Форматирование строк')
# При форматировании указанная строка объединяется со значениями любых других типов.
# Форматирование выполняется быстрее конкатенации.
# Операция форматирования записывается в следующем формате:
# <Строка специального формата> % <Значения>
# Внутри параметра <Строка специального формата> могут быть указаны спецификаторы, имеющие следующий синтаксис:
# %[(<Ключ>)][<Флаг>][<Ширина>][.<Точность>]<Тип преобразования>
# Количество спецификаторов внутри строки должно быть равно количеству элементов в параметре <Значения>. Если
# спецификатор один, то параметр <Значения> может содержать одно значение, в противном случае следует задать кортеж.
# Примеры:
print('%s' % 10)                      # Один элемент
print('%s - %s - %s' % (10, 20, 30))  # Несколько элементов
# Параметры внутри спецификатора имеют следующий смысл:
# - <Ключ> - ключ словаря. Если задан ключ, то в параметре <Значения> необходимо указать словарь, а не кортеж:
print('%(name)s - %(year)s' % {'year': 1978, 'name': 'Nik'})

# - <Флаг> - флаг преобразования. Может содержать следующие значения:
#  - # - у восьмеричных чисел добавляет в начало комбинацию символов 0o, у шестнадцатеричных - комбинацию символов 0x
# (если используется тип х) или 0X (если используется тип X), у вещественных чисел предписывает всегда выводить дробную
# точку, даже если в параметре <Точность> задано значение 0:
print('%#o %#o %#o' % (0o77, 0xff, 10))
print('%#x %#x %#x' % (0o77, 0xff, 10))
print('%#X %#X %#X' % (0o77, 0xff, 10))
print('%#.0F %.0F' % (300, 300))
#  - 0 - вывод ведущих нулей у чисел:
print("'%d' - '%05d'" % (3, 3))  # 5 - ширина поля
#  - - выравнивание по левой границе области (по умолчанию используется выравнивание по правой границе). Если флаг
# указан одновременно с флагом 0, то действие последнего будет отменено. Примеры:
print("'%5d' - '%-5d'" % (3, 3))    # 5 - ширина поля
print("'%05d' - '%-05d'" % (3, 3))
# пробел - вывод пробела перед положительным числом и минуса - перед отрицательным:
print("'% d' - '% d'" % (-3, 3))
#  + - вывод знака как у отрицательных, так и у положительных чисел. Если флаг + указан одновременно с флагом пробел, то
# действие последнего будет отменено. Пример:
print("'%+d' - '%+d'" % (-3, 3))

# - <Ширина> - минимальная ширина поля. Если строка не помещается в указанную ширину, значение игнорируется, и строка
# выводится полностью. Примеры:
print("'%10d' - '%-10d'" % (3, 3))
print("'%3s' - '%10s'" % ('string', 'string'))
# Вместо значения ширины можно указать символ "*". В этом случае ширину следует задать внутри кортежа. Пример:
print("'%*s' - '%10s'" % (10, 'string', 'str'))

# - <Точность>- количество знаков после точки у вещественных чисел. Перед этим параметром обязательно должна стоять
# точка. Пример:
print('%s %f %.2f' % (math.pi, math.pi, math.pi))
# Вместо значения точности можно указать символ "*". В этом случае точность следует задать внутри кортежа. Пример:
print("'%*.*f'" % (8, 5, math.pi))

# - <Тип преобразования>
#  - s - преобразование выводимого значения в строку с помощью функции str():
print('%s' % 'Обычная строка')
print('%s %s %s' % (10, 10.52, [1, 2, 3]))
#  - r - преобразование выводимого значения в строку с помощью функции repr():
print('%r' % 'Обычная строка')
#  - а - преобразование выводимого значения в строку вызовом функции ascii():
print('%a' % 'строка')
#  - с - вывод символа с указанным кодом. Выведем числовое значение и соответствующий ему символ:
for i in range(33, 127):
    print('%s => %c' % (i, i))
#  - d и i - вывод целой части заданного числа:
print('%d %d %d' % (10, 25.6, -80))
print('%i %i %i' % (10, 25.6, -80))
#  - о - вывод заданного целого числа в восьмеричном представлении:
print('%o %o' % (0o77, 10))
print('%#o %#o' % (0o77, 10))
# При попытке вывести таким образом вещественное число возникнет ошибка;
#  - х - вывод заданного целого числа в шестнадцатеричном представлении в нижнем регистре (при попытке вывести
#  вещественное число возникнет ошибка):
print('%x %x' % (0xff, 10))
print('%#x %#x' % (0xff, 10))
#  - X - вывод заданного целого числа в шестнадцатеричном представлении в верхнем регистре (при попытке вывести
#  вещественное число возникнет ошибка):
print('%X %X' % (0xff, 10))
print('%#X %#X' % (0xff, 10))
#  - f и F - вывод заданного вещественного числа в десятичном представлении:
print('%f %f %f' % (300, 18.65781452, -12.5))
print('%F %F %F' % (300, 18.65781452, -12.5))
print('%#.0F %.0F' % (300, 300))
#  - е - вывод заданного вещественного числа в экспоненциальной форме (буква е выводится в нижнем регистре):
print('%e %e' % (3000, 18657.81452))
#  - Е - вывод заданного вещественного числа в экспоненциальной форме (буква Е выводится в верхнем регистре):
print('%E %E' % (3000, 18657.81452))
#  - g - эквивалентно f или е (выбирается более короткая запись числа):
print('%g %g %g' % (0.086578, 0.000086578, 1.865E-005))
#  - G - эквивалентно F или E (выбирается более короткая запись числа):
print('%G %G %G' % (0.086578, 0.000086578, 1.865E-005))

# Если внутри строки необходимо использовать символ процента, этот символ следует удвоить, иначе будет выведено
# сообщение об ошибке:
# print('%%s' % '- это символ процента')  # Ошибка
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 322, in <module>
#     print('%%s' % '- это символ процента') # Ошибка
#           ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~
# TypeError: not all arguments converted during string formatting
print('%% %s' % '- это символ процента')  # Нормально
# Форматирование строк очень удобно использовать при передаче данных в шаблон веб-страницы. Для этого заполняем словарь
# данными и указываем его справа от символа %, а сам шаблон - слева. Продемонстрируем это на примере test_00028.py.
# Результат выполнения:
# <html>
# <head><title>Это название документа</title>
# </head>
# <body>
# <h1>Это заголовок первого уровня</hl>
# <div>Это основное содержание страницы</div>
# </body>
# </html>

# Для форматирования строк также можно использовать следующие методы, поддерживаемые объектом строки:
# - expandtabs([<Ширина поля>])- заменяет каждый символ табуляции в текущей строке пробелами так, чтобы общая ширина
# фрагмента вместе с текстом, расположенным перед символом табуляции, была равна указанной величине. Если параметр не
# указан, то ширина поля предполагается равной 8 символам. Пример:
s = '1\t12\t123\t'
print("'%s'" % s.expandtabs(4))
# В этом примере ширина задана равной четырем символам. Поэтому во фрагменте 1\t табуляция будет заменена тремя
# пробелами, во фрагменте 12\t - двумя пробелами, а во фрагменте 123\t - одним пробелом. Во всех трех фрагментах ширина
# будет равна четырем символам.
# Если перед символом табуляции нет текста или количество символов перед табуляцией равно указанной в вызове метода
# ширине, то табуляция заменяется указанным количеством пробелов:
s = '\t'
print("'%s' - '%s'" % (s.expandtabs(), s.expandtabs(4)))
s = '1234\t'
print("'%s'" % s.expandtabs(4))
# Если количество символов перед табуляцией больше ширины, то табуляция заменяется пробелами таким образом, чтобы ширина
# фрагмента вместе с текстом делилась без остатка на указанную ширину:
s = '12345\t123456\t1234567\t1234567890\t'
print("'%s'" % s.expandtabs(4))
# Таким образом, если количество символов перед табуляцией больше 4, но менее 8, то фрагмент дополняется пробелами до 8
# символов. Если количество символов больше 8, но менее 12, то фрагмент дополняется пробелами до 12 символов и т. д. Все
# это справедливо при указании, в качестве параметра числа 4;

# - center(<Ширина>[, <Символ>]) - выравнивает текущую строку по центру внутри поля указанной ширины с добавлением слева
# и справа символов из второго параметра (если он не указан, будут добавлены пробелы):
s = 'str'
print(s.center(15), s.center(11, '-'))
# Теперь произведем выравнивание трех фрагментов шириной 15 символов: первого - по правому краю, второго - по левому, а
# третьего - по центру:
s = 'str'
print("'%15s' '%-15s' '%s'" % (s, s, s.center(15)))
# Если количество символов в текущей строке превышает ширину поля, то значение ширины игнорируется и строка возвращается
# полностью:
s = 'string'
print(s.center(6), s.center(5))

# - ljust(<Ширина>[, <Символ>]) - выравнивает текущую строку по левому краю внутри поля указанной ширины с добавлением
# справа символов из второго параметра (если он не указан, будут добавлены пробелы). Если количество символов в текущей
# строке превышает ширину поля, то значение ширины, игнорируется и строка возвращается полностью. Примеры:
s = 'string'
print(s.ljust(15), s.ljust(15, '-'))
print(s.ljust(6), s.ljust(5))

# - rjust(<Ширина>[, <Символ>]) - выравнивает текущую строку по правому краю внутри поля указанной ширины с добавлением
# слева символов из второго параметра (если он не указан, будут добавлены пробелы). Если количество символов в текущей
# строке превышает ширину поля, то значение ширины, игнорируется и строка возвращается полностью. Пример:
s = 'string'
print(s.rjust(15), s.rjust(15, '-'))
print(s.rjust(6), s.rjust(5))

# - zfill(<Ширина>) - выравнивает текущую строку по правому краю внутри поля указанной ширины с добавлением слева нулей.
# Если количество символов в текущей строке превышает ширину поля, то значение ширины, игнорируется и строка
# возвращается полностью. Примеры:
print('5'.zfill(20), '123456'.zfill(5))


# 6.4. Метод format()
print('6.4. Метод format()')
# Для форматирования строк можно использовать метод format(). Он имеет следующий синтаксис вызова:
# <Строка специального формата>.format(*args, **kwargs)
# В качестве результата возвращается отформатированная строка.
# В параметре <Строка специального формата> внутри символов фигурных скобок {и} указываются спецификаторы, имеющие
# следующий синтаксис:
# {[<Поле>][!<Функция>][:<Формат>]}
# Все символы, расположенные вне фигурных скобок, выводятся без преобразований. Если внутри строки необходимо
# использовать символы {и}, то эти символы следует удвоить, иначе возбуждается исключение ValueError, например:
print('Символы {{ и }} - {0}'.format('специальные'))

# - <Поле> - параметр метода format(), в котором указано выводимое значение, в виде его порядкового номера (нумерация
# начинается с нуля) или имени. Допустимо комбинировать позиционные и именованные параметры, при этом именованные
# параметры следует указать последними. Примеры:
print('{0} - {1} - {2}'.format(10, 12.3, 'string'))          # Индексы
arr = [10, 12.3, 'string']
print('{0} - {1} - {2}'.format(*arr))                        # Индексы
print('{model} - {color}'.format(color='red', model='BМW'))  # Имена
d = {'color': 'red', 'model': 'BМW'}
print('{model} - {color}'.format(**d))                       # Имена
print('{color} - {0}'.format(2015, color='red'))             # Комбинация
# В вызове метода format() можно указать список, словарь или объект. Для доступа к элементам списка по индексу внутри
# строки формата применяются квадратные скобки, а для доступа к элементам словаря или атрибутам объекта - точечная
# нотация. Пример:
arr = [10, [12.3, 'string']]
print('{0[0]} - {0[1][0]} - {0[1][1]}'.format(arr))          # Индексы
print('{arr[0]} - {arr[1][1]}'.format(arr=arr))              # Индексы


class Car:
    color = 'red'
    model = 'BMW'


car = Car()
print('{0.model} - {0.color}'.format(car))                   # Атрибуты объекта
# Существует также краткая форма записи, при которой <Поле> не указывается. В этом случае скобки без заданного индекса
# нумеруются слева направо, начиная с нуля. Пример:
print('{} - {} - {} - {n}'.format(1, 2, 3, n = 4))  # '{0} - {1} - {2} - {n}'
print('{} - {} - {n} - {}'.format(1, 2, 3, n = 4))  # '{0} - {1} - {n} - {2}'

# - <Функция> - обозначение функции, обрабатывающей значение перед вставкой в строку. Если указано обозначение s, то
# значение обрабатывается функцией str() , если r, то функцией repr(), а если а, то функцией ascii(). Если параметр не
# указан, для преобразования значения используется функция str(). Пример:
print('{0!s}'.format('строка'))  # str()
print('{0!r}'.format('строка'))  # repr()
print('{0!a}'.format('строка'))  # ascii()

# - <Формат> - должен иметь следующий синтаксис:
# [[<Заполнитель>]<Выравнивание>][<Знак>][#][0][<Ширина>][,][_][.<Точность>][<Преобразование>]
#  - <Ширина> - минимальная ширина поля. Если выводимое значение не помещается в указанную ширину, то ширина,
# игнорируется и значение выводится полностью. Пример:
print("'{0:10}' '{1:3}'".format(3, 'string'))
# Ширину поля можно передать в качестве параметра в методе format(). В этом случае вместо значения ширины внутри
# фигурных скобок указывается индекс соответствующего параметра. Пример:
print("'{0:{1}}'".format(3, 10))  # 10 - это ширина поля
#  - <Выравнивание>:
# < - по левому краю;
# > - по правому краю (поведение по умолчанию);
# ^ - по центру поля.
# Пример:
print("'{0:<10}' '{1:>10}' '{2:^10}'".format(3, 3, 3))
# = - знак числа выравнивается по левому краю, а число - по правому:
print("'{0:=10}' '{1:=10}'".format(-3, 3))
# Как видно из приведенного примера, пространство между знаком и числом по умолчанию заполняется пробелами, а знак у
# положительного числа не указывается. Чтобы вместо пробелов пространство заполнялось нулями, необходимо указать нуль
# перед шириной поля, например:
print("'{0:=010}' '{1:=010}'".format(-3, 3))
# Начиная с Python 3.10, такое же поведение характерно и при выводе строк:
print("'{0:10}'".format('string'))
print("'{0:010}'".format('string'))
#  - <Заполнитель> - символ, которым будет заполняться свободное пространство в поле (по умолчанию пробел):
print("'{0:0=10}' '{1:0=10}'".format(-3, 3))
print("'{0:*<10}' '{1:*>10}' '{2:.^10}'".format(3, 3, 3))
#  - <Знак> - управляет выводом знака числа:
# +- вывод знака как у отрицательных, так и у положительных чисел;
# - - вывод знака только у отрицательных чисел (значение по умолчанию);
# пробел - вывод пробела у положительных чисел и минуса у отрицательных.
# Примеры:
print("'{0:+}' '{1:+}' '{0:-}' '{1:-}'".format(3, -3))
print("'{0: }' '{1: }'".format(3, -3))                  # Пробел
#  - <Преобразование> - у целых чисел:
#   - b - в двоичную систему счисления:
print("'{0:b}' '{0:#b}'".format(3))
#   - с - заданного числа в соответствующий символ:
print("'{0:c}'".format(167))
#   - d - в десятичную систему счисления;
#   - n - аналогично опции d, но учитывает настройки локали. Например, выведем большое число с разделением тысячных
#   разрядов пробелом (точнее, символом с кодом \xao, который при выводе преобразуется в пробел):
print(locale.setlocale(locale.LC_NUMERIC, 'ru_RU.UTF-8'))
print('{0:n}'.format(100000000).replace('\uffa0', ' '))
# Также можно разделить тысячные разряды запятой, указав ее в строке формата:
print('{0:,d}'.format(100000000))
# или символами подчеркивания - таким же образом:
print('{0:_d}'.format(100000000))
#   - о - в восьмеричную систему счисления:
print("'{0:d}' '{0:o}' '{0:#o}'".format(511))
#   - x - в шестнадцатеричную систему счисления в нижнем регистре:
print("'{0:x}' '{0:#x}'".format(255))
#   - X - в шестнадцатеричную систему счисления в верхнем регистре:
print("'{0:X}' '{0:#X}'".format(255))
#  - <Преобразование>- у вещественных чисел:
#   - f и F - в десятичную систему счисления:
print("'{0:f}' '{1:f}' '{2:f}'".format(30, 18.6578145, -2.5))
# По умолчанию выводимое число имеет шесть знаков после запятой. Задать другое количество знаков после запятой можно в
# параметре <Точность>, например:
print("'{0:.7f}' '{1:.2f}'".format(18.6578145, -2.5))
#   - e - в экспоненциальную форму (буква ев нижнем регистре):
print("'{0:e}' '{1:e}'".format(3000, 18657.81452))
#   - E - в экспоненциальную форму (буква Ев верхнем регистре):
print("'{0:E}' '{1:E}'".format(3000, 18657.81452))
# Здесь количество знаков после запятой по умолчанию также равно шести, но можно указать другое количество знаков в
# параметре <Точность>:
print("'{0:.2e}' '{1:.2E}'".format(3000, 18657.81452))
#   - g - эквивалентно f или е(выбирается более короткая запись числа):
print("'{0:g}' '{1:g}'".format (0.086578, 0.000086578))
#   - G - эквивалентно f или Е(выбирается более короткая запись числа):
print("'{0:G}' '{1:G}'".format(0.086578, 0.000086578))
#   - n - аналогично опции g, но учитывает настройки локали;
#   - % - умножает число на 100 и добавляет символ процента в конец. Значение отображается в соответствии с опцией f.
# Пример:
print("'{0:%}' '{1:.4%}'".format(0.086578, 0.000086578))


# 6.4.1. Форматируемые строки
print('6.4.1. Форматируемые строки')
# Форматируемая строка - это более компактная и удобная альтернатива методу format(). Форматируемая строка предваряется
# буквой f или F. В нужных местах такой строки записываются команды на вставку в эти места значений, хранящихся в
# переменных,- точно так же, как и в строках специального формата, описанных ранее. Такие команды имеют следующий
# синтаксис:
# {[<Переменная>][!<Функция>][:<Формат>]}
# Параметр <Переменная> задает имя переменной, из которой будет извлечено вставляемое в строку значение. Вместо имени
# переменной можно записать выражение, вычисляющее значение, которое нужно вывести. Параметры <Функция> и <Формат> имеют
# то же назначение и записываются так же, как и в случае метода format(). Примеры:
a = 10; b = 12.3; s = 'string'
print(f'{a} - {b} - {s}')          # Простой вывод чисел и строк
print(f'{a} - {b:5.2f} - {s}')     # Вывод с форматированием
d = 3
print(f'{a} - {b:5.{d}f} - {s}')   # В опциях можно использовать значения из переменных
arr = [3, 4]
print(f'{arr[0]} - {arr[1]}')      # Вывод элементов массива
print(f'{arr[0]} - {arr[1] * 2}')  # Вывод результатов вычисления выражений
# Начиная с Python 3.8, в форматируемой строке после переменной можно поставить символ равенства(=)- и в строку будет
# подставлено имя этой переменной, знак равенства и значение переменной:
b = 12.3
print(f'{b=}', f'{b = }')
print(f'Значение переменной {b = :5.2f}')
# Этот программный инструмент может быть применен для вывода значений переменных при отладке программ.


# 6.5. Функции и методы для работы со строками
print('6.5. Функции и методы для работы со строками')
# Основные функции для работы со строками:
# - str([<Значение>]) - преобразует заданное значение в строку, которую и возвращает. Если параметр не указан,
# возвращается пустая строка. Используется функцией print() для вывода объектов. Примеры:
print(str(), str([1, 2]), str((3, 4)), str({'x': 1}))
print('строка1\nстрока2')

# - repr(<Значение>) - возвращает строковое представление заданного значения. Используется при выводе данных
# интерпретатором, работающим в интерактивном режиме. Примеры:
print(repr('Строка'), repr([1, 2, 3]), repr({'x': 5}))

# - ascii(<Значение>) - возвращает строковое представление заданного значения, содержащее только символы из кодировки
# ASCII:
print(ascii([1, 2, 3]), ascii({'x': 5}))
print(ascii('строка'))

# - len(<Строка>) - возвращает длину заданной строки в символах:
print(len('Python'), len('\r\n\t'), len(r'\r\n\t'))
print(len('строка'))

# Основные методы, поддерживаемые строками:
# - strip([<Символы>]) - удаляет указанные в параметре символы в начале и в конце текущей строки. Если параметр не
# задан, удаляются пробельные символы: пробел, перевод строки (\n), возврат каретки (\r), горизонтальная (\t) и
# вертикальная (\v) табуляция. Примеры:
s1 = '    str\n\r\v\t'
s2 = 'strstrstrokstrstrstr'
print("'%s' - '%s'" % (s1.strip(), s2.strip('tsr')))

# - lstrip([<Символы>]) - удаляет заданные символы в начале текущей строки (если параметр не указан, удаляет пробелы):
s1 = '       str       '
s2 = 'strstrstrokstrstrstr'
print("'%s' - '%s'" % (s1.lstrip(), s2.lstrip('tsr')))

# - rstrip([<Символы>]) - удаляет заданные символы в конце текущей строки (если параметр не указан, удаляет пробелы):
s1 = '       str       '
s2 = 'strstrstrokstrstrstr'
print("'%s' - '%s'" % (s1.rstrip(), s2.rstrip('tsr')))

# - split([<Разделитель>[, <Лимит>]]) - разделяет текущую строку на подстроки по-указанному разделителю и добавляет эти
# подстроки в список, который возвращает в качестве результата. Если первый параметр не указан или имеет значение None,
# то в качестве разделителя используется символ пробела. Во втором параметре можно задать количество подстрок в
# результирующем списке, если он не указан или равен -1, в список попадут все подстроки. Если подстрок больше указанного
# количества, то список будет содержать еще один элемент - с остатком строки. Примеры:
s = 'word1 word2 word3'
print(s.split(), s.split(None, 1))
s = 'word1\nword2\nword3'
print(s.split('\n'))
# Если в текущей строке содержатся несколько пробелов подряд и разделитель не указан, то пустые элементы не будут
# добавлены в список:
s = 'word1          word2 word3     '
print(s.split())
# При использовании другого разделителя могут возникнуть пустые элементы:
s = ',,word1,,word2,,word3,,'
print(s.split(','))
print('1,,2,,3'.split(','))
# Если разделитель в текущей строке не найден, то список будет состоять из одного элемента, представляющего текущую
# строку:
print('word1 word2 word3'.split('\n'))

# - rsplit([<Разделитель>[, <Лимит>]]) - аналогичен методу split(), но поиск символа разделителя производится не слева
# направо, а наоборот - справа налево:
s = 'word1 word2 word3'
print(s.rsplit(), s.rsplit(None, 1))

# - splitlines([False]) - разделяет текущую строку на подстроки по символу перевода строки (\n) и добавляет их в список.
# Символы новой строки включаются в результат, только если необязательный параметр имеет значение True. Если разделитель
# в текущей строке не найден, список будет содержать только один элемент - саму текущую строку. Примеры:
print('word1\nword2\nword3'.splitlines())
print('word1\nword2\nword3'.splitlines(True))
print('word1 word2 word3'.splitlines())

# - partition(<Разделитель>) - находит первое вхождение указанного символа-разделителя в текущей строке и возвращает
# кортеж из трех элементов: фрагмента, расположенного перед разделителем, разделителя и фрагмента, расположенного после
# разделителя. Поиск производится слева направо. Если символ-разделитель не найден, то первый элемент кортежа будет
# содержать текущую строку, а остальные элементы останутся пустыми. Примеры:
print('word1 word2 word3'.partition(' '))
print('word1 word2 word3'.partition('\n'))

# - rpartition(<Разделитель>) - аналогичен методу partition(), но поиск символа разделителя производится не слева
# направо, а наоборот - справа налево. Если символ разделитель не найден, то первые два элемента кортежа окажутся
# пустыми, а третий элемент будет содержать текущую строку. Примеры:
print('word1 word2 word3'.rpartition(' '))
print('word1 word2 word3'.rpartition('\n'))

# - join() - преобразует последовательность в строку. Элементы добавляются через указанный разделитель. Формат метода:
# <Разделитель>.join(<Последовательность>)
# В качестве примера преобразуем список и кортеж в строку:
print(' => '.join(['word1', 'word2', 'wordЗ']))
print(' '.join(['word1', 'word2', 'wordЗ']))
# Элементы последовательностей должны быть строками, иначе возбуждается исключение TypeError:
# print(' '.join(['word1', 'word2', 5]))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 640, in <module>
#     print(' '.join(['word1', 'word2', 5]))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# TypeError: sequence item 2: expected str instance, int found

# - removeprefix(<Префикс>) (начиная с Python 3.9) - удаляет у текущей строки указанный префикс и возвращает результат.
# Если текущая строка не содержит такого префикса, возвращает текущую строку. Пример:
print('ActivePython'.removeprefix('Active'))
print('CPython'.removeprefix('Active'))

# - removesuffix(<Префикс>) (начиная с Python 3.9) - удаляет у текущей строки указанный суффикс и возвращает результат.
# Если текущая строка не содержит такого суффикса, возвращает текущую строку. Пример:
print('program.py'.removesuffix('.py'))
print('program.js'.removesuffix('.py'))

# Строки относятся к неизменяемым типам данных, поэтому если попытаться изменить какой-либо символ в строке, возникнет
# ошибка. Однако можно преобразовать строку в список с помощью функции list(), изменить нужные символы по их индексам, а
# затем вызовом метода join() превратить список обратно в строку. Пример:
s = 'Python'
arr = list(s)     # Преобразуем строку в список
print(arr)
arr[0] = 'J'      # Изменяем элемент по индексу
print(arr)
s = ''.join(arr)  # Преобразуем список в строку
print(s)
# Если строка содержит лишь символы из кодировки ASCII, ее можно преобразовать в последовательность байтов bytearray:
s = 'Python'
b = bytearray(s, 'cp1251')
print(b)
b[0] = ord('J')
print(b)
s = b.decode('cp1251')
print(s)


# 6.6. Настройка локали
print('6.6. Настройка локали')
# Для установки локали (совокупности языковых настроек системы) служит функция setlocale() из модуля locale. Прежде чем
# использовать функцию, необходимо подключить модуль с помощью выражения
# import locale
# Функция setlocale() имеет следующий формат вызова:
# setlocale(<Категория>[, <Локаль>]);
# Параметр <Категория> может принимать следующие значения:
# - locale.LC_ALL - устанавливает локаль для всех режимов;
# - locale.LC_COLLATE - для сравнения строк;
# - locale.LC_СТУРЕ - для перевода символов в нижний или верхний регистр;
# - locale.LC_MONETARY - для отображения денежных единиц;
# - locale.LC_NUМERIC - для форматирования чисел;
# - locale.LC_ТIМЕ - для форматирования значений даты и времени.
# Получить текущую локаль позволяет функция getlocale([<Категория>]) . Если категория не указана, будет выдана локаль
# для всех категорий. В качестве примера настроим локаль вначале на кодировку Windows-1251, потом на кодировку UTF-8,
# затем на кодировку по умолчанию, после чего выведем текущую локаль для всех категорий и только для locale.LC_COLLATE:
# Для кодировки windows-1251
print(locale.setlocale(locale.LC_ALL, 'ru_RU.UTF-8'))
# Устанавливаем локаль no умолчанию
print(locale.setlocale(locale.LC_ALL, ''))
# Получаем текущее значение лакали для всех категорий
print(locale.getlocale())
# Получаем текущее значение категории locale.LC_COLLATE
print(locale.getlocale(locale.LC_COLLATE))
# Получить настройки локали позволяет функция localeconv() из модуля locale. Функция возвращает словарь с настройками.
# Результат ее выполнения для локали Russian Russia.1251 выглядит следующим образом:
print(locale.localeconv())


# 6.7. Изменение регистра символов
print('6.7. Изменение регистра символов')
# Для изменения регистра символов в строке предназначены следующие методы:
# - upper() - приводит все символы в текущей строке к верхнему регистру:
print('строка'.upper())

# - lower() - приводит все символы в текущей строке к нижнему регистру:
print('СТРОКА'.lower())

# - swapcase() - заменяет в текущей строке все строчные символы соответствующими прописными буквами, а все прописные
# символы - строчными:
print('СТРОКА строка'.swapcase())

# - capitalize() - делает первую букву текущей строки прописной:
print('строка строка'.capitalize())

# - title() - делает первую букву каждого слова в текущей строке прописной:
s = 'первая буква каждого слова станет прописной'
print(s.title())

# - casefold() - то же самое, что и lower(), но дополнительно преобразует все символы с диакритическими знаками и
# лигатуры в буквы стандартной латиницы. Обычно применяется для сравнения строк:
print("Python".casefold() == "python".casefold())
print("grosse".casefold() == "große".casefold())


# 6.8. Функции для работы с символами
print('6.8. Функции для работы с символами')
# Для работы с отдельными символами предназначены следующие функции:
# - chr(<Код символа>) - возвращает символ по указанному коду:
print(chr(177))

# - ord(<Символ>) - возвращает код указанного символа:
print(ord('±'))


# 6.9. Поиск и замена в строке
print('6.9. Поиск и замена в строке')
# Для поиска и замены в строке используются следующие методы:
# - find() - ищет в текущей строке заданную подстроку. Возвращает номер позиции, с которой начинается вхождение
# подстроки в строку. Если подстрока не найдена, возвращает значение -1. Регистр символов учитывается. Формат метода:
# <Строка>.find(<Подстрока>[, <Начало>[, <Конец>]])
# Если параметр <Начало> не указан, то поиск будет осуществляться с начала текущей строки. Если параметры <Начало> и
# <Конец> указаны, то извлекается срез строки:
# <Строка>[<Начало>:<Конец>]
# и поиск подстроки выполняется с начала полученного фрагмента:
s = 'пример пример Пример'
print(s.find('при'), s.find('При'), s.find('тест'))
print(s.find('при', 9), s.find('при', 0, 6), s.find('при', 7, 12))

# - index() - аналогичен методу find(), но если подстрока не найдена, возбуждает исключение ValueError:
s = 'пример пример Пример'
print(s.index('при'), s.index('при', 7, 12), s.index('При', 1))
# print(s.index('тест'))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 760, in <module>
#     print(s.index('тест'))
#           ^^^^^^^^^^^^^^^
# ValueError: substring not found

# - rfind() - ищет в текущей строке заданную подстроку. Возвращает позицию последнего вхождения подстроки в строку. Если
# подстрока не найдена, возвращается значение -1. Регистр символов учитывается. Формат метода:
# <Строка>.rfind(<Подстрока>[, <Начало>[, <Конец>]])
# Если параметр <Начало> не указан, то поиск будет производиться с конца текущей строки. Если параметры <Начало> и
# <Конец> указаны, то извлекается срез строки, и поиск подстроки производится с конца полученного фрагмента. Пример:
s = 'пример пример Пример Пример'
print(s.rfind('при'), s.rfind('При'), s.rfind('тест'))
print(s.rfind('При'), s.rfind('При', 12, 18))

# - rindex() - аналогичен методу rfind(), но если подстрока не найдена, возбуждает исключение ValueError:
s = 'пример пример Пример Пример'
print(s.rindex('при'), s.rindex('При'), s.rindex('при', 0, 6))
# print(s.rindex('тест'))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 779, in <module>
#     print(s.rindex('тест'))
#           ^^^^^^^^^^^^^^^^
# ValueError: substring not found

# - count() - возвращает число вхождений заданной подстроки в текущую строку. Регистр символов учитывается. Формат
# метода:
# <Строка>.count(<Подстрока>[, <Начало>[, <Конец>]])
# Если параметр <Начало> не указан, то подсчет подстрок будет производиться во всей текущей строке. Если параметры
# <Начало> и <Конец> указаны, то извлекается срез строки и подсчет подстрок производится в полученном фрагменте.
# Примеры:
s = 'пример пример Пример Пример'
print(s.count('при'), s.count('при', 6), s.count('При'))
print(s.count('тест'))

# - startswith() - проверяет, начинается ли текущая строка с указанной подстроки. Если начинается, возвращается значение
# True, в противном случае - False. Регистр символов учитывается. Формат метода:
# <Строка>.startswith(<Подстрока>[, <Начало>[, <Конец>]])
# Если параметр <Начало> не указан, сравнение будет производиться с началом текущей строки. Если параметры <Начало> и
# <Конец> указаны, то извлекается срез строки и сравнение производится с началом полученного фрагмента. Примеры:
s = 'пример пример Пример Пример'
print(s.startswith('при'), s.startswith('При'))
print(s.startswith('при', 6), s.startswith('При', 14))
# Параметр <Подстрока> может быть кортежем:
s = 'пример пример Пример Пример'
print(s.startswith(('при', 'При')))

# - endswith() - проверяет, заканчивается ли текущая строка указанной подстрокой. Если заканчивается, то возвращается
# значение True, в противном случае - False. Регистр символов учитывается. Формат метода:
# <Строка>.endswith(<Подстрока>[, <Начало>[, <Конец>]])
# Если параметр <Начало> не указан, то сравнение будет производиться с концом текущей строки. Если параметры <Начало> и
# <Конец> указаны, то извлекается срез строки и сравнение производится с концом полученного фрагмента. Примеры:
s = 'подстрока Подстрока'
print(s.endswith('ока'), s.endswith('ОКА'))
print(s.endswith('ока', 0, 9))
# Параметр <Подстрока> может быть кортежем:
s = 'подстрока Подстрока'
print(s.endswith(('ока', 'ОКА')))

# - replace() - производит замену всех вхождений заданной подстроки в текущей строке на другую подстроку и возвращает
# результат в виде новой строки. Регистр символов учитывается. Формат метода:
# <Строка>.replace(<Заменяемая подстрока>, <Заменяющая подстрока>[, <Максимальное количество замен>])
# Если максимальное количество замен не указано, будет выполнена замена всех найденных подстрок. Примеры:
s = 'Привет, Петя'
print(s.replace('Петя', 'Вася'))
print(s.replace('петя', 'вася'))  # Зависит от регистра
s = 'strstrstrstrstr'
print(s.replace('str', ''), s.replace('str', '', 3))

# - translate(<Таблица символов>) - заменяет символы в текущей строке. Параметр <Таблица символов> должен быть словарем,
# ключами которого являются Unicode-коды заменяемых символов, а значениями - Unicode-коды заменяющих символов. Если
# вместо кода заменяющего символа указать None, то соответствующий заменяемый символ будет удален. Для примера удалим
# букву п, а также изменим регистр всех букв р:
s = 'Пример'
d = {ord('П'): None, ord('р'): ord('Р')}
print(d)
print(s.translate(d))
# Упростить создание таблицы символов позволяет статический метод maketrans(). Формат метода:
# str.maketrans(<X>[, <У>[, <Z>]])
# Если указан только первый параметр, то он должен быть словарем:
t = str.maketrans({'а': 'А', 'о': 'О', 'с': None})
print(t)
print('строка'.translate(t))
# Если указаны два первых параметра, то они должны быть строками одинаковой длины. В результате будет создан словарь с
# ключами из строки <Х> и значениями из строки <У>, расположенными в той же позиции. Изменим регистр некоторых символов:
t = str.maketrans('абвгдежзи', 'АБВГДЕЖЗИ')
print(t)
print('абвгдежзи'.translate(t))
# В третьем параметре можно дополнительно указать строку из символов, которым будет сопоставлено значение None. После
# выполнения метода translate() эти символы будут удалены из строки. Заменим все цифры на О, а некоторые буквы удалим
# из строки:
t = str.maketrans('123456789', 'О' * 9, 'str')
print(t)
print('str123456789str'.translate(t))


# 6.10. Проверка содержимого строки
print('6.10. Проверка содержимого строки')
# Для проверки содержимого строки предназначены следующие методы:
# - isalnum() - возвращает True, если текущая строка содержит только буквы и (или) цифры, в противном случае - False.
# Если строка пустая, возвращается False. Примеры:
print('0123'.isalnum(), '123abc'.isalnum(), 'abc123'.isalnum())
print('строка'.isalnum())
print(''.isalnum(), '123 abc'.isalnum(), 'abc, 123.'.isalnum())

# - isalpha() - возвращает True, если текущая строка содержит только буквы, в противном случае - False. Если строка
# пустая, возвращается False. Примеры:
print('string'.isalpha(), 'строка'.isalpha(), ''.isalpha())
print('123abc'.isalpha(), 'str str'.isalpha(), 'st,st'.isalpha())

# - isascii() (начиная с Python 3.7) - возвращает True, если текущая строка содержит лишь символы из кодировки ASCII, в
# противном случае - False. Если строка пустая, возвращается True. Примеры:
print('123abc'.isascii(), 'строка123'.isascii(), ''.isascii())

# - isdigit()- возвращает True, если текущая строка содержит только обычные цифры, в противном случае - False. Если
# строка пустая, возвращается False. Примеры:
print('0123'.isdigit(), '123abc'.isdigit(), 'abc123'.isdigit())

# - isdecimal() - возвращает True, если текущая строка содержит только символы цифр(обычных, надстрочных и подстрочных),
# в противном случае - False. Если строка пустая, возвращается False. Примеры:
print('123'.isdecimal(), '123стр'.isdecimal(), ''.isdecimal())

# - isnumeric()- возвращает True, если текущая строка содержит только символы чисел (обычные и римские цифры, дробные
# числа), в противном случае - False. Если строка пустая, возвращается False. Примеры:
print('\u2155'.isnumeric(), '\u2155'.isdigit(), ''.isnumeric())
print('\u2155')                                                  # Выведет символ "1/5"

# - isupper() - возвращает True, если текущая строка содержит буквы только, верхнего регистра, в противном случае -
# False. Если строка пустая или не содержит букв, возвращается False. Примеры:
print('STRING'.isupper(), 'СТРОКА'.isupper(), ''.isupper())
print('STRING1'.isupper(), 'СТРОКА, 123'.isupper(), '123'.isupper())
print('string'.isupper(), 'STRing'.isupper())

# - istitle() - возвращает True, если все слова в текущей строке начинаются с заглавной буквы, в противном случае -
# False. Если строка пустая или не содержит букв, возвращается False. Примеры:
print('Str Str'.istitle(), 'Стр Стр'.istitle())
print('Str Str 123'.istitle(), 'Стр Стр 123'.istitle())
print('Str str'.istitle(), 'Стр стр'.istitle())
print(''.istitle(), '123'.istitle())

# - isprintable() - возвращает True, если текущая строка содержит только печатаемые символы, в противном случае - False.
# Пробел относится к печатаемым символам. Если строка пустая, возвращается True. Примеры:
print('123'.isprintable())
print('PHP Python'.isprintable())
print('\n'.isprintable())

# - isspace() - возвращает True, если текущая строка содержит только пробельные символы, в противном случае - False.
# Если строка пустая, возвращается False. Пример:
print(''.isspace(), ' \n\r \t '.isspace(), 'str str'.isspace())

# - isidentifier() - возвращает True, если текущая строка представляет собой допустимое с точки зрения Python имя
# переменной, функции или класса, в противном случае - False:
print('s'.isidentifier())
print('func'.isidentifier())
print('123func'.isidentifier())
# Следует иметь в виду, что метод isidentifier() лишь проверяет, удовлетворяет ли заданное имя правилам языка. Он не
# проверяет, совпадает ли это имя с каким-либо ключевым словом Python. Для выполнения такой проверки надлежит применять
# функцию iskeyword() из модуля keyword, которая возвращает True, если переданная ей строка совпадает с одним из
# ключевых слов, например:
print(keyword.iskeyword('else'))
print(keyword.iskeyword('elsewhere'))
# Переделаем нашу программу суммирования произвольного количества целых чисел, введенных пользователем test_00025.py,
# таким образом, чтобы при вводе строки вместо числа программа не завершалась с фатальной ошибкой. Кроме того,
# предусмотрим возможность ввода отрицательных целых чисел test_00029.py.
# Процесс ввода значений и получения результата выглядит так (значения, введенные пользователем, выделены полужирным
# шрифтом):
# Введите слово 'stop' для получения результата
# Введите число: 10
# Введите число:
# Bы не ввели значение!
# Введите число: str
# Необходимо ввести число, а не строку!
# Введите число: -5
# Введите число: -str
# Необходимо ввести число, а не строку!
# Введите число: stop
# Сумма чисел равна: 5


# 6.11. Двоичные данные типа bytes
print('6.11. Двоичные данные типа bytes')
# Тип данных bytes представляет неизменяемую последовательность байтов (чисел от 0 до 255).
# Создать значение типа bytes можно следующими способами:
# - с помощью функции bytes([<Строка>, <Кодировка> [, <Обработка ошибок>]]). Если параметры не указаны, то возвращается
# пустая последовательность байтов. Чтобы преобразовать заданную строку в значение типа bytes, необходимо передать
# минимум два первых параметра. Если указан только первый параметр, то возбуждается исключение TypeError. Примеры:
print(bytes())
print(bytes('строка', 'cp1251'))
# print(bytes('строка'))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 950, in <module>
#     print(bytes('строка'))
#           ^^^^^^^^^^^^^^^
# TypeError: string argument without an encoding
# В третьем параметре могут быть указаны значения 'strict' (при ошибке возбуждается исключение UnicodeEncodeError -
# значение по умолчанию), 'replace' (неизвестный символ заменяется знаком вопроса) или 'ignore' (неизвестные символы
# игнорируются):
# print(bytes('string\uFFFD', 'ср1251', 'strict'))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 959, in <module>
#     print(bytes('string\uFFFD', 'ср1251', 'strict'))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/encodings/cp1251.py", line 12, in encode
#     return codecs.charmap_encode(input,errors,encoding_table)
#            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# UnicodeEncodeError: 'charmap' codec can't encode character '\ufffd' in position 6: character maps to <undefined>
print(bytes('string\uFFFD', 'ср1251', 'replace'))
print(bytes('string\uFFFD', 'ср1251', 'ignore'))

# - с помощью строкового метода encode([encoding='utf-8'][, errors='strict']). В параметре encoding задается кодировка
# (по умолчанию UTF-8). В параметре errors могут быть указаны значения 'strict' (значение по умолчанию), 'replace',
# 'ignore', 'xmlcharrefreplace' или 'backslashreplace'. Примеры:
print('строка'.encode())
print('строка'.encode(encoding='cp1251'))
print('строка\uFFFD'.encode(encoding='cp1251', errors='xmlcharrefreplace'))
print('строка\uFFFD'.encode(encoding='cp1251', errors='backslashreplace'))

# - указав букву b (регистр не имеет значения) перед строкой в апострофах, кавычках, тройных апострофах или тройных
# кавычках. В строке могут присутствовать только символы из кодировки ASCII, все остальные символы должны быть
# представлены специальными последовательностями. Примеры:
print(b"string", b'string', b"""string""", b'''string''')
# print(b'строка')
#   File "/Chapter_06.py", line 983
#     print(b'строка')
#           ^^^^^^^^^
# SyntaxError: bytes can only contain ASCII literal characters
print(b'\xf1\xf2\xf0\xee\xea\xe0')

# - с помощью функции bytes(<Последовательность>), которая преобразует заданную последовательность целых чисел от О до
# 255 в объект типа bytes. Если какое-либо число из последовательности не попадает в диапазон, возбуждается исключение
# valueError. Примеры:
b = bytes([225, 226, 224, 174, 170, 160])
print(b)
print(str(b, 'cp866'))

# - с помощью функции bytes(<Количество>), которая возвращает последовательность из заданного количества нулевых
# элементов:
print(bytes(10))

# - с помощью метода bytes.fromhex(<Строка>). Заданная строка в этом случае должна содержать только шестнадцатеричные
# числа. Начиная с Python 3.7, числа в строке можно разделять пробелами, которые будут проигнорированы. Пример:
b = bytes.fromhex(' e1 e2e0ae aaa0 ')
print(b)
print(str(b, 'cp866'))

# Как и все последовательности, значения типа bytes поддерживают обращение к элементу по индексу, получение среза,
# конкатенацию, повторение и проверку на вхождение:
b = bytes('string', 'ср1251')
print(b)
print(b[0])                              # Обращение по индексу
print(b[1:3])                            # Получение среза
print(b + b'123')                        # Конкатенация
print(b * 3)                             # Повторение
print(115 in b, b'tr' in b, b'as' in b)
# Как видно из примера, при выводе значения целиком, а также при извлечении среза производится попытка отображения
# символов. Однако доступ по индексу возвращает целое число, а не символ. Если преобразовать объект в список, то мы
# получим последовательность целых чисел:
print(list(bytes('string', 'ср1251')))
# Тип bytes относится к неизменяемым типам. Это означает, что можно получить значение по индексу, но изменить его
# нельзя:
# b = bytes('string', 'ср1251')
# b[0] = 168
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 1023, in <module>
#     b[0] = 168
#     ~^^^
# TypeError: 'bytes' object does not support item assignment
# Объекты типа bytes поддерживают большинство строковых методов, рассмотренных в предыдущих разделах, за исключением
# encode(), isidentifier(), isprintable(), isnumeric(), isdecimal(), format_map(), format() и операции форматирования.
# При использовании этих методов следует учитывать, что в параметрах нужно указывать объекты типа bytes, а не строки,
# например:
b = bytes('string', 'ср1251')
print(b.replace(b's', b'S'))
# Смешивать строки и значения типа bytes в выражениях нельзя. Необходимо явно преобразовать объекты к одному типу, и
# лишь затем производить операцию, например:
# print(b'string' + 'string')
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 1037, in <module>
#     print(b'string' + 'string')
#           ~~~~~~~~~~^~~~~~~~~~
# TypeError: can't concat str to bytes
print(b'string' + 'string'.encode('ascii'))
# Значение типа bytes может содержать как однобайтовые, так и многобайтовые символы. При использовании многобайтовых
# символов некоторые функции могут работать не так, как предполагалось, - например, функция len() вернет количество
# байтов, а не символов:
print(len('строка'))
print(len(bytes('строка', 'cp1251')))
print(len(bytes('строка', 'utf-8')))
# Преобразовать значение типа bytes в строку позволяет метод decode(). Метод имеет следующий формат:
# decode([encoding='utf-8'][, errors='strict'])
# Параметр encoding задает кодировку символов (по умолчанию UTF-8) в текущей последовательности, а параметр errors -
# способ обработки ошибок при преобразовании: 'strict' (значение по умолчанию), 'replace' или 'ignore'. Пример
# преобразования:
b = bytes('строка', 'ср1251')
print(b.decode(encoding='cp1251'))
# Для преобразования также можно воспользоваться функцией str():
b = bytes('строка', 'ср1251')
print(str(b, 'cp1251'))
# Чтобы изменить кодировку данных, сначала следует преобразовать значение типа bytes в строку, а затем произвести
# обратное преобразование, указав нужную кодировку. Преобразуем данные из кодировки Windows-1251 в кодировку KOI8-R,
# а затем обратно:
w = bytes('Строка', 'ср1251')            # Данные в кодировке windows-1251
k = w.decode('cp1251').encode('koi8-r')  # Данные в кодировке KOI8-R
print(k, str(k, 'koi8-r'))
w = k.decode('koi8-r').encode('cp1251')
print(w, str(w, 'ср1251'))               # Данные в кодировке windows-1251
# Последовательности типа bytes можно форматировать с применением оператора %:
print(b'%i - %i - %f' % (10, 20, 30))
# Однако тип преобразования s (т.е. вывод в виде Unicode-строки) в этом, случае не поддерживается, и его использование
# приведет к возбуждению исключения TypeError:
# print(b'%s - %s - %s' % (10, 20, 30))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 1072, in <module>
#     print(b'%s - %s - %s' % (10, 20, 30))
#           ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~
# TypeError: %b requires a bytes-like object, or an object that implements __bytes__, not 'int'
# Метод hex() возвращает строку с шестнадцатеричным представлением текущей последовательности типа bytes. Формат метода:
# hex([<Разделитель>[, <Число байтов в группе>]])
# Поддержка параметров у этого метода появилась в Python 3.8. Параметр <Разделитель> задает разделитель, который будет
# вставляться между отдельными группами байтов в выдаваемой строке (если он не указан, никакой разделитель не
# вставляется). Если параметру <Число байтов в группе> присвоено положительное число, отсчет байтов ведется справа, если
# отрицательное - слева, если параметр вообще не задан, число байтов в группе принимается равным 1. Примеры:
print(b'string'.hex())
print(b'string'.hex('_'), b'string'.hex('_', 4), b'string'.hex('_', -4))


# 6.12. Двоичные данные типа bytearray
print('6.12. Двоичные данные типа bytearray')
# Тип данных bytearray аналогичен типу bytes, только является изменяемым.
# Создать значение типа bytearray можно следующими способами:
# - с помощью функции bytearray([<Строка>, <Кодировка>[, <Обработка ошибок>]]). Если параметры не указаны, то
# возвращается пустая последовательность байтов. Чтобы преобразовать заданную строку в значение типа bytearray,
# необходимо передать как минимум два первых параметра. Если указан только первый параметр, то возбуждается исключение
# TypeError. Примеры:
print(bytearray())
print(bytearray('строка', 'ср1251'))
# print(bytearray('строка'))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 1098, in <module>
#     print(bytearray('строка'))
#           ^^^^^^^^^^^^^^^^^^^
# TypeError: string argument without an encoding
# В третьем параметре могут быть указаны значения 'strict' (при ошибке возбуждается исключение UnicodeEncodeError -
# значение по умолчанию), 'replace' (неизвестный символ заменяется знаком вопроса) или 'ignore' (неизвестные символы
# игнорируются):
# print(bytearray('string\uFFFD', 'ср1251', 'strict'))
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 1107, in <module>
#     print(bytearray('string\uFFFD', 'ср1251', 'strict'))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/encodings/cp1251.py", line 12, in encode
#     return codecs.charmap_encode(input,errors,encoding_table)
#            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# UnicodeEncodeError: 'charmap' codec can't encode character '\ufffd' in position 6: character maps to <undefined>
print(bytearray('string\uFFFD', 'ср1251', 'replace'))
print(bytearray('string\uFFFD', 'ср1251', 'ignore'))

# - с помощью функции bytearray(<Последовательность>), которая преобразует заданную последовательность целых чисел от 0
# до 255 в значение типа bytearray. Если какое-либо число из последовательности не попадает в диапазон, возбуждается
# исключение ValueError. Примеры:
b = bytearray([225, 226, 224, 174, 170, 160])
print(b)
print(str(b, 'cp866'))

# - с помощью функции bytearray(<Количество>), которая вернет последовательность из указанного количества нулевых
# элементов:
print(bytearray(5))

# - с помощью метода bytearray.fromhex(<Строка>). Указанная строка должна содержать только шестнадцатеричные числа и
# пробелы, которые будут проигнорированы. Примеры:
b = bytearray.fromhex(' e1 e2e0ae aaa0 ')
print(b)
print(str(b, 'cp866'))

# Любой элемент в последовательности типа bytearray можно изменить. При этом важно помнить, что присваиваемое ему новое
# значение должно быть целым числом в диапазоне от 0 до 255. Примеры:
b = bytearray('Python', 'ascii')
print(b[0])     # Можем получить значение
b[0] = b'J'[0]  # Можем изменить значение
print(b)
# Для изменения значения типа bytearray также можно использовать следующие методы:
# - append(<Число>) - добавляет заданное число в конец текущей последовательности:
b = bytearray('string', 'ascii')
b.append(b'1'[0])
print(b)

# - extend(<Последовательность>) - добавляет элементы заданной последовательности в конец текущей:
b = bytearray('string', 'ascii')
b.extend(b'123')
print(b)
# Добавить несколько элементов также можно с помощью операторов + и +=:
b = bytearray('string', 'ascii')
print(b + b'123')  # Возвращает новый объект
b += b'456'        # Изменяет текущий объект
print(b)
# Кроме того, можно воспользоваться операцией присваивания значения срезу:
b = bytearray('string', 'ascii')
b[len(b):] = b'123'  # Добавляем элементы в последовательность
print(b)

# - insert(<Индекс>, <Число>) - добавляет заданное число в текущую последовательность по указанному индексу. Остальные
# элементы смещаются. Добавим элемент в начало последовательности:
b = bytearray('string', 'ascii')
b.insert(0, b'1'[0])
print(b)
# Чтобы добавить несколько элементов, можно воспользоваться операцией присваивания значения срезу. Добавим несколько
# элементов в начало объекта:
b = bytearray('string', 'ascii')
b[:0] = b'123'
print(b)

# - рор([<Индекс>]) - удаляет из текущей последовательности элемент, расположенный по указанному индексу, и возвращает
# его. Если индекс не указан, удаляет и возвращает последний элемент. Примеры:
b = bytearray('string', 'ascii')
b.pop()   # Удаляем последний элемент
print(b)
b.pop(0)  # Удаляем первый элемент
print(b)
# Удалить элемент последовательности также позволяет оператор del:
b = bytearray('string', 'ascii')
del b[5]   # Удаляем последний элемент
print(b)
del b[:2]  # Удаляем первый и второй элементы
print(b)

# - remove(<Число>) - удаляет из текущей последовательности первый встреченный элемент, хранящий указанное число. Если
# элемент не найден, возбуждается исключение ValueError. Пример:
b = bytearray('string', 'ascii')
b.remove(b's'[0])
print(b)  # Удаляет только первый элемент

# - reverse() - изменяет порядок следования элементов текущей последовательности на противоположный:
b = bytearray('string', 'ascii')
b.reverse()
print(b)

# Преобразовать значение типа bytearray в строку позволяет метод decode(). Метод имеет следующий формат:
# decode([encoding='utf-8'][, errors='strict'] )
# Параметр encoding задает кодировку символов (по умолчанию UTF-8) в текущей последовательности, а параметр errors -
# способ обработки ошибок при преобразовании: 'strict' (значение по умолчанию), 'replace' или 'ignore'. Пример:
b = bytearray('строка', 'ср1251')
b.decode(encoding='cp1251')
print(b.decode('cp1251'))
# Для преобразования также можно воспользоваться функцией str():
b = bytearray('строка', 'ср1251')
print(str(b, 'cp1251'))


# 6.13. Сериализация и десериализация значений
print('6.13. Сериализация и десериализация значений')
# Сериализация - это преобразование какого-либо значения в последовательность байтов, обычно типа bytes (что может
# понадобиться, например, для записи значения в файл). Десериализация - это обратное преобразование значения из
# последовательности байтов в исходный вид.
# Инструменты для сереализации и десериализации находятся в модуле pickle, который предварительно следует подключить с
# помощью инструкции:
# import pickle
# Для преобразования предназначены две функции:
# - dumps(<Значение>[, protocol=None]) - производит сереализацию заданного значения и возвращает результирующую
# последовательность байтов. Формат, в котором представляется сериализованное значение, зависит от указанного во втором
# параметре протокола, который задается в виде числа от 0 до значения константы pickle.НIGHEST_PROTOCOL.
# Если второй параметр не указан, будет использован протокол 4 (константа pickle.DEFAULT_PROTOCOL, до Python 3.8 этот
# параметр имел значение по умолчанию 3). Пример преобразования списка и кортежа:
obj1 = [1, 2, 3, 4, 5]   # Список
obj2 = (6, 7, 8, 9, 10)  # Кортеж
print(pickle.dumps(obj1))
print(pickle.dumps(obj2))

# - loads(<Последовательность байтов>) - производит десериализацию значения из заданной последовательность байтов.
# Пример восстановления списка и кортежа:
print(pickle.loads(b'\x80\x04\x95\x0f\x00\x00\x00\x00\x00\x00\x00]\x94(K\x01K\x02K\x03K\x04K\x05e.'))  # Список
print(pickle.loads(b'\x80\x04\x95\x0e\x00\x00\x00\x00\x00\x00\x00(K\x06K\x07K\x08K\tK\nt\x94.'))       # Кортеж


# 6.14. Хеширование значений
print('6.14. Хеширование значений')
# Для вычисления хешей на основе последовательностей байтов предназначен модуль hashlib. Предварительно следует
# подключить его с помощью инструкции:
# import hashlib
# Модуль предоставляет следующие функции: md5(), sha1(), sha224(), sha256(), sha384(), sha512(), sha3_224(), sha3_256(),
# sha3_384(), sha3_512(), shake_l28() и shake_256(). В качестве необязательного параметра функциям можно передать
# последовательность байтов, на основе которой следует вычислить хеш:
h1 = hashlib.sha512(b'password')
# Указать хешируемую последовательность байтов также можно с помощью метода update(). В этом случае заданная
# последовательность присоединяется к уже имеющейся. Пример:
h2 = hashlib.sha512(b'pass')
h2.update(b'word')
# Получить хеш в виде последовательности байтов типа bytes и строки, позволяют методы соответственно digest() и
# hexdigest():
d1 = h1.digest()
print(d1)
print(d1 == h2.digest())  # Имитируем сверку хеша пароля, введенного пользователем, с хешем сохраненного пароля
# Пользователь ввел верный пароль!
# Свойство digest_size хранит длину сгенерированного хеша в байтах:
print(h1.digest_size)
# Поддерживаются еще две функции, вычисляющие более устойчивые к взлому хеши:
# - blake2s(<Значение>[, digest_size=З2][, salt=b'']) - хеширует заданное значение по алгоритму BLAКE2s,
# оптимизированному для 32-разрядных систем. Второй параметр задает требуемый размер хеша в виде числа от 1 до 32,
# третий - 'соль' в виде последовательности типа bytes, которая может иметь в длину не более 8 байтов. Возвращает хеш в
# виде последовательности типа bytes. Пример:
h = hashlib.blake2s(b'string', digest_size=16, salt=b'saltsalt')
print(h.digest())

# - blake2b(<Значение>[, digest_size=64][, salt=b""]) - хеширует заданное значение по алгоритму ВLАКЕ2b,
# оптимизированному для 64-разрядных систем. Второй параметр задает требуемый размер хеша в виде числа от 1 до 64,
# третий - 'соль' в виде последовательности типа bytes, которая может иметь в длину не более 16 байтов. Возвращает хеш в
# виде последовательности типа bytes. Пример:
h = hashlib.blake2b(b'string', digest_size=48, salt=b'saltsaltsalt')
print(h.digest())
# ПРИМЕЧАНИЕ - Функции blake2b() и blake2s() поддерживают большое количество параметров, которые применяются только в
# специфических случаях. Полное описание этих функций можно найти в документации по Python. Функция хеширования
# pbkdf2_hmac(), поддерживавшаяся в предыдущих версиях Python, начиная с Python 3.10, объявлена устаревшей и не
# рекомендуется к использованию.
