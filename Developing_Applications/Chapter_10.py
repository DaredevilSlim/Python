#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import calendar  # Подключаем модуля calendar
import datetime  # Подключаем модуля datetime
import locale  # Подключаем модуля locale
import time  # Подключаем модуля time
# Подключаем из модуля timeit содержащийся в нем объект Timer
from timeit import Timer

# ГЛАВА 10
# Работа с датой и временем
# Python предоставляет средства для работы со значениями даты и времени, а также комбинациями даты и времени (временными
# отметками). Кроме того, он содержит инструменты для вывода календаря в виде текста или в формате HTML и измерения
# времени выполнения определенных фрагментов программы для целей отладки.

# 10.1. Получение текущих даты и времени
print('10.1. Получение текущих даты и времени')
# - time() - возвращает количество секунд, прошедшее с начала эпохи (обычно с 1 января 1970 г.), в виде вещественного
# числа:
print(time.time())  # Получаем количество секунд

# - gmtime([<Количество секунд>]) - возвращает универсальное время (UTC) в виде объекта struct_time. Если параметр не
# указан, возвращается текущее время. Если параметр указан, время будет соответствующим заданному количеству секунд,
# прошедших с начала эпохи. Примеры:
print(time.gmtime(0))  # Начало эпохи
print(time.gmtime())  # Текущая дата и время
print(time.gmtime(1690476586.0))  # Дата 27.07.2023
# Получить значение конкретного атрибута можно, указав его имя или индекс внутри объекта:
d = time.gmtime()
print(d.tm_year, d[0])
print(tuple(d))  # Преобразование в кортеж

# - localtime([<Количество секунд>]) - возвращает местное время в виде объекта struct_time. Если параметр не указан,
# возвращается текущее время. Если параметр указан, время будет соответствующим заданному количеству секунд, прошедших с
# начала эпохи. Примеры:
print(time.localtime())  # Текущая дата и время
print(time.localtime(1690476586.0))  # Дата 27.07.2023

# - mktime(<Объект struct_time>) - возвращает количество секунд, прошедших с начала эпохи, в виде вещественного числа.
# В качестве параметра указывается объект struct_time или кортеж из девяти элементов. Если указанная дата некорректна,
# возбуждается исключение OverflowError. Примеры:
d = time.localtime(1690476586.0)
print(time.mktime(d))
print(tuple(time.localtime(1690476586.0)))
print(time.mktime((2023, 7, 27, 19, 49, 46, 3, 208, 1)))
print(time.mktime((1940, 0, 31, 5, 23, 43, 5, 31, 0)))
# Объект struct_time, возвращаемый функциями gmtime() и localtime(), содержит следующие атрибуты (указаны тройки вида
# «имя атрибута - индекс - описание»):
# tm_year - О - год;
# tm_mon - 1 - месяц (число от 1 до 12);
# tm_mday - 2 - день месяца (число от 1 до 31);
# tm_hour - 3 - час (число от 0 до 23);
# tm_min - 4 - минуты (число от 0 до 59);
# tm_sec - 5 - секунды (число от 0 до 59);
# tm_wday - б - день недели (число от 0 для понедельника до 6 для воскресенья);
# tm_yday - 7 - количество дней, прошедшее с начала года (число от 1 до 366);
# tm_isdst - 8 - флаг коррекции летнего времени (значения 0, 1 или -1).
# Выведем текущие дату и время таким образом, чтобы день недели и месяц были написаны по-русски test_00050.py.

# 10.2. Форматирование даты и времени
print('10.2. Форматирование даты и времени')
# Форматирование даты и времени выполняют следующие функции из модуля time:
# - strftime(<Строка формата>[, <Объект struct_time>]) - возвращает строковое представление даты и времени в
# соответствии с заданной строкой формата. Если второй параметр не указан, будут выведены текущие дата и время. Если во
# втором параметре указан объект struct_time или кортеж из девяти элементов, дата будет соответствовать указанному
# значению. Функция зависит от настройки локали. Примеры:
time.strftime('%d.%m.%Y')  # Форматирование даты
print(time.strftime('%H:%M:%S'))  # Форматирование времени
print(time.strftime('%d.%m.%Y', time.localtime(1691990120.1)))

# - strptime(<Строка с датой>[, <Строка формата>]) - разбирает указанную строку с датой и временем в соответствии с
# заданной строкой формата. Возвращает объект struct_time. Если строка не соответствует формату, возбуждается исключение
# ValueError. Если строка формата не указана, используется строка '%а %Ь %d %Н: %М: %S %Y'. Функция учитывает текущую
# локаль
print(time.strptime('Mon Aug 14 08:20:50 2023'))
print(time.strptime('14.08.2023', '%d.%m.%Y'))
# print(time.strptime('14-08-2023', '%d.%m.%Y'))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 74, in <module>
#     print(time.strptime('14-08-2023', '%d.%m.%Y'))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 562, in _strptime_time
#     tt = _strptime(data_string, format)[0]
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 349, in _strptime
#     raise ValueError("time data %r does not match format %r" %
# ValueError: time data '14-08-2023' does not match format '%d.%m.%Y'

# - asctime([<Объект struct_time>]) - возвращает строку формата '%а %Ь %d %H:%M:%S %Y'. Если параметр не указан, будут
# выведены текущие дата и время. Если в параметре указан объект struct_time или кортеж из девяти элементов, то дата
# будет соответствовать указанному значению.
print(time.asctime())  # Текущая дата
print(time.asctime(time.localtime(1601990120.0)))  # Дата в прошлом

# - ctime([<Количество секунд>]) - аналогична asctime(), но в качестве параметра принимает количество секунд, прошедших
# с начала эпохи.
print(time.ctime())  # Текущая дата
print(time.ctime(1691990120.0))  # Дата в прошлом
# В параметре <Строка формата> в функциях strftime() и strptime() могут быть использованы следующие комбинации
# специальных символов:
# %y - год из двух цифр (от '00' до '99');
# %Y - год из четырех цифр (например, '2011 ');
# %m - номер месяца с предваряющим нулем (от '01' до '12');
# %b - аббревиатура месяца в зависимости от настроек локали (например, 'янв' для января);
# %В - название месяца в зависимости от настроек локали (например, 'Январь');
# %d - номер дня в месяце с предваряющим нулем (от '01' до '31');
# %j - день с начала года (от '001' до '366');
# %U - номер недели в году (от '00' до '53'). Неделя начинается с воскресенья. Все дни с начала года до первого
# воскресенья относятся к неделе с номером 0;
# %W - номер недели в году (от '00' до '53'). Неделя начинается с понедельника. Все дни с начала года до первого
# понедельника относятся к неделе с номером 0;
# %w - номер дня недели ('0' - для воскресенья, '6' - для субботы);
# %a - аббревиатура дня недели в зависимости от настроек локали (например, 'Пн' для понедельника);
# %A - название дня недели в зависимости от настроек локали (например, 'понедельник');
# %Н - часы в 24-часовом формате (от '00' до '23');
# %I - часы в 12-часовом формате (от '01' до '12');
# %M - минуты (от '00' до '59');
# %S - секунды (от '00' до '59', изредка до '61 ');
# %p - эквивалент значениям АМ и РМ в текущей локали;
# %c - представление даты и времени в текущей локали;
# %x - представление даты в текущей локали;
# %X - представление времени в текущей локали.
locale.setlocale(locale.LC_ALL, '')
print(time.strftime('%x'))  # Представление даты
print(time.strftime('%X'))  # Представление времени
print(time.strftime('%c'))  # Представление даты и времени
# %Z - название часового пояса или пустая строка (например, 'Московское время', 'UTC');
# %% - символ'%'.
# Вывод текущей даты и времени с помощью функции strftime() (test_00051.py)

# 10.3. Приостановка выполнения программы
print('10.3. Приостановка выполнения программы')
# Функция sleep(<Время в секундах>) из модуля time приостанавливает выполнение программы на указанное время. В качестве
# параметра можно указать целое или вещественное число. Пример:
# time.sleep(5)  # 'Засыпаем' на 5 секунд

# 10.4. Значения даты и времени
print('10.4. Значения даты и времени')
# Модуль datetime предоставляет инструменты для работы со значениями даты и времени:
# выполнения арифметических операций, сравнения, вывода в различных форматах и др.
# Предварительно необходимо подключить модуль с помощью инструкции:
# import datetime

# 10.4.1 Временные промежутки
print('10.4.1 Временные промежутки')
# Временной промежуток - это величина разницы между какими-либо временными отметками (т. е. значениями времени и даты).
# Класс timedelta из модуля datetime позволяет выполнять операции над временными промежутками: складывать, вычитать,
# сравнивать и др. Конструктор класса имеет следующий формат:
# timedelta([days][, seconds][, microseconds][, milliseconds][, minutes][, hours][, weeks])
# Все параметры не являются обязательными и по умолчанию имеют значение 0. Их можно записывать как позиционные или как
# именованные. Первые три параметра считаются основными:
# - days - дни (диапазон -999999999 <= days <= 999999999);
# - seconds - секунды (диапазон 0 <= seconds < 3600*24);
# - microseconds - микросекунды (диапазон О <= microseconds < 1000000).
# Примеры:
print(datetime.timedelta(3))
print(datetime.timedelta(0, 2, 10000))
print(datetime.timedelta(days=1, seconds=7200))

# Все остальные параметры автоматически преобразуются в следующие значения:
# - milliseconds - миллисекунды (одна миллисекунда преобразуется в 1000 микросекунд):
print(datetime.timedelta(milliseconds=1))
# - minutes - минуты (одна минута преобразуется в 60 секунд):
print(datetime.timedelta(minutes=1))
# - hours - часы (один час преобразуется в 3600 секунд):
print(datetime.timedelta(hours=1))
# - weeks - недели (одна неделя преобразуется в 7 дней):
print(datetime.timedelta(weeks=1))

# Получить результат можно с помощью следующих атрибутов:
# - days - дни;
# - seconds - секунды;
# - microseconds - микросекунды.
d = datetime.timedelta(hours=1, days=2, milliseconds=1)
print(d)
print(d.days, d.seconds, d.microseconds)
# Получить результат в секундах позволяет метод total_seconds():
d = datetime.timedelta(minutes=1)
print(d.total_seconds())
# Над временными промежутками можно производить арифметические операции '+', '-', '/', '//', '%' и '*', использовать
# унарные операторы '+' и '-', а также получать абсолютное значение с помощью функции abs(), вычислять частное и остаток
# от деления нацело функцией divmod():
d1 = datetime.timedelta(days=2)
d2 = datetime.timedelta(days=7)
print(d1 + d2, d2 - d1)  # Сложение и вычитание
print(d2 / d1)  # Деление
print(d1 / 2, d2 / 2.5)  # Деление
print(d2 // d1)  # Деление
print(d1 // 2, d2 // 2)  # Деление
print(d2 % d1)  # Остаток
print(d1 * 2, d2 * 2)  # Умножение
print(2 * d1, 2 * d2)  # Умножение
d3 = -d1
print(d3, abs(d3))
print(divmod(d2, d1))
# Кроме того, можно использовать операторы сравнения '=', '!=', '<', '<=', '>' и '>='.
d1 = datetime.timedelta(days=2)
d2 = datetime.timedelta(days=7)
d3 = datetime.timedelta(weeks=1)
print(d1 == d2, d2 == d3)  # Проверка на равенство
print(d1 != d2, d2 != d3)  # Проверка на неравенство
print(d1 < d2, d2 <= d3)  # Меньше, меньше или равно
print(d1 > d2, d2 >= d3)  # Больше, больше или равно
# Также можно получать строковое представление объекта timedelta с помощью функций str() и repr():
d = datetime.timedelta(hours=25, minutes=5, seconds=27)
print(str(d), repr(d))
# Класс timedelta поддерживают следующие атрибуты:
# min - минимальное значение, которое может иметь объект timedelta;
# max - максимальное значение, которое может иметь объект timedelta;
# resolution - минимальное возможное различие между значениями timedelta.
# Вывод значения этих атрибутов:
print(datetime.timedelta.min)
print(datetime.timedelta.max)
print(datetime.timedelta.resolution)

# 10.4.2 Значения даты
print('10.4.2 Значения даты')
# Класс date из модуля datetime позволяет выполнять операции над датами. Конструктор класса имеет следующий формат:
# date(<Год>, <Месяц>, <День>)
# В параметрах указываются числа:
# - <Год> - в диапазоне между значениями констант MINYEAR и МАХУЕАR класса datetime (о нем речь пойдет позже). Выведем
# значения этих констант:
print(datetime.MINYEAR, datetime.MAXYEAR)
# - <Месяц> - от 1 до 12 включительно;
# - <День> - от 1 до количества дней в месяце.
# Если значения выходят за диапазон, возбуждается исключение ValueError. Примеры:
print(datetime.date(2023, 8, 14))
# print(datetime.date(2023, 14, 8))  # Неправильное значение для месяца
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 232, in <module>
#     print(datetime.date(2023, 14, 8))  # Неправильное значение для месяца
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^
# ValueError: month must be in 1..12

# Для создания даты также можно воспользоваться следующими методами класса date:
# - today() - возвращает текущую дату:
print(datetime.date.today())  # Получение текущей даты
# - fromtimestamp(<Количество секунд>) - возвращает дату, которая соответствует заданному количеству секунд, прошедших
# с начала эпохи:
print(datetime.date.fromtimestamp(time.time()))  # Текущая дата
print(datetime.date.fromtimestamp(1691996144.5))  # Дата 2023-08-14

# - fromordinal(<Количество дней с 1-го года>) - возвращает дату, которая соответствует заданному количеству дней,
# прошедших с первого года. В качестве параметра указывается число от 1 до datetime.date.max.toordinal().
print(datetime.date.max.toordinal())
print(datetime.date.fromordinal(3652059))
print(datetime.date.fromordinal(1))

# - fromisoformat(<Строка с датой>) (начиная с Python 3.7) - возвращает дату, созданную в результате преобразования
# заданной строки, которая указывается в формате <ГГГГ>-<ММ>-<ДД>:
print(datetime.date.fromisoformat('2021-12-17'))

# - fromisocalendar() (начиная с Python 3.8) - возвращает дату, созданную на основе заданных параметров. Формат метода:
# fromisocalendar(<Гoд>, <Порядковый номер недели в году>, <Порядковый номер дня в неделе>)
# Пример:
print(datetime.date.fromisocalendar(2023, 2, 4))

# Получить результат можно с помощью следующих атрибутов:
# year - год (число в диапазоне от MINYEAR до МАХУЕАR);
# month - месяц (число от 1 до 12);
# day - день (число от 1 до количества дней в месяце).
d = datetime.date.today()
print(d.year, d.month, d.day)  # Текущая дата 2023 8 14

# Над экземплярами класса date можно производить следующие операции:
# date2 = date1 + timedelta - прибавляет к дате date1 временной промежуток timedelta. Значения атрибутов seconds и
# microseconds временного промежутка игнорируются;
# date2 = date1 - timedelta - вычитает из даты date1 временной промежуток timedelta. Значения атрибутов seconds и
# microseconds временного промежутка игнорируются;
# timedelta = date1 - date2 - возвращает разницу между датами date1 и date2 в виде временного промежутка. Атрибуты
# seconds и microseconds последнего будут иметь значения О.
# Также можно сравнивать две даты с помощью операторов сравнения:
d1 = datetime.date(2023, 8, 14)
d2 = datetime.date(2022, 2, 24)
t = datetime.timedelta(days=10)
print(d1 + t, d1 - t)  # Прибавляем и вычитаем 10 дней
print(d1 - d2)  # Разница между датами
print(d1 < d2, d1 > d2, d1 <= d2, d1 >= d2)
print(d1 == d2, d1 != d2)
# Можно получить строковое представление даты с помощью функций str() и repr():
d = datetime.date(2023, 8, 14)
print(str(d), repr(d))

# Класс date поддерживает следующие методы:
# - replace([year][, month][, day]) - возвращает текущую дату с обновленными значениями года (параметр year),
# месяца (month) и (или) числа (day). Параметры можно указывать как позиционные или как именованные. Примеры:
d = datetime.date(2023, 8, 14)
print(d)
print(d.replace(2023, 8))  # Заменяем год и месяц
print(d.replace(year=2023, month=8, day=14))
print(d.replace(day=14))  # Заменяем только день

# - strftime(<Строка формата>) - возвращает текущую дату в виде строки, отформатированной согласно заданной строке
# формата. В строке формата можно задавать комбинации специальных символов, которые используются в функции strftime() из
# модуля time. Пример:
d = datetime.date(2023, 8, 14)
print(d.strftime('%d.%m.%Y'))

# - isoformat() -возвращает текущую дату в виде строки формата <ГГГГ>-<ММ>-<ДД>:
d = datetime.date(2023, 8, 14)
print(d.isoformat())

# - ctime() - возвращает текущую дату в виде строки формата '%a %b %d %H:%M:%S %Y':
d = datetime.date(2023, 8, 14)
print(d.ctime())

# - timetuple() - возвращает текущую дату в виде объекта struct_time:
d = datetime.date(2023, 8, 14)
print(d.timetuple())

# - toordinal() - возвращает текущую дату в виде количества дней, прошедших с 1-го года:
d = datetime.date(2023, 8, 14)
print(d.toordinal())

# - weekday() - возвращает порядковый номер дня в неделе (О - для понедельника, 6 - для воскресенья):
d = datetime.date(2023, 8, 14)
print(d.weekday())  # 0 - это понедельник

# - isoweekday() - возвращает порядковый номер дня в неделе (1 - для понедельника, 7 - для воскресенья):
d = datetime.date(2023, 8, 14)
print(d.isoweekday())  # 1 - это понедельник

# isocalendar() - возвращает последовательность из трех элементов: года, номера недели в году и порядкового номера дня
# в неделе:
d = datetime.date(2023, 8, 14)
print(d.isocalendar())

# Наконец, имеется поддержка следующих атрибутов класса:
# min - минимально возможное значение даты;
# max - максимально возможное значение даты;
# resolution - минимальное возможное различие между значениями даты.
# Выведем значения этих атрибутов:
print(datetime.date.min)
print(datetime.date.max)
print(datetime.date.resolution)

# 10.4.3 Значения времени
print('10.4.3 Значения времени')
# Класс time из модуля datetime позволяет выполнять операции над значениями времени. Конструктор класса имеет следующий
# формат:
# time((hour][, minute][, second][, microsecond][, tzinfo], [fold])
# Все параметры не являются обязательными. Их можно указывать как позиционные или как именованные, за исключением
# параметра fold, который можно указать только как именованный. В параметрах можно задать следующий диапазон значений:
# - hour - часы (число от 0 до 23);
# - minute - минуты (число от 0 до 59);
# - second - секунды (число от 0 до 59);
# - microsecond - микросекунды (число от 0 до 999999);
# - tzinfo - зона (экземпляр класса tzinfo или значение None).
# - fold - порядковый номер отметки времени. Значение 0 (используется по умолчанию) обозначает первую отметку,
# значение 1 - вторую. Предусмотрен для тех случаев, когда в рассматриваемой временной зоне практикуется перевод часов с
# зимнего на летнее время и обратно, в результате чего часы могут дважды в сутки показывать одинаковое время.
# Если значения выходят за диапазон, возбуждается исключение ValueError. Примеры:
print(datetime.time(23, 12, 38, 375000))
print(datetime.time(hour=23, second=38, minute=12))
# print(datetime.time(25, 12, 38, 375000))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 360, in <module>
#     print(datetime.time(25, 12, 38, 375000))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# ValueError: hour must be in 0..23
# Создать значение времени также можно с помощью метода fromisoformat(<Строка с временем>) класса time (этот метод
# поддерживается, начиная с Python 3.7). Строка с временем должна указываться в формате ISO 8601. Пример:
print(datetime.time.fromisoformat('13:49:24.186500'))
# Получить результат можно с помощью следующих атрибутов:
# hour - часы (число от 0 до 23);
# minute - минуты (число от 0 до 59);
# second - секунды (число от 0 до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo - зона (экземпляр класса tzinfo или значение None).
# fold - порядковый номер отметки времени (число 0 или 1).
t = datetime.time(23, 12, 38, 375000)
print(t.hour, t.minute, t.second, t.microsecond)
# Над значениями времени нельзя выполнять арифметические операции. Можно только производить сравнения, например:
t1 = datetime.time(23, 12, 38, 375000)
t2 = datetime.time(12, 28, 17)
print(t1 < t2, t1 > t2, t1 <= t2, t1 >= t2)
print(t1 == t2, t1 != t2)
# Можно получить строковое представление времени с помощью функций str() и repr():
t = datetime.time(23, 12, 38, 375000)
print(str(t), repr(t))

# Класс time поддерживает следующие методы:
# - replace() - возвращает текущее время с обновленными значениями, указанными в параметрах. Формат метода:
# replace([hour][, minute][, second][, microsecond][, tzinfo][, fold])
# Параметры можно указывать как позиционные или как именованные. Примеры:
t = datetime.time(23, 12, 38, 375000)
print(t.replace(10, 52))  # Заменяем часы и минуты
print(t.replace(second=21))  # Заменяем только секунды

# - isoformat([timespec="auto"]) - возвращает строку с текущим временем в формате ISO 8601. В параметре timespec можно
# указать состав выдаваемого времени, задав одно из следующих значений:
#  - 'auto' - часы, минуты, секунды и микросекунды, если количество последних не равно 0 - в противном случае
# микросекунды не включаются в состав времени;
#  - 'hours' - часы;
#  - 'minutes' - часы и минуты;
#  - 'seconds' - часы, минуты и секунды;
#  - 'milliseconds' - часы, минуты, секунды и миллисекунды (вычисляются путем округления микросекунд до тысячных);
#  - 'microseconds' - часы, минуты, секунды и микросекунды (выводятся всегда, даже если их количество равно 0).
# Примеры:
t = datetime.time(23, 12, 38, 375000)
print(t.isoformat())
print(t.isoformat('minutes'))

# - strftime(<Строка формата>) - возвращает текущее время, отформатированное согласно заданной строке формата. В строке
# формата можно указывать комбинации специальных символов, которые используются в функции strftime () из модуля time.
# Пример:
t = datetime.time(23, 12, 38, 375000)
print(t.strftime('%H:%M:%S'))

# Дополнительно класс time поддерживает такие атрибуты:
# min - минимально возможное значение времени;
# max - максимально возможное значение времени;
# resolution - минимальное возможное различие между значениями времени.
# Значения этих атрибутов:
print(datetime.time.min)
print(datetime.time.max)
print(datetime.time.resolution)
# Класс time поддерживает также методы dst(), utcoffset() и tzname(). За подробной информацией по этим методам, а также
# по абстрактному классу tzinfo обращайтесь к документации по модулю datetime.

# 10.4.4 Временные отметки
print('10.4.4 Временные отметки')
# Класс datetime из модуля datetime позволяет выполнять операции над временными отметками (комбинацией даты и времени).
# Конструктор класса имеет следующий формат:
# datetime(<Гoд>, <Месяц>, <День>[, hour][, minute][, second][, microsecond][, tzinfo][, fold])
# Первые три параметра являются обязательными. Остальные параметры можно указывать как позиционные или как именованные,
# кроме fold, который задается только как именованный. В параметрах можно указать следующие значения:
# <Год> - число, расположенное в диапазоне между значениями из констант MINYEAR(1) и МАХУЕАR(9999);
# <Месяц> - число от 1 до 12 включительно;
# <День> - число от 1 до количества дней в месяце;
# hour - часы (число от 0 до 23);
# minute - минуты (число от 0 до 59);
# second - секунды (число от 0 до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo - зона (экземпляр класса tzinfo или значение None).
# fold - порядковый номер отметки времени. Значение 0 (используется по умолчанию) обозначает первую отметку, значение 1
# - вторую. Предусмотрен для тех случаев, когда в рассматриваемой временной зоне практикуется перевод часов с зимнего на
# летнее время и обратно, в результате чего часы могут дважды в сутки показывать одинаковое время.
# Если значения выходят за диапазон, возбуждается исключение ValueError. Примеры:
print(datetime.datetime(2023, 8, 14))
print(datetime.datetime(2023, 8, 14, hour=21, minute=55))
# print(datetime.datetime(2023, 32, 14))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 448, in <module>
#     print(datetime.datetime(2023, 32, 14))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# ValueError: month must be in 1..12

# Для создания временной отметки также можно воспользоваться следующими методами:
# - today() - возвращает текущие дату и время:
print(datetime.datetime.today())

# - now([<Зона>]) - возвращает текущие дату и время. Если параметр не задан, то метод аналогичен методу today(). Пример:
print(datetime.datetime.now())

# - utcnow() - возвращает текущее универсальное время (UTC):
print(datetime.datetime.utcnow())

# - fromtimestamp(<Количество секунд>[, <Временная зона>]) - возвращает временную отметку, которая соответствует
# заданному количеству секунд, прошедших с начала эпохи:
print(datetime.datetime.fromtimestamp(time.time()))
print(datetime.datetime.fromtimestamp(1692039037.0))

# - utcfromtimestamp(<Количество секунд>) - возвращает временную отметку, которая соответствует заданному количеству
# секунд, прошедших с начала эпохи, в универсальном времени (UTC).
print(datetime.datetime.utcfromtimestamp(time.time()))
print(datetime.datetime.utcfromtimestamp(1692039037.0))

# - fromordinal(<Количество дней с 1-го года>) - возвращает дату, которая соответствует заданному количеству дней,
# прошедших с 1-го года. В качестве параметра указывается число от 1 до datetime.datetime.max.toordinal(). Примеры:
print(datetime.datetime.fromordinal(3652059))
print(datetime.datetime.fromordinal(1))

# - fromisoformat(<Строка с датой и временем>) (начиная с Python 3.7)- возвращает временную отметку, созданную в
# результате преобразования заданной строки, которая указывается в формате ISO 8601:
print(datetime.datetime.fromisoformat('2023-08-14T22:40:53.190301'))

# - fromisocalendar() (начиная с Python 3.8)- возвращает временную отметку, созданную на основе заданных параметров.
# Формат метода:
# fromisocalendar(<Гoд>, <Порядковый номер недели в году>, <Порядковый номер дня в неделе>)
# Пример:
print(datetime.datetime.fromisocalendar(2022, 2, 4))

# - combine(<Дата>, <Время>[, <Временная зона>]) - возвращает временную отметку, созданную на основе переданных ему даты
# и времени:
d = datetime.date(2023, 8, 14)  # Дата
t = datetime.time(22, 46, 22)  # Время
print(datetime.datetime.combine(d, t))

# - strptime(<Строка с датой>, <Строка формата>) - возвращает временную отметку, созданную на основе разбора заданной
# строки с датой в соответствии с указанной строкой формата. Если строка с датой не соответствует формату, возбуждается
# искшочение ValueError. Метод учитывает текущую локаль. Примеры:
print(datetime.datetime.strptime('14.08.2023', '%d.%m.%Y'))
# print(datetime.datetime.strptime('14.08.2023', '%d-%m-%Y'))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 500, in <module>
#     print(datetime.datetime.strptime('14.08.2023', '%d-%m-%Y'))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 568, in _strptime_datetime
#     tt, fraction, gmtoff_fraction = _strptime(data_string, format)
#                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 349, in _strptime
#     raise ValueError("time data %r does not match format %r" %
# ValueError: time data '14.08.2023' does not match format '%d-%m-%Y'
# Получить результат можно с помощью следующих атрибутов:
# year - год (число в диапазоне от MINYEAR до МАХУЕАR);
# month - месяц (число от 1 до 12);
# dау - день (число от 1 до количества дней в месяце );
# hour - часы (число от 0 до 23);
# minute - минуты (число от 0 до 59);
# second - секунды (число от о до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo - временная зона (объект класса tzinfo или значение None).
# fold - порядковый номер отметки времени (число 0 или 1).
# Примеры:
d = datetime.datetime(2023, 8, 14, 22, 52, 22)
print(d.year, d.month, d.day)
print(d.hour, d.minute, d.second, d.microsecond)

# Над временными отметками можно производить следующие операции:
# - datetime2 = datetime1 + timedelta - сложение временной отметки datetime1 и временного промежутка timedelta;
# - datetime2 = datetime1 - timedelta - вычитание из временной отметки datetime1 временного промежутка timedelta;
# - timedelta = datetime1 - datetime2 - возвращает разницу между временными отметками datetime1 и datetime2 в виде
# временного промежутка.
# Также можно сравнивать две даты с помощью операторов сравнения. Примеры:
d1 = datetime.datetime(2023, 8, 14, 22, 57, 22)
d2 = datetime.datetime(2022, 2, 24, 4, 31, 4)
t = datetime.timedelta(days=10, minutes=10)
print(d1 + t)  # Прибавляем 10 дней и 10 минут
print(d1 - t)  # Вычитаем 10 дней и 10 минут
print(d1 - d2)  # Разница между датами
print(d1 < d2, d1 > d2, d1 <= d2, d1 >= d2)
print(d1 == d2, d1 != d2)
# Можно получить строковое представление временной отметки с помощью функций str() и repr():
d = datetime.datetime(2023, 8, 14, 23, 39, 21, 998076)
print(str(d), repr(d))

# Класс datetime поддерживают следующие методы:
# - date() - возвращает текущую дату в виде объекта date:
d = datetime.datetime(2023, 8, 14, 23, 39, 21)
print(d.date())

# - time() - возвращает текущее время в виде объекта time без временной зоны:
d = datetime.datetime(2023, 8, 14, 23, 39, 21)
print(d.time())

# - timetz() - возвращает текущее время в виде объекта time с временной зоной;

# - timestamp() - возвращает количество секунд, прошедшее с начала эпохи (обычно с 1 января 1970 г.), в виде
# вещественного числа:
d = datetime.datetime(2023, 8, 14, 23, 39, 21)
print(d.timestamp())

# - replace() - возвращает текущую временную отметку с обновленными значениями, взятыми из параметров. Формат метода:
# replace([year][, month][, day][, hour][, minute][, second][, microsecond][, tzinfo][, fold])
# Параметры можно указывать как позиционные или как именованные, за исключением fold, который указывается только как
# именованный. Примеры:
d = datetime.datetime(2022, 8, 15, 8, 39, 21)
print(d.replace(2023, 8))
print(d.replace(hour=12, minute=10, microsecond=38))

# - timetuple() - возвращает текущие дату и время в виде объекта struct_time:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.timetuple())

# - utctimetuple() - возвращает текущие дату и время в виде объекта struct_time в универсальном времени (UTC):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.utctimetuple())

# - toordinal() - возвращает количество дней, прошедшее с 1-го года:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.toordinal())

# - weekday() - возвращает порядковый номер дня в неделе (0 - для понедельника, 6 - для воскресенья):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.weekday())  # 1 - это вторник

# - isoweekday() - возвращает порядковый номер дня в неделе (1- для понедельника, 7 - для воскресенья):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.isoweekday())  # 2 - это вторник

# - isocalendar() - возвращает кортеж из трех элементов (год, номер недели в году и порядковый номер дня в неделе):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
isoc = d.isocalendar()
print(isoc[0], isoc[1], isoc[2])

# - isoformat([<Разделитель>][, ] [timespec="auto"]) - возвращает дату в формате ISO 8601. Если разделитель не указан,
# используется буква т. В параметре timespec можно указать состав выдаваемого времени, задав одно из следующих значений:
#  - 'auto' - часы, минуты, секунды и микросекунды, если количество последних не равно О - в противном случае
# микросекунды не включаются в состав времени;
#  - 'hours' - часы;
#  - 'minutes' - часы и минуты;
#  - 'seconds' - часы, минуты и секунды;
#  - 'milliseconds' - часы, минуты, секунды и миллисекунды (вычисляются путем округления микросекунд до тысячных);
#  - 'microseconds' - часы, минуты, секунды и микросекунды (выводятся всегда, даже если их количество равно О).
# Примеры:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.isoformat())  # Разделитель не указан
print(d.isoformat())  # Пробел в качестве разделителя

# - ctime() - возвращает текущие дату и время в виде строки формата "%а %b %d %H:%M:%S %y":
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.ctime())

# - strftime(<Строка формата>) - возвращает текущие дату и время в виде строки, отформатированной согласно заданной
# строке формата. В строке формата можно указывать комбинации специальных символов, которые используются в функции
# strftime() из модуля time. Пример:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.strftime('%d.%m.%Y %H:%M:%S'))

# Класс datetime поддерживает также следующие атрибуты:
# min - минимально возможные значения даты и времени;
# max - максимально возможные значения даты и времени;
# resolution - минимальное возможное различие между значениями даты и времени.
# Значения этих атрибутов:
print(datetime.datetime.min)
print(datetime.datetime.max)
print(datetime.datetime.resolution)
# Примечание - Класс datetime также поддерживает методы astimezone(), dst(), utcoffset() и tzname(). За подробной
# информацией по этим методам, а также по абстрактному классу tzinfo обращайтесь к документации по модулю datetime.

# 10.5. Вывод календаря
print('10.5. Вывод календаря')
# Модуль calendar формирует календарь в виде простого текста или НТМL-кода. Прежде чем использовать модуль, необходимо
# подключить его с помощью инструкции:
# import calendar
# Класс Calendar, содержащийся в этом модуле, является базовым, от которого наследуют остальные классы календарей,
# описываемые далее. Формат конструктора:
# Calendar([<Первый день недели>])
# В параметре указывается число от О (для понедельника) до 6 (для воскресенья). Если параметр не указан, его значение
# принимается равным О. Вместо чисел можно использовать значения переменных: MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
# FRIDAY, SATURDAY или SUNDAY, содержащихся в модуле calendar.
# В качестве примера получим двумерный список всех дней в январе 2022 года, распределенных по дням недели:
c = calendar.Calendar()
print(c.monthdayscalendar(2023, 8))
# В дальнейшем указать другой первый день недели у объекта календаря позволяет метод setfirstweekday(<Первый день
# недели>). В качестве примера получим календарь на февраль 2022 года, где первым днем недели является воскресенье:
c.setfirstweekday(calendar.SUNDAY)
print(c.monthdayscalendar(2022, 2))

# 10.5.1. Вывод календаря в текстовом виде
print('10.5.1. Вывод календаря в текстовом виде')
# Для формирования календаря в текстовом виде служат два класса из модуля calendar:
# - TextCalendar - выводит названия месяцев и дней недели по-английски. Формат конструктора:
# TextCalendar([<Первый день недели>])
# Параметр указывается в таком же формате, что и у класса Calendar (см. разд. 10.5). Выведем календарь на весь 2023 год:
c = calendar.TextCalendar()
print(c.formatyear(2023))
# Результатом станет большая строка, содержащая календарь в виде отформатированного текста;

# - LocaleTextCalendar - выводит названия месяцев и дней недели в соответствии с указанной локалью. Формат конструктора:
# LocaleTextCalendar([<Первый день недели>[, <Название локали>]])
# Выведем календарь на весь 2023 год на русском языке:
c = calendar.LocaleTextCalendar(0, ('ru_RU', 'UTF-8'))
print(c.formatyear(2023))
# Классы TextCalendar и LocaleTextCalendar поддерживают следующие методы:

# - formatmonth() - возвращает текстовый календарь на указанный месяц в заданном году.
# Формат метода:
# formatmonth(<Год>, <Месяц>[, <Ширина поля с днем>[, <Количество символов перевода строки>]])
# Третий параметр задает ширину поля с днем, а четвертый параметр - количество символов перевода строки между строками.
# Выведем календарь на декабрь 2022 года:
c = calendar.LocaleTextCalendar(0, ('ru_RU', 'UTF-8'))
print(c.formatmonth(2023, 12))

# - prmonth() - аналогичен методу formatmonth(), только сразу выводит календарь в консоль. Распечатаем календарь на
# август 2023 года, указав ширину поля с днем, равной 4 символам:
c = calendar.LocaleTextCalendar(0, ('ru_RU', 'UTF-8'))
print(c.prmonth(2022, 12, 4))

# formatyear(<Год>[, w=2][, 1=1][, с=6][, m=3]) - возвращает текстовый календарь на указанный год. Параметры имеют
# следующее предназначение:
# - w - ширина поля с днем;
# - l - количество символов перевода строки между строками;
# - c - количество пробелов между месяцами;
# - m - количество месяцев на строке.
# Их можно указывать как позиционные или как именованные.
# Сформируем календарь на 2024 год, выведем на одной строке сразу четыре месяца и установим количество пробелов между
# месяцами, равное 2:
c = calendar.LocaleTextCalendar(0, ('ru_RU', 'UTF-8'))
print(c.formatyear(2023, m=4, c=2))

# pryear() - аналогичен методу formatyear(), только сразу выводит календарь в консоль. Распечатаем календарь на 2024
# год по два месяца на строке, расстояние между месяцами установим равным четырем символам, ширину поля с датой -
# равной двум символам, а строки разделим одним символом перевода строки:
c = calendar.LocaleTextCalendar(0, ('ru_RU', 'UTF-8'))
print(c.pryear(2024, 2, 1, 4, 2))


# 10.5.2. Вывод календаря в формате HTML
print('10.5.2. Вывод календаря в формате HTML')
# Для формирования календаря в формате НТМL служат два класса из модуля calendar:
# - HTМLCalendar() - выводит названия месяцев и дней недели по-английски. Формат конструктора:
# HTМLCalendar([<Первый день недели>])
# Параметр указывается в таком же формате, что и у класса Calendar (см. разд. 10.5).Выведем календарь на весь 2023 год:
c = calendar.HTMLCalendar()
print(c.formatyear(2023))
# Результатом будет большая строка с НТМL-кодом календаря, отформатированного в виде таблицы;

# - LocaleHTМLCalendar() - выводит названия месяцев и дней недели в соответствии с указанной локалью. Формат
# конструктора:
# LocaleHTМLCalendar([<Первый день недели>[, <Название локали>]])
# Выведем календарь на весь 2023 год на русском языке в виде отдельной веб-страницы:
c = calendar.LocaleHTMLCalendar(0, ('ru_RU', 'UTF-8'))
xhtml = c.formatyearpage(2022, encoding='windows-1251')
print(xhtml.decode('cp1251'))

# Классы HTМLCalendar и LocaleHТМLCalendar поддерживают следующие методы:
# - formatmonth(<Год>, <Месяц>[, <True|False>]) - возвращает календарь на указанный месяц в заданном году в виде
# НТМL-кода, содержащего только таблицу (тег <table>).
# Если в третьем параметре указано значение True (значение по умолчанию), то в заголовке таблицы после названия месяца
# будет указан год. Выведем календарь на август 2023 года:
c = calendar.LocaleHTMLCalendar(0, ('ru_RU', 'UTF-8'))
print(c.formatmonth(2023, 8))
# У каждой ячейки НТМL-таблицы, формирующей календарь, указывается стилевой класс, соответствующий одному из дней
# недели. Благодаря этому к ячейкам можно привязывать разные СSS-стили. Имена этих стилевых классов доступны через
# атрибут cssclasses класса календаря:
c = calendar.HTMLCalendar(0)
print(c.cssclasses)

# Начиная с Python 3.7, класс календаря поддерживает следующие атрибуты, задающие другие стилевые классы:
# - cssclass_noday - имя стилевого класса, указываемого у пустых ячеек календаря (соответствующих дням предыдущего и
# следующего месяцев). По умолчанию: 'noday';

# - cssclasses_weekday_head - список имен стилевых классов, указываемых у заголовочных ячеек с названиями дней недели
# (по умолчанию совпадает со списком из атрибута cssclasses);

# - cssclass_month_head - имя стилевого класса, указываемого у заголовочной ячейки с названием месяца (по умолчанию:
# 'month');

# - cssclass_month - имя стилевого класса, указываемого. у таблицы, в которой выводится календарь за месяц (по
# умолчанию: 'month');

# - cssclass_year_head - имя стилевого класса, указываемого у заголовочной ячейки с годом (по умолчанию: 'year');

# - cssclass_year - имя стилевого класса, указываемого у таблицы, в которой выводится календарь за весь год (по
# умолчанию: 'year').

# Выведем календарь на август 2023 года, указав другие имена стилевых классов для ячеек с днями недели и заголовочной
# ячейки с месяцем:
c = calendar.LocaleHTMLCalendar(0, ('ru_RU', 'UTF-8'))
c.cssclasses = ['workday', 'workday', 'workday', 'workday', 'workday', 'week-end', 'week-end']
c.cssclass_month_head = 'month-head'
print(c.formatmonth(2023, 8, False))

# - formatyear(<Год>[, <Количество месяцев на строке>]) - возвращает календарь на указанный год в виде НТМL-кода.
# Календарь будет отформатирован с помощью нескольких НТМL-таблиц. Если количество месяцев в строке не задано,
# принимается значение 3. Выведем календарь на 2023 год так, чтобы на одной строке выводились сразу четыре месяца:
c = calendar.LocaleHTMLCalendar(0, ('ru_RU', 'UTF-8'))
print(c.formatyear(2023, 8))

# - formatyearpage(<Год>[, width][, css][, encoding]) - возвращает календарь на указанный год в виде отдельной
# веб-страницы. Параметры имеют следующее предназначение:
# - width - количество месяцев на строке (по умолчанию: 3);
# - css - название файла с таблицей стилей (по умолчанию: 'calendar.css');
# - encoding- кодировка файла, указываемая в параметре encoding ХМL-пролога и теге <meta> (по умолчанию не указана).
# Параметры можно указывать как позиционные или как именованные.
# Выведем календарь на 2023 год так, чтобы на одной строке выводились четыре месяца, дополнительно указав кодировку:
c = calendar.LocaleHTMLCalendar(0, ('ru_RU', 'UTF-8'))
xhtml = c.formatyearpage(2023, 8, encoding='windows-1251')
print(type(xhtml))  # Возвращаемая строка имеет тип данных bytes
print(xhtml.decode('cp1251'))


# 10.5.3. Другие полезные функции
print('10.5.3. Другие полезные функции')
# Модуль calendar предоставляет еще ряд полезных функций:
# - setfirstweekday(<Первый день недели>) - устанавливает первый день недели для календаря. В качестве параметра
# указывается число от 0 (для понедельника) до 6 (для воскресенья). Вместо чисел можно использовать значения
# переменных: MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY или SUNDAY. Получить текущее значение параметра
# можно с помощью функции firstweekday(). Установим воскресенье первым днем недели:
print(calendar.firstweekday())  # По умолчанию 0
calendar.setfirstweekday(6)     # Изменяем значение
print(calendar.firstweekday())  # Проверяем установку

# - month() - возвращает текстовый календарь на указанный месяц в году. Формат функции:
# month(<Год>, <Месяц>[, <Ширина поля с днем>[, <Количество символов перевода строки>])
# Третий параметр указывает ширину поля с днем, а четвертый - количество символов перевода строки между строками.
# Выведем календарь на август 2023 года:
calendar.setfirstweekday(0)
print(calendar.month(2023, 8))

# - prmonth() - аналогична функции month() , только сразу выводит календарь в консоль.
# Выведем календарь на август 2023 года:
print(calendar.prmonth(2023, 8))

# - monthcalendar(<Год>, <Месяц>) - возвращает двумерный список всех дней в указанном месяце указанного года,
# распределенных по дням недели. Дни, выходящие за пределы месяца, будут представлены нулями. Выведем массив для августа
# 2022 года:
print(calendar.monthcalendar(2023, 8))

# - monthrange(<Год>, <Месяц>) - возвращает кортеж из двух элементов: номера дня недели, приходящегося на первое число
# указанного месяца указанного года, и количества дней в месяце:
print(calendar.monthrange(2023, 8))
# Август 2023 года начинается со вторника (0) и включает 31 день

# - calendar(<Год>[, w=2][, 1=1][, с=6] [, m=3]) - возвращает текстовый календарь на указанный год. Параметры имеют
# следующее предназначение:
# - w - ширина поля с днем;
# - l - количество символов перевода строки между строками;
# - с - количество пробелов между месяцами;
# - m - количество месяцев на строке.
# Параметры можно указывать как позиционные или как именованные.
# Выведем календарь на 2023 год так, чтобы на одной строке выводились сразу четыре месяца, указав два пробела между
# месяцами:
print(calendar.calendar(2023, m=4, c=2))

# - prcal() - аналогична функции calendar(), только сразу выводит его календарь в консоль. Выведем календарь на 2023 год
# по два месяца на строке, расстояние между месяцами установим равным четырем символам, ширину поля с датой - равной
# двум символам, а строки разделим одним символом перевода строки:
print(calendar.prcal(2023, 2, 1, 4, 2))

# - weekheader(<Длина>) - возвращает строку, которая содержит аббревиатуры дней недели с учетом текущей локали,
# разделенные пробелами. Единственный параметр задает длину каждой аббревиатуры в символах. Примеры:
print(locale.setlocale(locale.LC_ALL, ('en_US', 'UTF-8')))
print(calendar.weekheader(4))
print(calendar.weekheader(2))
print(locale.setlocale(locale.LC_ALL, ('ru_RU', 'UTF-8')))
print(calendar.weekheader(2))

# - isleap(<Год>) - возвращает значение True, если указанный год является високосным, в противном случае - False:
print(calendar.isleap(2022), calendar.isleap(2024))

# - leapdays(<Год 1>, <Год 2>) - возвращает количество високосных лет в диапазоне от <Год 1> до <Год 2> (<Год 2> не
# учитывается):
print(calendar.leapdays(2021, 2024))  # 2024 не учитывается
print(calendar.leapdays(2020, 2024))  # 2020 - високосный год
print(calendar.leapdays(2020, 2025))  # 2020 и 2024 - високосные года

# - weekday(<Год>, <Месяц>, <День>) - возвращает номер дня недели (О - для понедельника, 6 - для воскресенья):
print(calendar.weekday(2022, 1, 17))

# - timegm(<Объект struct_time>)- возвращает количество секунд, прошедших с начала эпохи. В качестве параметра
# указывается объект struct_time с датой и временем, возвращаемый функцией gmtime() из модуля time. Примеры:
d = time.gmtime(1692570423.0)  # Дата 20-08-2023
print(d)
print(tuple(d))
print(calendar.timegm(d))
print(calendar.timegm((2023, 8, 20, 22, 27, 3, 4, 351, 0)))

# Модуль calendar также поддерживает ряд полезных атрибутов:
# - day_name - список полных названий дней недели в текущей локали:
print(locale.setlocale(locale.LC_ALL, ('en_US', 'UTF-8')))
print([i for i in calendar.day_name])
print(locale.setlocale(locale.LC_ALL, ('ru_RU', 'UTF-8')))
print([i for i in calendar.day_name])

# - dау_abbr- список аббревиатур названий дней недели в текущей локали:
print(locale.setlocale(locale.LC_ALL, ('en_US', 'UTF-8')))
print([i for i in calendar.day_abbr])
print(locale.setlocale(locale.LC_ALL, ('ru_RU', 'UTF-8')))
print([i for i in calendar.day_abbr])

# - month_name - список полных названий месяцев в текущей локали:
print(locale.setlocale(locale.LC_ALL, ('en_US', 'UTF-8')))
print([i for i in calendar.month_name])
print(locale.setlocale(locale.LC_ALL, ('ru_RU', 'UTF-8')))
print([i for i in calendar.month_name])

# - month_abbr - список аббревиатур названий месяцев в текущей локали:
print(locale.setlocale(locale.LC_ALL, ('en_US', 'UTF-8')))
print([i for i in calendar.month_abbr])
print(locale.setlocale(locale.LC_ALL, ('ru_RU', 'UTF-8')))
print([i for i in calendar.month_abbr])


# 10.6. Измерение времени выполнения фрагментов кода
print('10.6. Измерение времени выполнения фрагментов кода')
# Модуль timeit предоставляет инструменты для измерения времени выполнения фрагментов кода программы с целью ее
# оптимизации.
# Измерения производятся с помощью класса Timer, который сначала следует импортировать из модуля timeit посредством
# инструкции:
# Конструктор класса имеет следующий формат:
# Timer([stmt='pass'][, setup='pass'])
# В параметре stmt указывается код (в виде строки), время выполнения которого нужно измерить. Параметр setup задает
# код, выполняемый перед измерением времени выполнения кода, из параметра stmt (например, код из параметра setup может
# подключать необходимые модули).
# Получить время выполнения можно с помощью метода timeit([number=1000000]). В параметре number указывается количество
# повторений. Для примера просуммируем числа от 1 до 10000 тремя способами и выведем время выполнения каждого способа
# test_00052.py.
# Примерный результат выполнения (зависит от мощности компьютера):
# while: 2.6792108130002816
# for: 2.1719006940002146
# sum: 1.0123976709992348
# Сразу видно, что цикл перебора последовательности работает почти в два раза быстрее цикла с условием, а функция sum()
# в нашем случае вовсе вне конкуренции.
# Метод repeat([repeat=5][, number=1000000]) вызывает метод timeit() указанное в параметре repeat количество раз и
# возвращает список значений (до Python 3.7 этот параметр имел значение по умолчанию 3). Аргумент number передается в
# качестве параметра методу timeit().
# Для примера создадим список со строковыми представлениями чисел от 1 до 10000: в первом случае для создания списка
# используем цикл перебора последовательности и метод append(), а во втором - генератор списков test_00053.py.
# Примерный результат выполнения:
# append: [1.0052308879994598, 0.9876182150001114, 0.9906691819996922]
# генератор: [0.978266340999653, 0.9711916360001851, 0.9749160069995924]
# Как видно из результата, генераторы списков работают быстрее.
