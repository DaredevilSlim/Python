#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import calendar  # Подключаем модуля calendar
import datetime  # Подключаем модуля datetime
import locale  # Подключаем модуля locale
import time  # Подключаем модуля time

# ГЛАВА 10
# Работа с датой и временем
# Python предоставляет средства для работы со значениями даты и времени, а также комбинациями даты и времени (временными
# отметками). Кроме того, он содержит инструменты для вывода календаря в виде текста или в формате HTML и измерения
# времени выполнения определенных фрагментов программы для целей отладки.

# 10.1. Получение текущих даты и времени
print('10.1. Получение текущих даты и времени')
# - time() - возвращает количество секунд, прошедшее с начала эпохи (обычно с 1 января 1970 г.), в виде вещественного
# числа:
print(time.time())  # Получаем количество секунд

# - gmtime([<Количество секунд>]) - возвращает универсальное время (UTC) в виде объекта struct_time. Если параметр не
# указан, возвращается текущее время. Если параметр указан, время будет соответствующим заданному количеству секунд,
# прошедших с начала эпохи. Примеры:
print(time.gmtime(0))  # Начало эпохи
print(time.gmtime())  # Текущая дата и время
print(time.gmtime(1690476586.0))  # Дата 27.07.2023
# Получить значение конкретного атрибута можно, указав его имя или индекс внутри объекта:
d = time.gmtime()
print(d.tm_year, d[0])
print(tuple(d))  # Преобразование в кортеж

# - localtime([<Количество секунд>]) - возвращает местное время в виде объекта struct_time. Если параметр не указан,
# возвращается текущее время. Если параметр указан, время будет соответствующим заданному количеству секунд, прошедших с
# начала эпохи. Примеры:
print(time.localtime())  # Текущая дата и время
print(time.localtime(1690476586.0))  # Дата 27.07.2023

# - mktime(<Объект struct_time>) - возвращает количество секунд, прошедших с начала эпохи, в виде вещественного числа.
# В качестве параметра указывается объект struct_time или кортеж из девяти элементов. Если указанная дата некорректна,
# возбуждается исключение OverflowError. Примеры:
d = time.localtime(1690476586.0)
print(time.mktime(d))
print(tuple(time.localtime(1690476586.0)))
print(time.mktime((2023, 7, 27, 19, 49, 46, 3, 208, 1)))
print(time.mktime((1940, 0, 31, 5, 23, 43, 5, 31, 0)))
# Объект struct_time, возвращаемый функциями gmtime() и localtime(), содержит следующие атрибуты (указаны тройки вида
# «имя атрибута - индекс - описание»):
# tm_year - О - год;
# tm_mon - 1 - месяц (число от 1 до 12);
# tm_mday - 2 - день месяца (число от 1 до 31);
# tm_hour - 3 - час (число от 0 до 23);
# tm_min - 4 - минуты (число от 0 до 59);
# tm_sec - 5 - секунды (число от 0 до 59);
# tm_wday - б - день недели (число от 0 для понедельника до 6 для воскресенья);
# tm_yday - 7 - количество дней, прошедшее с начала года (число от 1 до 366);
# tm_isdst - 8 - флаг коррекции летнего времени (значения 0, 1 или -1).
# Выведем текущие дату и время таким образом, чтобы день недели и месяц были написаны по-русски test_00050.py.

# 10.2. Форматирование даты и времени
print('10.2. Форматирование даты и времени')
# Форматирование даты и времени выполняют следующие функции из модуля time:
# - strftime(<Строка формата>[, <Объект struct_time>]) - возвращает строковое представление даты и времени в
# соответствии с заданной строкой формата. Если второй параметр не указан, будут выведены текущие дата и время. Если во
# втором параметре указан объект struct_time или кортеж из девяти элементов, дата будет соответствовать указанному
# значению. Функция зависит от настройки локали. Примеры:
time.strftime('%d.%m.%Y')  # Форматирование даты
print(time.strftime('%H:%M:%S'))  # Форматирование времени
print(time.strftime('%d.%m.%Y', time.localtime(1691990120.1)))

# - strptime(<Строка с датой>[, <Строка формата>]) - разбирает указанную строку с датой и временем в соответствии с
# заданной строкой формата. Возвращает объект struct_time. Если строка не соответствует формату, возбуждается исключение
# ValueError. Если строка формата не указана, используется строка '%а %Ь %d %Н: %М: %S %Y'. Функция учитывает текущую
# локаль
print(time.strptime('Mon Aug 14 08:20:50 2023'))
print(time.strptime('14.08.2023', '%d.%m.%Y'))
# print(time.strptime('14-08-2023', '%d.%m.%Y'))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 74, in <module>
#     print(time.strptime('14-08-2023', '%d.%m.%Y'))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 562, in _strptime_time
#     tt = _strptime(data_string, format)[0]
#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 349, in _strptime
#     raise ValueError("time data %r does not match format %r" %
# ValueError: time data '14-08-2023' does not match format '%d.%m.%Y'

# - asctime([<Объект struct_time>]) - возвращает строку формата '%а %Ь %d %H:%M:%S %Y'. Если параметр не указан, будут
# выведены текущие дата и время. Если в параметре указан объект struct_time или кортеж из девяти элементов, то дата
# будет соответствовать указанному значению.
print(time.asctime())  # Текущая дата
print(time.asctime(time.localtime(1601990120.0)))  # Дата в прошлом

# - ctime([<Количество секунд>]) - аналогична asctime(), но в качестве параметра принимает количество секунд, прошедших
# с начала эпохи.
print(time.ctime())  # Текущая дата
print(time.ctime(1691990120.0))  # Дата в прошлом
# В параметре <Строка формата> в функциях strftime() и strptime() могут быть использованы следующие комбинации
# специальных символов:
# %y - год из двух цифр (от '00' до '99');
# %Y - год из четырех цифр (например, '2011 ');
# %m - номер месяца с предваряющим нулем (от '01' до '12');
# %b - аббревиатура месяца в зависимости от настроек локали (например, 'янв' для января);
# %В - название месяца в зависимости от настроек локали (например, 'Январь');
# %d - номер дня в месяце с предваряющим нулем (от '01' до '31');
# %j - день с начала года (от '001' до '366');
# %U - номер недели в году (от '00' до '53'). Неделя начинается с воскресенья. Все дни с начала года до первого
# воскресенья относятся к неделе с номером 0;
# %W - номер недели в году (от '00' до '53'). Неделя начинается с понедельника. Все дни с начала года до первого
# понедельника относятся к неделе с номером 0;
# %w - номер дня недели ('0' - для воскресенья, '6' - для субботы);
# %a - аббревиатура дня недели в зависимости от настроек локали (например, 'Пн' для понедельника);
# %A - название дня недели в зависимости от настроек локали (например, 'понедельник');
# %Н - часы в 24-часовом формате (от '00' до '23');
# %I - часы в 12-часовом формате (от '01' до '12');
# %M - минуты (от '00' до '59');
# %S - секунды (от '00' до '59', изредка до '61 ');
# %p - эквивалент значениям АМ и РМ в текущей локали;
# %c - представление даты и времени в текущей локали;
# %x - представление даты в текущей локали;
# %X - представление времени в текущей локали.
locale.setlocale(locale.LC_ALL, '')
print(time.strftime('%x'))  # Представление даты
print(time.strftime('%X'))  # Представление времени
print(time.strftime('%c'))  # Представление даты и времени
# %Z - название часового пояса или пустая строка (например, 'Московское время', 'UTC');
# %% - символ'%'.
# Вывод текущей даты и времени с помощью функции strftime() (test_00051.py)

# 10.3. Приостановка выполнения программы
print('10.3. Приостановка выполнения программы')
# Функция sleep(<Время в секундах>) из модуля time приостанавливает выполнение программы на указанное время. В качестве
# параметра можно указать целое или вещественное число. Пример:
# time.sleep(5)  # 'Засыпаем' на 5 секунд

# 10.4. Значения даты и времени
print('10.4. Значения даты и времени')
# Модуль datetime предоставляет инструменты для работы со значениями даты и времени:
# выполнения арифметических операций, сравнения, вывода в различных форматах и др.
# Предварительно необходимо подключить модуль с помощью инструкции:
# import datetime

# 10.4.1 Временные промежутки
print('10.4.1 Временные промежутки')
# Временной промежуток - это величина разницы между какими-либо временными отметками (т. е. значениями времени и даты).
# Класс timedelta из модуля datetime позволяет выполнять операции над временными промежутками: складывать, вычитать,
# сравнивать и др. Конструктор класса имеет следующий формат:
# timedelta([days][, seconds][, microseconds][, milliseconds][, minutes][, hours][, weeks])
# Все параметры не являются обязательными и по умолчанию имеют значение 0. Их можно записывать как позиционные или как
# именованные. Первые три параметра считаются основными:
# - days - дни (диапазон -999999999 <= days <= 999999999);
# - seconds - секунды (диапазон 0 <= seconds < 3600*24);
# - microseconds - микросекунды (диапазон О <= microseconds < 1000000).
# Примеры:
print(datetime.timedelta(3))
print(datetime.timedelta(0, 2, 10000))
print(datetime.timedelta(days=1, seconds=7200))

# Все остальные параметры автоматически преобразуются в следующие значения:
# - milliseconds - миллисекунды (одна миллисекунда преобразуется в 1000 микросекунд):
print(datetime.timedelta(milliseconds=1))
# - minutes - минуты (одна минута преобразуется в 60 секунд):
print(datetime.timedelta(minutes=1))
# - hours - часы (один час преобразуется в 3600 секунд):
print(datetime.timedelta(hours=1))
# - weeks - недели (одна неделя преобразуется в 7 дней):
print(datetime.timedelta(weeks=1))

# Получить результат можно с помощью следующих атрибутов:
# - days - дни;
# - seconds - секунды;
# - microseconds - микросекунды.
d = datetime.timedelta(hours=1, days=2, milliseconds=1)
print(d)
print(d.days, d.seconds, d.microseconds)
# Получить результат в секундах позволяет метод total_seconds():
d = datetime.timedelta(minutes=1)
print(d.total_seconds())
# Над временными промежутками можно производить арифметические операции '+', '-', '/', '//', '%' и '*', использовать
# унарные операторы '+' и '-', а также получать абсолютное значение с помощью функции abs(), вычислять частное и остаток
# от деления нацело функцией divmod():
d1 = datetime.timedelta(days=2)
d2 = datetime.timedelta(days=7)
print(d1 + d2, d2 - d1)  # Сложение и вычитание
print(d2 / d1)  # Деление
print(d1 / 2, d2 / 2.5)  # Деление
print(d2 // d1)  # Деление
print(d1 // 2, d2 // 2)  # Деление
print(d2 % d1)  # Остаток
print(d1 * 2, d2 * 2)  # Умножение
print(2 * d1, 2 * d2)  # Умножение
d3 = -d1
print(d3, abs(d3))
print(divmod(d2, d1))
# Кроме того, можно использовать операторы сравнения '=', '!=', '<', '<=', '>' и '>='.
d1 = datetime.timedelta(days=2)
d2 = datetime.timedelta(days=7)
d3 = datetime.timedelta(weeks=1)
print(d1 == d2, d2 == d3)  # Проверка на равенство
print(d1 != d2, d2 != d3)  # Проверка на неравенство
print(d1 < d2, d2 <= d3)  # Меньше, меньше или равно
print(d1 > d2, d2 >= d3)  # Больше, больше или равно
# Также можно получать строковое представление объекта timedelta с помощью функций str() и repr():
d = datetime.timedelta(hours=25, minutes=5, seconds=27)
print(str(d), repr(d))
# Класс timedelta поддерживают следующие атрибуты:
# min - минимальное значение, которое может иметь объект timedelta;
# max - максимальное значение, которое может иметь объект timedelta;
# resolution - минимальное возможное различие между значениями timedelta.
# Вывод значения этих атрибутов:
print(datetime.timedelta.min)
print(datetime.timedelta.max)
print(datetime.timedelta.resolution)

# 10.4.2 Значения даты
print('10.4.2 Значения даты')
# Класс date из модуля datetime позволяет выполнять операции над датами. Конструктор класса имеет следующий формат:
# date(<Год>, <Месяц>, <День>)
# В параметрах указываются числа:
# - <Год> - в диапазоне между значениями констант MINYEAR и МАХУЕАR класса datetime (о нем речь пойдет позже). Выведем
# значения этих констант:
print(datetime.MINYEAR, datetime.MAXYEAR)
# - <Месяц> - от 1 до 12 включительно;
# - <День> - от 1 до количества дней в месяце.
# Если значения выходят за диапазон, возбуждается исключение ValueError. Примеры:
print(datetime.date(2023, 8, 14))
# print(datetime.date(2023, 14, 8))  # Неправильное значение для месяца
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 232, in <module>
#     print(datetime.date(2023, 14, 8))  # Неправильное значение для месяца
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^
# ValueError: month must be in 1..12

# Для создания даты также можно воспользоваться следующими методами класса date:
# - today() - возвращает текущую дату:
print(datetime.date.today())  # Получение текущей даты
# - fromtimestamp(<Количество секунд>) - возвращает дату, которая соответствует заданному количеству секунд, прошедших
# с начала эпохи:
print(datetime.date.fromtimestamp(time.time()))  # Текущая дата
print(datetime.date.fromtimestamp(1691996144.5))  # Дата 2023-08-14

# - fromordinal(<Количество дней с 1-го года>) - возвращает дату, которая соответствует заданному количеству дней,
# прошедших с первого года. В качестве параметра указывается число от 1 до datetime.date.max.toordinal().
print(datetime.date.max.toordinal())
print(datetime.date.fromordinal(3652059))
print(datetime.date.fromordinal(1))

# - fromisoformat(<Строка с датой>) (начиная с Python 3.7) - возвращает дату, созданную в результате преобразования
# заданной строки, которая указывается в формате <ГГГГ>-<ММ>-<ДД>:
print(datetime.date.fromisoformat('2021-12-17'))

# - fromisocalendar() (начиная с Python 3.8) - возвращает дату, созданную на основе заданных параметров. Формат метода:
# fromisocalendar(<Гoд>, <Порядковый номер недели в году>, <Порядковый номер дня в неделе>)
# Пример:
print(datetime.date.fromisocalendar(2023, 2, 4))

# Получить результат можно с помощью следующих атрибутов:
# year - год (число в диапазоне от MINYEAR до МАХУЕАR);
# month - месяц (число от 1 до 12);
# day - день (число от 1 до количества дней в месяце).
d = datetime.date.today()
print(d.year, d.month, d.day)  # Текущая дата 2023 8 14

# Над экземплярами класса date можно производить следующие операции:
# date2 = date1 + timedelta - прибавляет к дате date1 временной промежуток timedelta. Значения атрибутов seconds и
# microseconds временного промежутка игнорируются;
# date2 = date1 - timedelta - вычитает из даты date1 временной промежуток timedelta. Значения атрибутов seconds и
# microseconds временного промежутка игнорируются;
# timedelta = date1 - date2 - возвращает разницу между датами date1 и date2 в виде временного промежутка. Атрибуты
# seconds и microseconds последнего будут иметь значения О.
# Также можно сравнивать две даты с помощью операторов сравнения:
d1 = datetime.date(2023, 8, 14)
d2 = datetime.date(2022, 2, 24)
t = datetime.timedelta(days=10)
print(d1 + t, d1 - t)  # Прибавляем и вычитаем 10 дней
print(d1 - d2)  # Разница между датами
print(d1 < d2, d1 > d2, d1 <= d2, d1 >= d2)
print(d1 == d2, d1 != d2)
# Можно получить строковое представление даты с помощью функций str() и repr():
d = datetime.date(2023, 8, 14)
print(str(d), repr(d))

# Класс date поддерживает следующие методы:
# - replace([year][, month][, day]) - возвращает текущую дату с обновленными значениями года (параметр year),
# месяца (month) и (или) числа (day). Параметры можно указывать как позиционные или как именованные. Примеры:
d = datetime.date(2023, 8, 14)
print(d)
print(d.replace(2023, 8))  # Заменяем год и месяц
print(d.replace(year=2023, month=8, day=14))
print(d.replace(day=14))  # Заменяем только день

# - strftime(<Строка формата>) - возвращает текущую дату в виде строки, отформатированной согласно заданной строке
# формата. В строке формата можно задавать комбинации специальных символов, которые используются в функции strftime() из
# модуля time. Пример:
d = datetime.date(2023, 8, 14)
print(d.strftime('%d.%m.%Y'))

# - isoformat() -возвращает текущую дату в виде строки формата <ГГГГ>-<ММ>-<ДД>:
d = datetime.date(2023, 8, 14)
print(d.isoformat())

# - ctime() - возвращает текущую дату в виде строки формата '%a %b %d %H:%M:%S %Y':
d = datetime.date(2023, 8, 14)
print(d.ctime())

# - timetuple() - возвращает текущую дату в виде объекта struct_time:
d = datetime.date(2023, 8, 14)
print(d.timetuple())

# - toordinal() - возвращает текущую дату в виде количества дней, прошедших с 1-го года:
d = datetime.date(2023, 8, 14)
print(d.toordinal())

# - weekday() - возвращает порядковый номер дня в неделе (О - для понедельника, 6 - для воскресенья):
d = datetime.date(2023, 8, 14)
print(d.weekday())  # 0 - это понедельник

# - isoweekday() - возвращает порядковый номер дня в неделе (1 - для понедельника, 7 - для воскресенья):
d = datetime.date(2023, 8, 14)
print(d.isoweekday())  # 1 - это понедельник

# isocalendar() - возвращает последовательность из трех элементов: года, номера недели в году и порядкового номера дня
# в неделе:
d = datetime.date(2023, 8, 14)
print(d.isocalendar())

# Наконец, имеется поддержка следующих атрибутов класса:
# min - минимально возможное значение даты;
# max - максимально возможное значение даты;
# resolution - минимальное возможное различие между значениями даты.
# Выведем значения этих атрибутов:
print(datetime.date.min)
print(datetime.date.max)
print(datetime.date.resolution)

# 10.4.3 Значения времени
print('10.4.3 Значения времени')
# Класс time из модуля datetime позволяет выполнять операции над значениями времени. Конструктор класса имеет следующий
# формат:
# time((hour][, minute][, second][, microsecond][, tzinfo], [fold])
# Все параметры не являются обязательными. Их можно указывать как позиционные или как именованные, за исключением
# параметра fold, который можно указать только как именованный. В параметрах можно задать следующий диапазон значений:
# - hour - часы (число от 0 до 23);
# - minute - минуты (число от 0 до 59);
# - second - секунды (число от 0 до 59);
# - microsecond - микросекунды (число от 0 до 999999);
# - tzinfo - зона (экземпляр класса tzinfo или значение None).
# - fold - порядковый номер отметки времени. Значение 0 (используется по умолчанию) обозначает первую отметку,
# значение 1 - вторую. Предусмотрен для тех случаев, когда в рассматриваемой временной зоне практикуется перевод часов с
# зимнего на летнее время и обратно, в результате чего часы могут дважды в сутки показывать одинаковое время.
# Если значения выходят за диапазон, возбуждается исключение ValueError. Примеры:
print(datetime.time(23, 12, 38, 375000))
print(datetime.time(hour=23, second=38, minute=12))
# print(datetime.time(25, 12, 38, 375000))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 360, in <module>
#     print(datetime.time(25, 12, 38, 375000))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# ValueError: hour must be in 0..23
# Создать значение времени также можно с помощью метода fromisoformat(<Строка с временем>) класса time (этот метод
# поддерживается, начиная с Python 3.7). Строка с временем должна указываться в формате ISO 8601. Пример:
print(datetime.time.fromisoformat('13:49:24.186500'))
# Получить результат можно с помощью следующих атрибутов:
# hour - часы (число от 0 до 23);
# minute - минуты (число от 0 до 59);
# second - секунды (число от 0 до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo - зона (экземпляр класса tzinfo или значение None).
# fold - порядковый номер отметки времени (число 0 или 1).
t = datetime.time(23, 12, 38, 375000)
print(t.hour, t.minute, t.second, t.microsecond)
# Над значениями времени нельзя выполнять арифметические операции. Можно только производить сравнения, например:
t1 = datetime.time(23, 12, 38, 375000)
t2 = datetime.time(12, 28, 17)
print(t1 < t2, t1 > t2, t1 <= t2, t1 >= t2)
print(t1 == t2, t1 != t2)
# Можно получить строковое представление времени с помощью функций str() и repr():
t = datetime.time(23, 12, 38, 375000)
print(str(t), repr(t))

# Класс time поддерживает следующие методы:
# - replace() - возвращает текущее время с обновленными значениями, указанными в параметрах. Формат метода:
# replace([hour][, minute][, second][, microsecond][, tzinfo][, fold])
# Параметры можно указывать как позиционные или как именованные. Примеры:
t = datetime.time(23, 12, 38, 375000)
print(t.replace(10, 52))  # Заменяем часы и минуты
print(t.replace(second=21))  # Заменяем только секунды

# - isoformat([timespec="auto"]) - возвращает строку с текущим временем в формате ISO 8601. В параметре timespec можно
# указать состав выдаваемого времени, задав одно из следующих значений:
#  - 'auto' - часы, минуты, секунды и микросекунды, если количество последних не равно 0 - в противном случае
# микросекунды не включаются в состав времени;
#  - 'hours' - часы;
#  - 'minutes' - часы и минуты;
#  - 'seconds' - часы, минуты и секунды;
#  - 'milliseconds' - часы, минуты, секунды и миллисекунды (вычисляются путем округления микросекунд до тысячных);
#  - 'microseconds' - часы, минуты, секунды и микросекунды (выводятся всегда, даже если их количество равно 0).
# Примеры:
t = datetime.time(23, 12, 38, 375000)
print(t.isoformat())
print(t.isoformat('minutes'))

# - strftime(<Строка формата>) - возвращает текущее время, отформатированное согласно заданной строке формата. В строке
# формата можно указывать комбинации специальных символов, которые используются в функции strftime () из модуля time.
# Пример:
t = datetime.time(23, 12, 38, 375000)
print(t.strftime('%H:%M:%S'))

# Дополнительно класс time поддерживает такие атрибуты:
# min - минимально возможное значение времени;
# max - максимально возможное значение времени;
# resolution - минимальное возможное различие между значениями времени.
# Значения этих атрибутов:
print(datetime.time.min)
print(datetime.time.max)
print(datetime.time.resolution)
# Класс time поддерживает также методы dst(), utcoffset() и tzname(). За подробной информацией по этим методам, а также
# по абстрактному классу tzinfo обращайтесь к документации по модулю datetime.

# 10.4.4 Временные отметки
print('10.4.4 Временные отметки')
# Класс datetime из модуля datetime позволяет выполнять операции над временными отметками (комбинацией даты и времени).
# Конструктор класса имеет следующий формат:
# datetime(<Гoд>, <Месяц>, <День>[, hour][, minute][, second][, microsecond][, tzinfo][, fold])
# Первые три параметра являются обязательными. Остальные параметры можно указывать как позиционные или как именованные,
# кроме fold, который задается только как именованный. В параметрах можно указать следующие значения:
# <Год> - число, расположенное в диапазоне между значениями из констант MINYEAR(1) и МАХУЕАR(9999);
# <Месяц> - число от 1 до 12 включительно;
# <День> - число от 1 до количества дней в месяце;
# hour - часы (число от 0 до 23);
# minute - минуты (число от 0 до 59);
# second - секунды (число от 0 до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo - зона (экземпляр класса tzinfo или значение None).
# fold - порядковый номер отметки времени. Значение 0 (используется по умолчанию) обозначает первую отметку, значение 1
# - вторую. Предусмотрен для тех случаев, когда в рассматриваемой временной зоне практикуется перевод часов с зимнего на
# летнее время и обратно, в результате чего часы могут дважды в сутки показывать одинаковое время.
# Если значения выходят за диапазон, возбуждается исключение ValueError. Примеры:
print(datetime.datetime(2023, 8, 14))
print(datetime.datetime(2023, 8, 14, hour=21, minute=55))
# print(datetime.datetime(2023, 32, 14))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 448, in <module>
#     print(datetime.datetime(2023, 32, 14))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# ValueError: month must be in 1..12

# Для создания временной отметки также можно воспользоваться следующими методами:
# - today() - возвращает текущие дату и время:
print(datetime.datetime.today())

# - now([<Зона>]) - возвращает текущие дату и время. Если параметр не задан, то метод аналогичен методу today(). Пример:
print(datetime.datetime.now())

# - utcnow() - возвращает текущее универсальное время (UTC):
print(datetime.datetime.utcnow())

# - fromtimestamp(<Количество секунд>[, <Временная зона>]) - возвращает временную отметку, которая соответствует
# заданному количеству секунд, прошедших с начала эпохи:
print(datetime.datetime.fromtimestamp(time.time()))
print(datetime.datetime.fromtimestamp(1692039037.0))

# - utcfromtimestamp(<Количество секунд>) - возвращает временную отметку, которая соответствует заданному количеству
# секунд, прошедших с начала эпохи, в универсальном времени (UTC).
print(datetime.datetime.utcfromtimestamp(time.time()))
print(datetime.datetime.utcfromtimestamp(1692039037.0))

# - fromordinal(<Количество дней с 1-го года>) - возвращает дату, которая соответствует заданному количеству дней,
# прошедших с 1-го года. В качестве параметра указывается число от 1 до datetime.datetime.max.toordinal(). Примеры:
print(datetime.datetime.fromordinal(3652059))
print(datetime.datetime.fromordinal(1))

# - fromisoformat(<Строка с датой и временем>) (начиная с Python 3.7)- возвращает временную отметку, созданную в
# результате преобразования заданной строки, которая указывается в формате ISO 8601:
print(datetime.datetime.fromisoformat('2023-08-14T22:40:53.190301'))

# - fromisocalendar() (начиная с Python 3.8)- возвращает временную отметку, созданную на основе заданных параметров.
# Формат метода:
# fromisocalendar(<Гoд>, <Порядковый номер недели в году>, <Порядковый номер дня в неделе>)
# Пример:
print(datetime.datetime.fromisocalendar(2022, 2, 4))

# - combine(<Дата>, <Время>[, <Временная зона>]) - возвращает временную отметку, созданную на основе переданных ему даты
# и времени:
d = datetime.date(2023, 8, 14)  # Дата
t = datetime.time(22, 46, 22)  # Время
print(datetime.datetime.combine(d, t))

# - strptime(<Строка с датой>, <Строка формата>) - возвращает временную отметку, созданную на основе разбора заданной
# строки с датой в соответствии с указанной строкой формата. Если строка с датой не соответствует формату, возбуждается
# искшочение ValueError. Метод учитывает текущую локаль. Примеры:
print(datetime.datetime.strptime('14.08.2023', '%d.%m.%Y'))
# print(datetime.datetime.strptime('14.08.2023', '%d-%m-%Y'))
# Traceback (most recent call last):
#   File "/Chapter_10.py", line 500, in <module>
#     print(datetime.datetime.strptime('14.08.2023', '%d-%m-%Y'))
#           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 568, in _strptime_datetime
#     tt, fraction, gmtoff_fraction = _strptime(data_string, format)
#                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#   File "/usr/src/Python-3.11.4/Lib/_strptime.py", line 349, in _strptime
#     raise ValueError("time data %r does not match format %r" %
# ValueError: time data '14.08.2023' does not match format '%d-%m-%Y'
# Получить результат можно с помощью следующих атрибутов:
# year - год (число в диапазоне от MINYEAR до МАХУЕАR);
# month - месяц (число от 1 до 12);
# dау - день (число от 1 до количества дней в месяце );
# hour - часы (число от 0 до 23);
# minute - минуты (число от 0 до 59);
# second - секунды (число от о до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo - временная зона (объект класса tzinfo или значение None).
# fold - порядковый номер отметки времени (число 0 или 1).
# Примеры:
d = datetime.datetime(2023, 8, 14, 22, 52, 22)
print(d.year, d.month, d.day)
print(d.hour, d.minute, d.second, d.microsecond)

# Над временными отметками можно производить следующие операции:
# - datetime2 = datetime1 + timedelta - сложение временной отметки datetime1 и временного промежутка timedelta;
# - datetime2 = datetime1 - timedelta - вычитание из временной отметки datetime1 временного промежутка timedelta;
# - timedelta = datetime1 - datetime2 - возвращает разницу между временными отметками datetime1 и datetime2 в виде
# временного промежутка.
# Также можно сравнивать две даты с помощью операторов сравнения. Примеры:
d1 = datetime.datetime(2023, 8, 14, 22, 57, 22)
d2 = datetime.datetime(2022, 2, 24, 4, 31, 4)
t = datetime.timedelta(days=10, minutes=10)
print(d1 + t)  # Прибавляем 10 дней и 10 минут
print(d1 - t)  # Вычитаем 10 дней и 10 минут
print(d1 - d2)  # Разница между датами
print(d1 < d2, d1 > d2, d1 <= d2, d1 >= d2)
print(d1 == d2, d1 != d2)
# Можно получить строковое представление временной отметки с помощью функций str() и repr():
d = datetime.datetime(2023, 8, 14, 23, 39, 21, 998076)
print(str(d), repr(d))

# Класс datetime поддерживают следующие методы:
# - date() - возвращает текущую дату в виде объекта date:
d = datetime.datetime(2023, 8, 14, 23, 39, 21)
print(d.date())

# - time() - возвращает текущее время в виде объекта time без временной зоны:
d = datetime.datetime(2023, 8, 14, 23, 39, 21)
print(d.time())

# - timetz() - возвращает текущее время в виде объекта time с временной зоной;

# - timestamp() - возвращает количество секунд, прошедшее с начала эпохи (обычно с 1 января 1970 г.), в виде
# вещественного числа:
d = datetime.datetime(2023, 8, 14, 23, 39, 21)
print(d.timestamp())

# - replace() - возвращает текущую временную отметку с обновленными значениями, взятыми из параметров. Формат метода:
# replace([year][, month][, day][, hour][, minute][, second][, microsecond][, tzinfo][, fold])
# Параметры можно указывать как позиционные или как именованные, за исключением fold, который указывается только как
# именованный. Примеры:
d = datetime.datetime(2022, 8, 15, 8, 39, 21)
print(d.replace(2023, 8))
print(d.replace(hour=12, minute=10, microsecond=38))

# - timetuple() - возвращает текущие дату и время в виде объекта struct_time:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.timetuple())

# - utctimetuple() - возвращает текущие дату и время в виде объекта struct_time в универсальном времени (UTC):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.utctimetuple())

# - toordinal() - возвращает количество дней, прошедшее с 1-го года:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.toordinal())

# - weekday() - возвращает порядковый номер дня в неделе (0 - для понедельника, 6 - для воскресенья):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.weekday())  # 1 - это вторник

# - isoweekday() - возвращает порядковый номер дня в неделе (1- для понедельника, 7 - для воскресенья):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.isoweekday())  # 2 - это вторник

# - isocalendar() - возвращает кортеж из трех элементов (год, номер недели в году и порядковый номер дня в неделе):
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
isoc = d.isocalendar()
print(isoc[0], isoc[1], isoc[2])

# - isoformat([<Разделитель>][, ] [timespec="auto"]) - возвращает дату в формате ISO 8601. Если разделитель не указан,
# используется буква т. В параметре timespec можно указать состав выдаваемого времени, задав одно из следующих значений:
#  - 'auto' - часы, минуты, секунды и микросекунды, если количество последних не равно О - в противном случае
# микросекунды не включаются в состав времени;
#  - 'hours' - часы;
#  - 'minutes' - часы и минуты;
#  - 'seconds' - часы, минуты и секунды;
#  - 'milliseconds' - часы, минуты, секунды и миллисекунды (вычисляются путем округления микросекунд до тысячных);
#  - 'microseconds' - часы, минуты, секунды и микросекунды (выводятся всегда, даже если их количество равно О).
# Примеры:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.isoformat())  # Разделитель не указан
print(d.isoformat())  # Пробел в качестве разделителя

# - ctime() - возвращает текущие дату и время в виде строки формата "%а %b %d %H:%M:%S %y":
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.ctime())

# - strftime(<Строка формата>) - возвращает текущие дату и время в виде строки, отформатированной согласно заданной
# строке формата. В строке формата можно указывать комбинации специальных символов, которые используются в функции
# strftime() из модуля time. Пример:
d = datetime.datetime(2023, 8, 15, 8, 59, 21)
print(d.strftime('%d.%m.%Y %H:%M:%S'))

# Класс datetime поддерживает также следующие атрибуты:
# min - минимально возможные значения даты и времени;
# max - максимально возможные значения даты и времени;
# resolution - минимальное возможное различие между значениями даты и времени.
# Значения этих атрибутов:
print(datetime.datetime.min)
print(datetime.datetime.max)
print(datetime.datetime.resolution)
# Примечание - Класс datetime также поддерживает методы astimezone(), dst(), utcoffset() и tzname(). За подробной
# информацией по этим методам, а также по абстрактному классу tzinfo обращайтесь к документации по модулю datetime.

# 10.5. Вывод календаря
print('10.5. Вывод календаря')
# Модуль calendar формирует календарь в виде простого текста или НТМL-кода. Прежде чем использовать модуль, необходимо
# подключить его с помощью инструкции:
# import calendar
# Класс Calendar, содержащийся в этом модуле, является базовым, от которого наследуют остальные классы календарей,
# описываемые далее. Формат конструктора:
# Calendar([<Первый день недели>])
# В параметре указывается число от О (для понедельника) до 6 (для воскресенья). Если параметр не указан, его значение
# принимается равным О. Вместо чисел можно использовать значения переменных: MONDAY, TUESDAY, WEDNESDAY, THURSDAY,
# FRIDAY, SATURDAY или SUNDAY, содержащихся в модуле calendar.
# В качестве примера получим двумерный список всех дней в январе 2022 года, распределенных по дням недели:
c = calendar.Calendar()
print(c.monthdayscalendar(2023, 8))
# В дальнейшем указать другой первый день недели у объекта календаря позволяет метод setfirstweekday(<Первый день
# недели>). В качестве примера получим календарь на февраль 2022 года, где первым днем недели является воскресенье:
c.setfirstweekday(calendar.SUNDAY)
print(c.monthdayscalendar(2022, 2))

# 10.5.1. Вывод календаря в текстовом виде
print('10.5.1. Вывод календаря в текстовом виде')
# Для формирования календаря в текстовом виде служат два класса из модуля calendar:
# - TextCalendar - выводит названия месяцев и дней недели по-английски. Формат конструктора:
# TextCalendar([<Первый день недели>])
# Параметр указывается в таком же формате, что и у класса Calendar (см. разд. 10.5). Выведем календарь на весь 2022 год:
c = calendar.TextCalendar()
print(c.formatyear(2023))
# Результатом станет большая строка, содержащая календарь в виде отформатированного текста;

# - LocaleTextCalendar - выводит названия месяцев и дней недели в соответствии с указанной локалью. Формат конструктора:
# LocaleTextCalendar([<Первый день недели>[, <Название локали>]])
# Выведем календарь на весь 2022 год на русском языке:
c = calendar.LocaleTextCalendar(0, ('ru_RU', 'UTF-8'))
print(c.formatyear(2023))
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

# 195
