#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import random

# ГЛАВА 11
# Функции
# Функция - это языковая конструкция, выполняющая над переданными ей значениями (параметрами) какое-либо сложное
# действие. Так, функция sqrt() вычисляет квадратный корень, функция print() выводит заданные значения в консоль, а
# функция strftime() форматирует указанные дату и время сообразно заданному формату. Функция может принимать
# произвольное количество параметров, в том числе и ни одного. Также функция может возвращать результат выполненного ею
# действия.
# Язык Python содержит огромное количество функций, которые реализованы в нем самом и называются встроенными. Однако мы
# можем добавить к ним свои собственные, пользовательские, функции. Которым и посвящена эта глава.


# 11.1. Определение и вызов функции
print('11.1. Определение и вызов функции')


# Инструкция создания, или определения, пользовательской функции записывается в следующем формате:
# def <Имя функции>([<Имена параметров через запятую>]): <Тело функции>
# Имя функции должно быть уникальным, состоять из латинских букв, цифр и знаков подчеркивания и не начинаться с цифры.
# В качестве имени нельзя использовать ключевые слова Python, кроме того, следует избегать совпадений с названиями
# встроенных идентификаторов. Регистр символов в имени функции также имеет значение.
# Имена параметров должны удовлетворять тем же требованиям, что и имена переменных (см. разд. 2.1). Если функция не
# принимает параметров, следует указать пустые круглые скобки.
# Тело функции - это блок, реализующий функциональность определяемой функции. Не забываем, что инструкции, входящие в
# блок, должны иметь одинаковые отступы слева, выполненные пробелами.
# При вызове функции создаются переменные, имеющие те же имена, что и записанные в определении функции параметры. Эти
# переменные будут хранить реальные значения параметров, заданные в выражении вызова функции, станут доступны лишь в
# теле функции (локальные переменные), а после завершения выполнения функции - удалены из памяти.
# Пример определения функции, принимающей два параметра, делящей их друг на друга и выводящей результат в консоль:
def division(a, b):
    res = a / b
    print(str(a), ' / ', str(b), ' = ', str(res))


# Если тело функции состоит из одного выражения, его можно набрать в одной строке с языковой конструкцией def. Пример
# определения функции, не принимающей параметров и выводящей в консоль случайное число:
def rnd(): print(random.random())


# Для возврата результата из функции в ее теле записывается инструкция такого формата:
# return <Возвращаемое значение>
# Пример функции, принимающей два параметра, делящей их друг на друга и возвращающей в качестве результата строку с
# получившимся частным:
def division2(a, b):
    res = a / b
    s = str(a) + ' / ' + str(b) + ' = ' + str(res)
    return s


# После выполнения инструкции, возвращающей результат, исполнение тела функции завершается:
def func():
    print('Текст до инструкции return')
    return 'Возвращаемый результат'
    print('Этa инструкция никогда не будет выполнена')


# Если в теле функции отсутствует инструкция, возвращающая результат, функция при вызове все равно будет неявно
# возвращать в качестве результата значение None. Обращение к ранее определенной функции называется вызовом. И
# встроенные, и пользовательские функции вызываются одинаково - записью выражения в формате:
# <Имя функции>([<Значения параметров через запятую>])
# Количество параметров в выражении вызова функции должно совпадать с количеством параметров в ее определении, иначе
# будет выведено сообщение об ошибке. Если вызываемая функция не принимает параметров, все равно следует указать пустые
# круглые скобки. Примеры:
# Вызываем функцию, принимающую параметры
print(division(1, 2))
print(division(2, 1))
# Вызываем функцию, не принимающую параметров
print(rnd())
# Результат, возвращенный функцией, можно сохранить в какой-либо переменной или использовать в дальнейших вычислениях:
n = division2(4, 6)
print(n)
print('Получен результат: ', division2(7, 5))
# Также его можно нигде не сохранять и никак не использовать - в таком случае результат будет потерян. Так поступают,
# если результат выполнения функции не нужен для работы.
# Пример:
print(division2(4, 6))  # Результат выполнения функции потерян
# Поскольку в теле функции для хранения полученных параметров используются специально создаваемые локальные переменные,
# значения параметров могут быть изменены в теле функции - и зто не вызовет никаких сторонних эффектов в коде,
# вызвавшем функцию. Вот пример:
def func(a):
    print('Внутри функции: ', a)
    a = 20  # Изменяем значение параметра внутри функции
    print('Внутри функции: ', a)


b = 30                     # Создаем переменную
print('Вне функции: ', b)
func(b)                    # Передаем функции значение из переменной b
print('Вне функции: ', b)  # Значение переменной b не изменилось
# Однако в теле функции можно изменять значения изменяемых типов (например, списков), созданных вне функции (поскольку
# в функцию передаются не сами эти значения, а ссылки на них):
def func(lst):
    lst.append('Python')
    lst.append('Django')


platforms = ['РНР', 'Laravel']
print(func(platforms))
print(platforms)


# 11.1.1. Расположение определений функций
print('11.1.1. Расположение определений функций')
# Определение функции должно быть расположено перед ее вызовом. Правильно:
def summa(x, y):
    return x + y


v = summa(10, 20)
print(v)
# Неправильно (возникнет ошибка: Name Error: name 'summa' is not defined):
# v = summa1(10, 20)
# def summa1(х, у):
#    return х + у
# Traceback (most recent call last):
#   File "/Chapter_11.py", line 115, in <module>
#     v = summa1(10, 20)
#         ^^^^^^
# NameError: name 'summa1' is not defined.
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

# 223
