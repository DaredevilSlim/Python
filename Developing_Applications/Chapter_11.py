#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import random

# ГЛАВА 11
# Функции
# Функция - это языковая конструкция, выполняющая над переданными ей значениями (параметрами) какое-либо сложное
# действие. Так, функция sqrt() вычисляет квадратный корень, функция print() выводит заданные значения в консоль, а
# функция strftime() форматирует указанные дату и время сообразно заданному формату. Функция может принимать
# произвольное количество параметров, в том числе и ни одного. Также функция может возвращать результат выполненного ею
# действия.
# Язык Python содержит огромное количество функций, которые реализованы в нем самом и называются встроенными. Однако мы
# можем добавить к ним свои собственные, пользовательские, функции. Которым и посвящена эта глава.


# 11.1. Определение и вызов функции
print('11.1. Определение и вызов функции')


# Инструкция создания, или определения, пользовательской функции записывается в следующем формате:
# def <Имя функции>([<Имена параметров через запятую>]): <Тело функции>
# Имя функции должно быть уникальным, состоять из латинских букв, цифр и знаков подчеркивания и не начинаться с цифры.
# В качестве имени нельзя использовать ключевые слова Python, кроме того, следует избегать совпадений с названиями
# встроенных идентификаторов. Регистр символов в имени функции также имеет значение.
# Имена параметров должны удовлетворять тем же требованиям, что и имена переменных (см. разд. 2.1). Если функция не
# принимает параметров, следует указать пустые круглые скобки.
# Тело функции - это блок, реализующий функциональность определяемой функции. Не забываем, что инструкции, входящие в
# блок, должны иметь одинаковые отступы слева, выполненные пробелами.
# При вызове функции создаются переменные, имеющие те же имена, что и записанные в определении функции параметры. Эти
# переменные будут хранить реальные значения параметров, заданные в выражении вызова функции, станут доступны лишь в
# теле функции (локальные переменные), а после завершения выполнения функции - удалены из памяти.
# Пример определения функции, принимающей два параметра, делящей их друг на друга и выводящей результат в консоль:
def division(a, b):
    res = a / b
    print(str(a), ' / ', str(b), ' = ', str(res))


# Если тело функции состоит из одного выражения, его можно набрать в одной строке с языковой конструкцией def. Пример
# определения функции, не принимающей параметров и выводящей в консоль случайное число:
def rnd(): print(random.random())


# Для возврата результата из функции в ее теле записывается инструкция такого формата:
# return <Возвращаемое значение>
# Пример функции, принимающей два параметра, делящей их друг на друга и возвращающей в качестве результата строку с
# получившимся частным:
def division2(a, b):
    res = a / b
    s = str(a) + ' / ' + str(b) + ' = ' + str(res)
    return s


# После выполнения инструкции, возвращающей результат, исполнение тела функции завершается:
def func():
    print('Текст до инструкции return')
    return 'Возвращаемый результат'
    print('Этa инструкция никогда не будет выполнена')


# Если в теле функции отсутствует инструкция, возвращающая результат, функция при вызове все равно будет неявно
# возвращать в качестве результата значение None. Обращение к ранее определенной функции называется вызовом. И
# встроенные, и пользовательские функции вызываются одинаково - записью выражения в формате:
# <Имя функции>([<Значения параметров через запятую>])
# Количество параметров в выражении вызова функции должно совпадать с количеством параметров в ее определении, иначе
# будет выведено сообщение об ошибке. Если вызываемая функция не принимает параметров, все равно следует указать пустые
# круглые скобки. Примеры:
# Вызываем функцию, принимающую параметры
print(division(1, 2))
print(division(2, 1))
# Вызываем функцию, не принимающую параметров
rnd()
# Результат, возвращенный функцией, можно сохранить в какой-либо переменной или использовать в дальнейших вычислениях:
n = division2(4, 6)
print(n)
print('Получен результат: ', division2(7, 5))
# Также его можно нигде не сохранять и никак не использовать - в таком случае результат будет потерян. Так поступают,
# если результат выполнения функции не нужен для работы.
# Пример:
print(division2(4, 6))  # Результат выполнения функции потерян
# Поскольку в теле функции для хранения полученных параметров используются специально создаваемые локальные переменные,
# значения параметров могут быть изменены в теле функции - и зто не вызовет никаких сторонних эффектов в коде,
# вызвавшем функцию. Вот пример:
def func(a):
    print('Внутри функции: ', a)
    a = 20  # Изменяем значение параметра внутри функции
    print('Внутри функции: ', a)


b = 30                     # Создаем переменную
print('Вне функции: ', b)
func(b)                    # Передаем функции значение из переменной b
print('Вне функции: ', b)  # Значение переменной b не изменилось
# Однако в теле функции можно изменять значения изменяемых типов (например, списков), созданных вне функции (поскольку
# в функцию передаются не сами эти значения, а ссылки на них):


def func(lst):
    lst.append('Python')
    lst.append('Django')


platforms = ['РНР', 'Laravel']
func(platforms)
print(platforms)


# 11.1.1. Расположение определений функций
print('11.1.1. Расположение определений функций')
# Определение функции должно быть расположено перед ее вызовом. Правильно:


def summa(x, y):
    return x + y


v = summa(10, 20)
print(v)
# Неправильно (возникнет ошибка: Name Error: name 'summa' is not defined):
# v = summa1(10, 20)
# def summa1(х, у):
#    return х + у
# Traceback (most recent call last):
#   File "/Chapter_11.py", line 115, in <module>
#     v = summa1(10, 20)
#         ^^^^^^
# NameError: name 'summa1' is not defined.
# Чтобы избежать ошибки, определения функций размещают в самом начале программы после подключения модулей или в
# отдельном модуле. Если определения функций располагаются в том же модуле, что и их вызовы, определения  функций часто
# отделяют от остального кода - для наглядности. С помощью инструкции ветвления можно при выполнении заданного условия
# определить одну функцию, а при его невыполнении - другую test_00054.py.
# При вводе числа 1 мы получим сообщение 'Вы ввели число 1', в противном случае - 'Альтернативная функция'.
# Если определение одной и той же функции встречается в программе несколько раз, будет использоваться функция, которая
# была определена последней:


# 11.1.2. Локальные и глобальные переменные
print('11.1.2. Локальные и глобальные переменные')
# В теле функции можно создавать любые переменные. Они будут существовать только в теле функции и по завершении ее
# выполнения уничтожатся. Такие переменные называются локальными. Пример функции, в теле которой создаются локальные
# переменные res и s:


def division2(a, b):
    res = a / b
    s = str(a) + ' / ' + str(b) + ' = ' + str(res)
    return s


print(division2(4, 6))  # Вызываем функцию
# print(res)                    # Безуспешно пытаемся обратиться к локальной переменной
# Traceback (most recent call last):
#   File "/Chapter_11.py", line 146, in <module>
#     print(res)
#           ^^^
# NameError: name 'res' is not defined
# Как отмечалось ранее, сам интерпретатор для размещения значений параметров, переданных функции при вызове, создает в
# ней локальные переменные с именами, совпадающими с именами параметров, которые указаны в определении функции. Так, при
# вызове функции, определенной в предыдущем примере, будут созданы локальные переменные 'a' и 'b'. # Переменные,
# созданные вне любых функций, называются глобальными. Они доступны в теле любой функции - но только на чтение.
# Глобальную переменную можно создать как перед определением функции, так и после него. Пример:


def func():
    print(glob)


glob = 10
func()
# При попытке в теле функции присвоить глобальной переменной новое значение создается одноименная локальная переменная,
# к которой в дальнейшем и будет выполняться обращение:


def func2():
    glob = 20    # Будет создана локальная переменная glob
    print(glob)


func2()
print(glob)      # Значение глобальной переменной не изменилось
# Однако попытка в теле функции присвоить значение локальной переменной после обращения к одноименной глобальной
# переменной приведет к возбуждению исключения UnboundLocalError:


def func():
    print(glob)
    glob = 20


# func()
# Traceback (most recent call last):
#   File "/Chapter_11.py", line 189, in <module>
#     func()
#   File "/Chapter_11.py", line 185, in func
#     print(glob)
#           ^^^^
# UnboundLocalError: cannot access local variable 'glob' where it is not associated with a value
# Чтобы значения глобальных переменных можно было изменять внутри функции, необходимо в теле функции объявить эти
# переменные глобальными с помощью языковой конструкции формата:
# global <Имена переменных через запятую>
# Продемонстрируем это на примере test_00055.py.
# Результат выполнения:
# Значение glob вне функции = 10
# Значение glob внутри функции= 25
# Значение glob после функции = 25
# Получить все идентификаторы и их значения позволяют следующие функции:
# - globals() - возвращает словарь с глобальными идентификаторами;
# - locals() - возвращает словарь с локальными идентификаторами.
# Пример использования обеих этих функций показан в листинге test_00056.py.
# Результат выполнения:
# Глобальные идентификаторы внутри функции
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__',
# '__spec__', 'func', 'glob1', 'glob2']
# Локальные идентификаторы внутри функции
# ['glob2', 'local1']
# Глобальные идентификаторы вне функции
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__',
# '__spec__', 'func', 'glob1', 'glob2']
# - vars([<Объект>]) - если вызывается без параметра внутри функции, возвращает словарь с локальными идентификаторами.
# Если вызывается без параметра вне функции, возвращает словарь с глобальными идентификаторами. При указании объекта в
# качестве параметра возвращает идентификаторы этого объекта (эквивалентно вызову <Объект>. _dict_). Пример
# использования этой функции можно увидеть в листинге test_00057.py.
# Результат выполнения:
# Локальные идентификаторы внутри функции
# ['glob2', 'local1']
# Глобальные идентификаторы вне функции
# ['__annotations__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__',
# '__spec__', 'func', 'glob', 'glob2']
# Указание объекта в качестве параметра
# ['__class_getitem__', '__contains__', '__delitem__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__',
# '__gt__', '__hash__', '__init__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__',
# '__repr__', '__reversed__', '__ror__', '__setitem__', '__sizeof__', 'clear', 'copy', 'fromkeys', 'get', 'items',
# 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']
# Альтернативный вызов
# ['__class_getitem__', '__contains__', '__delitem__', '__doc__', '__eq__', '__ge__', '__getattribute__', '__getitem__',
# '__gt__', '__hash__', '__init__', '__ior__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__',
# '__repr__', '__reversed__', '__ror__', '__setitem__', '__sizeof__', 'clear', 'copy', 'fromkeys', 'get', 'items',
# 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values']


# 11.1.3. Позиционные и именованные параметры
print('11.1.3. Позиционные и именованные параметры')
# Ранее отмечалось, что при вызове функции ее параметры указываются через запятую внутри круглых скобок:
division(1, 2)
# Такие параметры носят название позиционных. Значения этих параметров передаются в вызываемую функцию согласно их
# позициям - в том порядке, в котором параметры указаны в выражении ее вызова. Так, в случае функции division() значение
# 1 будет присвоено параметру a (точнее, соответствующей ему локальной переменной, созданной интерпретатором,
# подробности - в разд. 11.1), а значение 2 - параметру b.
# Однако для вызова функции можно использовать выражение и другого формата:
# <Имя функции>([<Параметр 1>=<Значение параметра 1>,
#                <Параметр 2>=<Значение параметра 2>,
#                ...
#                <Параметр N>=<Значение параметра N>])
# Здесь применяются именованные параметры, значения которых передаются вызываемой функции по их именам, например:
division(a=1, b=2)
# Именованные параметры в выражении вызова функции можно располагать в произвольном порядке:
division(b=2, a=1)
# При вызове функции можно использовать и позиционные, и именованные параметры. Однако именованные параметры должны
# располагаться после позиционных, иначе возникнет ошибка. Примеры:


def func(a, b, c):
    print('a =>', str(a), 'b =>', str(b), 'с =>', str(c))


func(1, 2, c=3)
func(1, b=2, c=3)
func(1, c=3, b=2)
# func(a=1, 2, c=3)
# File "/Chapter_11.py", line 268
#     func(a=1, 2, c=3)
#                     ^
# SyntaxError: positional argument follows keyword argument
# При попытке передать функции не поддерживаемый ею именованный параметр возникнет ошибка:
# func(1, 2, 3, d=4)
# Traceback (most recent call last):
#   File "/Chapter_11.py", line 274, in <module>
#     func(1, 2, 3, d=4)
# TypeError: func() got an unexpected keyword argument 'd'
# По умолчанию любой параметр функции может быть указан и как позиционный, и как именованный (двоякий параметр). Однако
# существует возможность пометить одни параметры как задаваемые только в качестве именованных (строго именованные), а
# другие - только как позиционные (строго позиционные - поддерживаются, начиная с Python 3.8). Для этого языковая
# конструкция def, входящая в состав определения функции, записывается в следующем формате:
# def <Имя функции>(<Строго позиционные параметры>, /, <Двоякие параметры>, *, <Строго именованные параметры>)
# Пример функции с двумя строго позиционными, тремя двоякими и двумя строго именованными параметрами:


def func(a, b, /, c, d, e, f, g):
    print('a =>', str(a), 'b =>', str(b), 'с =>', str(c), 'd =>', str(d), end=' ')
    print('е =>', str(e), 'f =>', str(f), 'g =>', str(g), end=' ')


func(1, 2, 3, 4, 5, f=6, g=7)
print()
func(1, 2, 3, d=4, e=5, f=6, g=7)
print()
# Попытка передать строго позиционный параметр как именованный или строго именованный как позиционный приведет к ошибке:
# func(1, b=2, c=3, d=4, e=5, f=6, g=7)
# Traceback (most recent call last):
#   File "/Chapter_11.py", line 297, in <module>
#     func(1, b=2, c=3, d=4, e=5, f=6, g=7)
# TypeError: func() got some positional-only arguments passed as keyword arguments: 'b'
# Выражение вызова функции с позиционными параметрами имеет более компактную запись. Однако использование именованных
# параметров позволяет сделать ее нагляднее. Особенно удобно применять именованные параметры для вызова функций с
# большим числом необязательных параметров (о них рассказано в разд. 11.1.4).


# 11.1.4. Необязательные параметры
print('11.1.4. Необязательные параметры')
# Есть возможность сделать некоторые (или даже все) параметры пользовательской функции необязательными к указанию
# (необязательные параметры). Если при вызове функции такой параметр не задан, он получит заданное у него значение по
# умолчанию. Необязательный параметр указывается в определении функции в следующем формате:
# <Имя параметра>=<Значение параметра по умолчанию>
# Необязательные параметры должны следовать после обязательных к указанию, иначе возникнет ошибка. Пример функции, у
# которой второй параметр помечен как необязательный и имеет значение по умолчанию 2:


def division(a, b=2):
    print(str(a), ' / ', str(b), ' = ', str(a / b))


division(5)
division(5, 3)
division(5, b=12)
# Пример функции, имеющей два необязательных параметра:


def func(a, b=2, c=3):
    print('a=>', str(a), 'b =>', str(b), 'c =>', str(c))


func(1)
func(1, 200)
# Если при вызове функции требуется указать значение не первого из необязательных параметров, следует задать значения у
# всех предшествующих ему необязательных параметров (хотя бы равные указанным у них значениям по умолчанию)- в противном
# случае возникнет ошибка. Например, предположим, что нужно вызвать функцию func(), указав значение у третьего (второго
# необязательного) параметра:
func(1, 2, 3456789)  # Задаем второй параметр - все работает
# func(1, , 3456789)   # Пропускаем второй параметр - получаем ошибку
# File "/Chapter_11.py", line 338
#     func(1, , 3456789)   # Пропускаем второй параметр - получаем ошибку
#             ^
# SyntaxError: invalid syntax
# Хотя проще задать нужный-параметр как именованный (если определение функции позволяет это):
func(1, c=512)
# Значение по умолчанию, указанное у необязательного параметра, вычисляется только один раз при определении функции:
n = 2  # Создаем переменную для хранения значения параметра по умолчанию


def division(a, b=n):
    print(str(a), ' / ', str(b), ' = ', str(a / b))


division(5)
n = 3        # Изменяем значение переменной
division(5)  # Значение параметра по умолчанию не изменилось
# Если в качестве значения по умолчанию указать значение изменяемого типа, это значение будет сохраняться между вызовами
# функции:


def func(a=[]):
    a.append(2)
    return a


print(func())  # Выведет: [2]
print(func())  # Выведет: [2, 2]
print(func())  # Выведет: [2, 2, 2]
# Как видно из примера, значения накапливаются внутри списка. Обойти эту проблему можно, например, следующим образом:


def func(a=None):
    # Создаем новый список, если значение равно None
    if a is None:
        a = []
    a.append(2)
    return a


print(func())     # Выведет: [2]
print(func([1]))  # Выведет: [1, 2]
print(func())     # Выведет: [2]


# 11.1.5. Произвольное количество параметров
print('11.1.5. Произвольное количество параметров')
# Наконец, можно определять функции, принимающие произвольное количество параметров. Для этого в определении функции в
# составе набора принимаемых параметров следует указать одну из следующих языковых конструкций или сразу обе:
# - *<Имя параметра> - параметр с заданным именем получит в качестве значения кортеж, содержащий значения всех
# переданных функции позиционных параметров;
# - **<Имя параметра> - параметр с заданным именем получит в качестве значения словарь, содержащий значения всех
# переданных функции именованных параметров. В качестве ключей элементов словаря будут выступать имена параметров.


def func1(*pars):
    print(pars)


func1(1, 2, 3, 4)
func1(1, 2, 3, 4, 5, 6, 'abc')


def func2(**pars):
    print(pars)


func2(a=1, b=2, c=3)
func2(a=1, b=2, c=3, i=9, j='def')


def func3(*pars1, **pars2):
    print(pars1)
    print(pars2)


func3(1, 2, а=3, bcd=4)
func3(5, 6, 7)
func3(s='a', t='b', v='c')
# Можно комбинировать упомянутые языковые конструкции с обычными параметрами, использовав следующий формат:
# def <Имя функции>([<Строго позиционные параметры>, /,]
#                   <Двоякие параметры>[,
#                   *<Список позиционных параметров>][,
#                   <Строго именованные параметры>][,
#                   **<Словарь именованных параметров>])
# Пример функции, принимающей один обязательный строго позиционный параметр, один обязательный двоякий, произвольное
# количество позиционных параметров, один обязательный строго именованный и произвольное количество именованных:


def func4(a, /, b, *c, d, **e):
    print(a, b, c, d, e)


func4(1, 2, 3, 4, 5, d=6, е=7, f=8, g=9)
func4(1, b=2, d=6, e=7)
# func4(1, 2, 3, 4, 5, е=7, f=8, g=9)
# Traceback (most recent call last):
#   File "/Chapter_11.py", line 434, in <module>
#     func4(1, 2, 3, 4, 5, е=7, f=8, g=9)
# TypeError: func4() missing 1 required keyword-only argument: 'd'
# Пример функции, принимающей один необязательный двоякий параметр, произвольное количество позиционных и один
# необязательный именованный:


def func5(a=1, *b, c=100):
    print(a, b, c)


func5(1, 2, 3, 4, 5)
func5(a=10, c=20)
func5()


# 11.1.6. Распаковка последовательностей и отображений
print('11.1.6. Распаковка последовательностей и отображений')
# Если значения параметров, которые требуется передать в функцию, содержатся в последовательности (списке или кортеже)
# или отображении (словаре), то в вызове функции вместо параметров можно указать одну из следующих языковых конструкций
# или сразу обе:
# - *<Последовательность> - значения элементов заданной последовательности будут переданы вызываемой функции в качестве
# позиционных параметров;
# - **<Отображение> - значения элементов заданного отображения будут переданы вызываемой функции в качестве именованных
# параметров.
# Подобного рода передача в функцию параметров из последовательностей и отображений называется распаковкой. Ее пример
# приведен в test_00058.py.


# 11.1.7. Функция как значение. Функции обратного вызова
print('11.1.7. Функция как значение. Функции обратного вызова')
# Определение функции (неважно, пользовательской или встроенной) представляет собой объект, имеющий тип function, т. е.
# значение. Следовательно, функцию (точнее, ссылку на нее) можно присвоить какой-либо переменной, а позже вызвать через
# эту переменную. Пример показан в test_00059.py.
# Также можно поместить функцию в последовательность или отображение и даже передать функцию другой функции в качестве
# параметра test_00058.py. Функции, передаваемые другим функциям, носят название функций обратного вызова.


def summa(x, y):
    """ Суммирование двух чисел """
    return x + y


print(dir(summa))
print(summa.__name__)
print(summa.__code__.co_varnames)
print(summa.__doc__)


# 11.2. Анонимные функции
print('11.2. Анонимные функции')
# Анонимная функция (или лямбда-функция), в отличие от обычной, не имеет имени и поэтому сразу после определения должна
# быть присвоена какой-либо переменной или передана какой-либо другой функции - в противном случае она будет потеряна.
# Формат определения анонимной функции:
# lambda [<Параметр 1>[, . . . , <Параметр N>]]: <Возвращаемый результат>
# Пример использования анонимных функций приведен в test_00061.py.
# Анонимные функции могут иметь необязательные параметры test_00062.py.
# Чаще всего анонимные функции используют в качестве функций обратного вызова (см. разд. 11.6.7). Например, метод
# списков sort() позволяет указать пользовательскую функцию в параметре key. Отсортируем список без учета регистра
# символов, указав в качестве параметра анонимную функцию test_00063.py.
# При указании глобальной переменной внутри анонимной функции будет сохранена ссылка на эту переменную, а не ее значение
# в момент определения функции:
x = 5
func = lambda: x  # Сохраняется ссылка, а не значение переменной х!!!
x = 80             # Изменили значение
print(func())      # Выведет: 80, а не 5
# Если необходимо сохранить именно текущее значение глобальной переменной, можно воспользоваться следующим способом:
x = 5
func = (lambda y: lambda: y)(x)  # Сохраняется значение переменной х
x = 80                           # Изменили значение
print(func())                    # Выведет: 5
# Во второй строке кода мы определили анонимную функцию с одним параметром, возвращающую ссылку на вложенную анонимную
# функцию. Далее мы вызываем первую функцию с помощью круглых скобок и передаем ей значение переменной х. В результате
# сохраняется текущее значение переменной, а не ссылка на нее.
# Сохранить текущее значение глобальной переменной также можно, указав эту переменную в качестве значения параметра по
# умолчанию:
x = 5
func = lambda x=x: x  # Сохраняется значение переменной х
x = 80                # Изменили значение
print(func())         # Выведет: 5


# 11.3. Функции-генераторы
print('11.3. Функции-генераторы')
# Функция-генератор при последовательных вызовах возвращает один за другим элементы какой-либо последовательности. Для
# возврата элемента в таких функциях применяется языковая конструкция формата:
# yield <Возвращаемый элемент>
# Напишем функцию, которая генерирует диапазон из заданного количества чисел и последовательно возвращает его элементы,
# возведенные в заданную степень test_00064.py.
# Функции-генераторы поддерживают метод __next__(), выдающий следующее значение из последовательности. Когда значения
# заканчиваются, метод генерирует исключение StopIteration. Метод __next__() автоматически вызывается в цикле перебора
# последовательности. Для примера перепишем предыдущую программу, использовав метод __next__() вместо цикла
# test_00065.py.
# Существует возможность вызвать одну функцию-генератор из другой. Для этого применяется языковая конструкция формата:
# yield from <Вызываемая функция-генератор>
# Предположим, у нас есть список чисел, и нам требуется получить другой список, включающий числа в диапазоне от 1 до
# каждого из чисел в первом списке. Чтобы создать такой список, напишем код, показанный в test_00066.py.
# Здесь мы в функции-генераторе gen() перебираем переданный ей в качестве параметра список и для каждого его элемента
# вызываем другую функцию-генератор. В качестве последней выступает выражение, создающее диапазон от 1 до значения
# очередного элемента, увеличенного на единицу (чтобы это значение вошло в диапазон). В результате на выходе мы получим
# вполне ожидаемый результат:
# 1 2 3 4 5 1 2 3 4 5 6 7 8 9 10
# Усложним задачу, включив в результирующий список числа, умноженные на 2. Код, выполняющий эту задачу, показан в
# test_00067.py.
# Здесь мы вызываем из функции-генератора gen() функцию-генератор gen2(). Последняя создает диапазон, перебирает все
# входящие в него числа и возвращает их умноженными на 2. Результат работы приведенного в листинге кода таков:
# 2 4 6 8 10 2 4 6 8 10 12 14 16 18 20
# Функции-генераторы пригодятся при обработке большого количества значений, поскольку не понадобится загружать весь
# список с исходными значениями в память.


# 11.4. Декораторы функций
print('11.4. Декораторы функций')
# Декоратор - это функция, изменяющая поведение другой функции (например, производящая какие-либо действия перед ее
# выполнением). Функция-декоратор должна принимать в качестве параметра ссылку на функцию, поведение которой необходимо
# изменить, и возвращать ссылку на ту же функцию или какую-либо другую.
# Вызов декоратора записывается непосредственно перед определением изменяемой функции в формате:
# @<Имя декоратора>
# Круглые скобки у декоратора указывать не нужно.
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

# 223
