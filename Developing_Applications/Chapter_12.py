#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import time  # Подключаем модуля time
import math  # Подключаем модуля math
import sys   # Подключаем модуля sys

# ГЛАВА 12
print('ГЛАВА 12')
# Модули, пакеты и импорт
print('Модули, пакеты и импорт')
# Модуль-это любой файл с программным кодом. Любой модуль может использовать идентификаторы (переменные, функции и
# классы, о которых речь пойдет в главе 13), созданные в другом модуле, выполнив процедуру подключения, или импорта,
# последнего. В составе интерпретатора Python поставляется большой набор модулей, содержащих полезные переменные,
# функции и классы. Эти модули называются встроенными, а их совокупность - стандартной библиотекой языка.

# ПРИМЕЧАНИЕ - Модули можно создавать не только на самом Python, но и на языке С++, компилируя их в машинный код. В
# стандартной библиотеке содержится ряд таких модулей.

# Модуль Python представляется особым объектом, содержащим ряд атрибутов. Так, атрибут __name__ содержит имя модуля в
# виде строки. У модуля, непосредственно запущенного на исполнение, этот атрибут хранит строку '__main__'. Пример:
print(__name__)  # Выведет: main
# Проверить, является модуль непосредственно запущенным (главным модулем, или главной программой) или импортированным,
# позволяет следующий код:
if __name__ == '__main__':
    print('Это главная программа')
else:
    print('Импортированный модуль')


# 12.1. Импорт модуля целиком
print('12.1. Импорт модуля целиком')
# Можно импортировать модуль целиком и использовать любые созданные в нем переменные, функции и классы. Для этого
# предназначена языковая конструкция следующего формата:
# import <Модуль 1> [as <Псевдоним 1>], ..., <Модуль N> [as <Псевдоним N>]
# Имя модуля не должно содержать расширения и пути к файлу, а также удовлетворять всем требованиям, предъявляемым к
# именам переменных (см.разд. 2.1). Дело в том, что при импорте модуля интерпретатор создает переменную, которой
# присваивает объект импортированного модуля.
# Все идентификаторы, созданные в импортированном модуле, доступны через атрибуты объекта этого модуля (атрибут - это
# переменная, входящая в состав объекта). Для доступа к атрибутам следует использовать такой синтаксис:
# <Переменная с объектом модуля>.<Атрибут с нужным идентификатором>
# Поскольку переменная с объектом модуля и атрибут отделяются друг от друга точкой, такая запись получила название
# точечной нотации.
# Для примера импортируем модуль time и получим текущую дату вызовом функции strftime(), определенной в этом модуле:
print(time.strftime('%d.%m.%Y'))
# Подключим сразу два модуля: time и math:
print(time.strftime('%d.%m.%Y'))
print(math .pi)  # Число п
# Функция getattr() позволяет получить значение атрибута с заданным в виде строки именем, принадлежащего указанному
# модулю. С помощью этой функции можно сформировать имя нужного атрибута программно. Формат функции:
# getattr(<Объект модуля>, <Имя атрибута>[, <Значение по умолчанию>])
# Если указанный атрибут не найден, возвращается заданное значение по умолчанию, а если оно не указано - возбуждается
# исключение AttributeError. Пример:
print(getattr(math, 'pi'))     # Будет выведено число п
print(getattr(math, 'х', 50))  # Будет выведено 50, т.к. х не существует
# Проверить существование атрибута с заданным именем в указанном модуле позволяет функция
# hasattr(<Модуль>, <Имя атрибута>). Если атрибут существует, функция возвращает значение True, в противном случае
# - False. Напишем функцию проверки существования атрибута в модуле math test_00077.py.
# Если имя модуля слишком длинное и его неудобно указывать каждый раз для доступа к атрибутам, то можно дать модулю
# псевдоним. После чего для доступа к модулю следует использовать исключительно указанный псевдоним (при попытке доступа
# по имени модуля возникнет ошибка). Дадим модулю math псевдоним m:
# import math as m
# print(m.pi)
# Идентификаторы, содержащиеся в импортированном модуле, не смешиваются с идентификаторами, созданными в импортирующем
# модуле. Это значит, что, например, в импортируемом и импортирующем модулях могут содержаться совершенно разные
# переменные с одинаковым именем х.
# Проиллюстрируем это примером. Создадим модуль test_00078.py, в котором определим переменную х.
# В главной программе также определим переменную х, но с другим значением. Затем подключим модуль test_00078.py и
# выведем значения переменных test_00079.py.
# Оба модуля размещаем в одном каталоге и запускаем модуль с главной программой. Программа выведет числа 50 и 22
# - значения переменных с именем х, хранящихся в разных модулях. Как видно из результата, одноименные переменные из
# разных модулей никак не конфликтуют друг с другом.
# Объект каждого импортированного модуля заносится в словарь modules из модуля sys. При попытке импорта модуля сначала
# проверяется, есть ли этот модуль в упомянутом словаре, и если он там есть, повторный импорт выполнен не будет.
# Выведем ключи словаря modules, предварительно отсортировав их test_00080.py.
# Инструкция импорта требует явного указания объекта модуля. Задать имя модуля в виде строки нельзя.
# Чтобы подключить модуль, имя которого формируется программно, следует воспользоваться функцией
# __import__( <Имя модуля>). Функция возвращает объект импортированного модуля. Для примера импортируем модуль
# test_00078.py с помощью функции __import__() test_00081.py.
# Получить список всех идентификаторов, созданных в указанном модуле, позволяет функция dir(<Объект модуля>). Еще можно
# воспользоваться словарем из атрибута __dict__ объекта модуля, который содержит все идентификаторы и их значения
# test_00082.py.
# ПРИМЕЧАНИЕ - При импорте модуля он всегда компилируется (о компиляции рассказывалось в разд. 1.10).


# 12.2. Импорт отдельных идентификаторов
print('12.2. Импорт отдельных идентификаторов')
# Также можно импортировать из модуля только отдельные идентификаторы, нужные для работы. Для этого применяется языковая
# конструкция, записываемая в одном из следующих форматов:
# from <Модуль> import <Идентификатор 1> [as <Псевдоним 1>], ..., <Идентификатор N> [as <Псевдоним N>]
# from <Модуль> import (<Идентификатор 1> [as <Псевдоним 1>], ..., <Идентификатор N> [as <Псевдоним N>])
# from <Модуль> import *
# Первые два формата импортируют из указанного модуля только заданные идентификаторы. Длинным идентификаторам можно
# назначить псевдонимы. В качестве примера импортируем из модуля math константу pi и функцию floor(), дав последней
# псевдоним f test_00083.py.
# Второй формат инструкции импорта позволяет разбить слишком длинный перечень импортируемых идентификаторов на несколько
# строк:
# from math import (pi, floor, sin, cos)
# Третий формат импортирует из модуля все идентификаторы. Для примера импортируем все идентификаторы из модуля math
# test_00084.py.
# Однако в этом случае идентификаторы, импортированные из модуля, смешаются с идентификаторами из импортирующего модуля.
# Например, если импортировать из модуля переменную s, а потом попытаться создать в импортирующем модуле переменную с
# таким же именем, произойдет перезапись значения импортированной переменной s. То же самое произойдет, если
# импортировать одноименную переменную из двух разных модулей,- при импорте переменной из второго модуля будет
# перезаписано значение переменной из первого модуля.
# Для примера создадим два модуля, содержащих переменные с одинаковым именем s и разными значениями, и подключим их с
# помощью разных инструкций. Содержимое первого модуля, с именем test_00085.py, приведено в test_00085.py.
# Содержимое второго модуля, test_00086.py, приведено в test_00086.py.
# Код главной программы показан в test_00087.py.
# Размещаем все три модуля в одном каталоге, запускаем модуль с главной программой и смотрим на результат. Согласно
# результату переменная s получила значение из модуля test_00086.py, который был импортирован последним. Это довольно
# опасная ситуация, чреватая возникновением трудно выявляемых ошибок. Однако получить доступ к переменным s из разных
# модулей все-таки можно - импортировав эти модули целиком (см.разд. 12.1).


# 12.2.1. Указание идентификаторов, доступных для импорта
print('12.2.1. Указание идентификаторов, доступных для импорта')
# По умолчанию все идентификаторы, определенные в модуле, доступны для импорта в других модулях. Исключение составляют
# лишь идентификаторы, начинающиеся со знака подчеркивания,- их импортировать нельзя.
# Однако можно явно задать перечень идентификаторов, доступных для импорта (идентификаторы, не указанные в перечне, не
# будут импортироваться). Для этого следует в коде модуля занести в переменную _all_ список таких идентификаторов,
# представленных в виде строк. Интересно, что таким образом можно сделать доступными для импорта даже идентификаторы,
# начинающиеся с подчеркивания.
# Для примера создадим модуль test_00088.py с множеством переменных и разрешим другим модулям импортировать только две
# из них.
# Затем напишем главную программу, которая будет его импортировать test_00089.py.


# 12.2.2. Управление доступом к идентификаторам
print('12.2.2. Управление доступом к идентификаторам')
# В Python 3.7 появилась возможность управлять доступом к идентификаторам, определенным в импортируемом модуле.
# В частности, можно при попытке получить из импортирующего модуля доступ к какому-либо несуществующему идентификатору
# выдать значение другого, существующего, идентификатора или даже результат вычисления какого-либо выражения.
# Чтобы реализовать управление доступом к идентификаторам, в модуле следует определить специальную функцию (функцию,
# вызываемую самим интерпретатором в определенные моменты времени) с именем __getattr__(). Она должна принимать в
# качестве единственного параметра имя идентификатора, к которому импортирующий модуль пытается получить доступ, и либо
# возвращать какое-либо значение, либо, если такой идентификатор не должен поддерживаться, генерировать исключение
# AttributeError.
# Также в модуле можно определить специальную функцию __dir__(). Она не должна принимать параметров и должна возвращать
# последовательность с именами идентификаторов, доступных извне текущего модуля.
# В качестве примера создадим модуль test_00090.py.
# Код главной программы приведен в test_00091.py.


# 12.3. Пути поиска модулей
print('12.3. Пути поиска модулей')
# Получить список файловых путей, по которым интерпретатор Python будет искать импортируемые модули, можно из переменной
# path, которая создана в модуле sys:
for i in sys.path:
    print(i)
# Список из переменной path содержит следующие пути:
# - путь к папке с файлом главной программы или, если интерпретатор работает в интерактивном режиме, пустая строка;
# - значение переменной окружения PYTHONPATH. Для создания этой переменной в меню Пуск выбираем пункт Панель управления
# (или Настройка | Панель управления). В открывшемся окне выбираем пункт Система и щелкаем на ссылке Дополнительные
# параметры системы. Переходим на вкладку Дополнительно и нажимаем кнопку Переменные среды. В разделе Переменные среды
# пользователя нажимаем кнопку Создать. В поле Имя переменной вводим PYTHONPATH, а в поле Значение переменной задаем
# пути к папкам с модулями через точку с запятой - например, с:\folder1;с:\folder2. Закончив, не забудем нажать кнопки
# ОК обоих открытых окон. После этого изменения перезагружать компьютер не нужно, достаточно перезапустить программу;
# - пути поиска стандартных модулей;
# - содержимое файлов с расширением pth, расположенных в каталогах поиска стандартных модулей,- например, в каталоге
# C:\Python310\Lib\site-packages. Названия таких файлов могут быть произвольными, главное, чтобы они имели расширение
# pth. Каждый путь (абсолютный или относительный) должен быть расположен на отдельной строке.
# Для примера создайте файл mypath.pth в каталоге C:\Python310\Lib\site-packages со следующим содержимым:
# Это комментарий
# С:\folder1
# С:\folder2
# Каталоги должны существовать, в противном случае они не будут добавлены в список sys.path.
# При поиске модуля список sys.path просматривается от начала к концу. Поиск прекращается после первого найденного
# модуля. Таким образом, если в каталогах C:\folder1 и C:\folder2 существуют одноименные модули, то будет использоваться
# модуль из папки C:\folder1, поскольку он расположен первым в списке путей поиска.
# Список sys.path можно изменять программно с помощью соответствующих методов.
# Например, добавить каталог в конец списка можно с помощью метода append(), а в его начало - с помощью метода insert()
# test_00092.py.
# В этом примере мы добавили папку C:\folder2 в начало списка. Теперь, если в каталогах C:\folder1 и C:\folder2
# существуют одноименные модули, будет использоваться модуль из папки C:\folder2, а не из папки C:\folder1, как в
# предыдущем примере.
# Также можно указать полностью свои пути для поиска модулей, при этом список, хранящийся в переменной sys.path, будет
# проигнорирован. Для этого достаточно поместить в папку, где установлен Python, файл с именем python<первые два числа
# из номера версии Python>._pth (так, для Python 3.10 этот файл должен иметь имя python310._pth) или python._pth, в
# котором записать все нужные пути в том же формате, который используется при создании файлов pth. Первый файл будет
# использоваться программами, вызывающими библиотеку времени выполнения Python, в частности IDLE Shell. А второй файл
# будет считан при запуске Python-программы щелчком мыши на ее файле.
# В файл python<первые два числа из номера версии Python>._pth обязательно следует включить пути для поиска модулей,
# составляющих стандартную библиотеку Python (их можно получить из списка, хранящегося в переменной sys.path).
# Если этого не сделать, утилита IDLE Shell вообще не запустится.


# 12.4. Перезагрузка модулей
print('12.4. Перезагрузка модулей')
# При первой операции импорта модуль загружается в оперативную память. При последующих попытках импортировать тот же
# модуль ничего не произойдет. Если же требуется выполнить повторный импорт (перезагрузку) импортированного ранее
# модуля, следует воспользоваться функцией reload(<Модуль>) из модуля importlib.
# В качестве примера создадим модуль test_00093.py, поместив его в папку C:\book.
# Следует учитывать, что идентификаторы, импортированные с помощью языковой конструкции from, перезагружены не будут.
# Кроме того, не перезагружаются скомпилированные модули, написанные на других языках программирования (например, на С).


# 12.5. Пакеты
print('12.5. Пакеты')
# Пакет - это обычный каталог, содержащий модули и обязательный файл инициализации __init__.py. Последний может быть
# пустым или содержать код, который будет выполнен при первой операции импорта любого модуля из этого пакета. Чтобы
# импортировать модуль, находящийся в пакете, надо записать путь к этому модулю, разделяя имена пакетов и самого модуля
# точками. Например, чтобы импортировать модуль module2.py из пакета folder1\folder2, следует записать инструкцию:
# import folder1.folder2.module2
# Правда, переменная, создаваемая интерпретатором для хранения объекта импортированного модуля, получит имя, совпадающее
# с указанным путем к модулю:
# folder1.folder2.module.func()
# Поэтому для упрощения доступа к созданным в таком модуле идентификаторам рекомендуется задавать у модуля псевдоним:
# import folder1.folder2.module2 as mod
# mod.func()
# или импортировать только нужные идентификаторы:
# from folder1.folder2.module import func
# func()
# Также можно импортировать модуль из пакета, записав языковую конструкцию формата:
# from <Путь к пакету> import <Модуль>[ as <Псевдоним>]
# Например:
# from folder1.folder2 import module
# module.func()
# В качестве примера создадим следующую структуру каталогов и файлов:
# main.py  # Файл с главной программой
# folder1\  # Каталог на одном уровне вложенности с main.py
#   __init__.ру  # Файл инициализации
#   module1.py  # Модуль folder1\module1.py
#   folder2\  # Вложенный каталог
#       __init__.ру  # Файл инициализации
#        module2.py  # Модуль folder1\folder2\module2.py
#        moduleЗ.py  # Модуль folder1\folder2\module3.py
# Содержимое файлов __init__.py:
# print('__init__ из', __name__)
# Содержимое модулей module1.py, module2.py, module3.py
# msg = 'Модуль {О}'.format(__name__)
# Теперь импортируем эти модули в главном модуле main.py и получим значение переменной msg разными способами. Содержимое
# модуля main.py:
# # Доступ к модулю folder1\module1.py
# import folder1.module1 as m1               # Выведет: __init__ из folder1
# print(m1.msg)                              # Выведет: Модуль folder1.module1
# from folder1 import module1 as m2
# print(m2.msg)                              # Выведет: Модуль folder1.module1
# from folder1.module1 import msg
# print(msg)                                 # Выведет: Модуль folder1.module1
# Доступ к модулю folder1\folder2\module2.py
# import folder1.folder2.module2 as mЗ       # Выведет: __init__ из folder1.folder2
# print(mЗ.msg)                              # Выведет: Модуль folder1.folder2.module2
# from folder1.folder2 import module2 as m4
# print(m4.msg)                              # Выведет: Модуль folder1.folder2.module2
# from folder1.folder2.module2 import msg
# print(msg)                                 # Выведет: Модуль folder1.folder2 .module2
# input()
# Инструкция импорта из пакета также позволяет импортировать сразу несколько модулей. Для этого внутри файла
# инициализации __init__.py в переменной __all__ следует указать список с именами импортируемых модулей. В качестве
# примера изменим содержимое файла __init__.py из каталога folder1\folder2\ на следующее:
# __all__ = ['module2', 'module3']
# Теперь создадим модуль main2.py и запустим его.
# from folder1.folder2 import *
# print(module2.msg)  # Выведет: Модуль folder1.folder2.module2
# print(module3.msg)  # Выведет: Модуль folder1.folder2.module3
# input()
# Здесь после ключевого слова from указывается лишь путь к пакету без имени модуля. В результате будут импортированы все
# модули, указанные в списке __all__.
# Чтобы импортировать модуль, расположенный в том же каталоге, что и импортирующий модуль, перед именем модуля
# указывается точка, например:
# from .module import *
# или
# from . import module
# Чтобы импортировать модуль, расположенный в родительском каталоге, перед именем модуля указываются две точки:
# from .. module import *
# или
# from .. import module
# Если необходимо обратиться уровнем еще выше, то указываются три точки:
# from ... module import *
# или
# from ... import module
# Для примера создадим в каталоге C:\folder1\folder2\ модуль module4.py.
# Импорт модуля module2.py из текущего каталога
# from . import module2 as m1
# var1 = "Значение из: {0}".format(m1.msg)
# from .module2 import msg as m2
# var2 = "Значение из: {0}".format(m2)
# Импорт модуля module1.py из родительского каталога
# from .. import module1 as mЗ
# varЗ = "Значение из: {О}".format(mЗ.msg)
# from .. module1 import msg as m4
# var4 = "Значение из: {О}".format(m4)
# Теперь создадим модуль mainЗ.py и запустим его на выполнение.
# from folder1.folder2 import module4 as m
# print(m.var1)  # Значение из: Модуль folder1.folder2.module2
# print(m.var2)  # Значение из: Модуль folder1.folder2.module2
# print(m.varЗ)  # Значение из: Модуль folder1.module1
# print(m.var4)  # Значение из: Модуль folder1.module1
# input()
# Следует помнить очень важную вещь. Если при запуске Python-программы в список sys.path автоматически добавляется путь
# к каталогу с запущенным файлом, то при относительном импорте внутри пакета этого не происходит. Для примера изменим
# содержимое модуля module4.py на следующее:
# import module2  # Ошибка! Поиск модуля по абсолютному пути
# var1 = "Значение из: {0}".format(module2.msg)
# var2 = varЗ = var4 = О
# Здесь мы пытаемся импортировать из модуля module4.py модуль module2.py, находящийся в том же пакете. Однако раз путь к
# импортирующему модулю (и, соответственно, к содержащему его пакету) не был добавлен в его список sys.path,
# интерпретатор не найдет требуемый модуль и выдаст ошибку. А если по одному из путей поиска модулей находится модуль с
# таким же именем, то он и будет импортирован и программа станет работать не так, как нужно (и, скорее всего, «вылетит»
# с ошибкой).
# Чтобы импортировать модуль из того же пакета, следует использовать такую инструкцию:
# from . import module2
# или указать полный путь относительно каталога, в котором находится главный модуль:
# import folder1.folder2.module2 as module2
