#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ГЛАВА 13
print('ГЛАВА 13')
# Объекты и классы
print('Объекты и классы')
# Объект - это сложная структура, хранящая множество каких-либо значений и содержащая инструменты для их обработки.
# Отдельные значения хранятся в атрибутах - переменных, входящих в состав объекта, а инструменты реализованы в виде
# методов - функций, которые также принадлежат объекту.
# Все значения, обрабатываемые Python, представляют собой объекты. Например, строка является объектом, содержащим методы
# format(), strip(), split() и многие другие. Значение даты также является объектом с атрибутами year, month, day,
# методами weelday(), isoformat() и др..
# Класс - это образец, на основе которого создаются объекты, относящиеся к одной разновидности. Класс определяет набор
# атрибутов и методов, поддерживаемых объектами соответствующей разновидности. Например, объекты строк принадлежат
# классу, носящему имя str (как и строковый тип данных), а объекты дат - классу date.
# Стандартная библиотека Python содержит множество классов, называемых встроенными.
# Кроме того, разработчики могут создавать свои, пользовательские классы.


# 13.1. Определение классов, создание объектов и работа с ними
print('13.1. Определение классов, создание объектов и работа с ними')
# Инструкция создания, или определения, пользовательского класса записывается в следующем формате:
# class <Имя класса>:
#   [<Строка документирования>]
#   <Определения методов>
# Имя класса должно удовлетворять тем же требованиям, что и имена переменных.
# Дело в том, что, обработав определение класса, интерпретатор создает переменную, чье имя совпадает с именем созданного
# класса, и присваивает ей определение этого класса (которое также представляет собой объект).
# Определения методов записываются в том же формате, что и определения функций. Первым (или единственным) параметром
# каждый метод должен принимать ссылку на текущий объект этого класса (чтобы в теле метода можно было обратиться к
# атрибутам и методам текущего объекта). Традиционно этому параметру дают имя self.
# Атрибуты создаются в теле методов простым присваиванием им значений, для чего применяются инструкции формата:
# <Объект>.<Атрибут> = <Значение атрибута>
# В качестве <Объекта> следует использовать значение первого параметра, полученного методом (как отмечалось ранее,
# обычно его называют self).
# Кроме того, внутри методов можно обращаться к созданным ранее атрибутам текущего объекта с целью получить их значения,
# применяя следующий синтаксис (известный под названием точечной нотации):
# <Объект>.<Атрибут>
# и вызывать методы, использовав выражение формата:
# <Объект>.<Метод>([Параметры через запятую])
# При вызове метода следует указать только значения второго и последующих параметров, передаваемых ему. Значение первого
# параметра (self) - ссылка на текущий объект - будет передано методу самим интерпретатором.
# Определения классов должны предшествовать инструкциям, создающим на их основе объекты. Как правило, определения класса
# располагают в начале модуля или в отдельном модуле, отделяют от остального кода и друг от друга пустыми строками - для
# наглядности.
# При вводе определения класса в интерпретаторе, работающем в интерактивном режиме, после ввода языковой конструкции
# class и нажатия клавиши <Enter> последующие строки станут выводиться с отступом слева, и можно будет занести строку
# документирования, определения атрибутов и методов. При вводе определения метода после набора языковой конструкции def
# следующие строки станут выводиться с двойным отступом слева, и можно будет занести тело метода. Завершив ввод тела
# очередного метода, следует уменьшить отступ нажатием клавиши <Backspace>, чтобы ввести языковую конструкцию def
# определения следующего метода. Завершив ввод всех методов, нужно нажать <Enter> дважды, чтобы закончить ввод
# определения класса.
# Пример определения класса Platform, содержащего атрибуты name (название программной платформы) и type (тип платформы:
# клиентская или серверная, изначальное значение: "Серверная"), методы setName(<Название>) (задает новое название у
# текущей платформы) и getFullName() (возвращает строку с названием и типом текущей платформы):


class Platform:

    def set_name(self, name):
        self.name = name         # Создаем атрибут name
        self.type = 'Серверная'  # Создаем атрибут type

    def get_full_name(self):
        return self.name + ' (' + self.type + ')'


# Определив класс, на его основе можно создать произвольное количество объектов. Для создания объекта класса примеряется
# следующий синтаксис:
# <Класс>()
# Возвращенный объект класса необходимо присвоить какой-либо переменной, атрибуту другого объекта, передать в качестве
# параметра функции или методу. Если этого не сделать, созданный объект будет потерян.
# Для примера создадим пару объектов только что определенного класса Platform:
p11 = Platform()
p12 = Platform()
# Для обращения к атрибутам и методам объекта применяется точечная нотация, описанная ранее. Укажем у первого из
# созданных объектов название платформы (вызовом метода set_name()),а у второго-название и тип (который занесем в
# атрибут type):
p11.set_name('Python')      # Указываем значение второго параметра метода
p12.set_name('JavaScript')  # Значение первого параметра(ссылка на текущий объект) будет передано методу интерпретатором
p12.type = 'Клиентская'
print(p12.get_full_name())
print(p11.get_full_name())
# В обычном коде можно создавать у объекта принадлежащие исключительно ему атрибуты (атрибуты экземпляра объекта),
# просто присваивая им значения. Создадим у второго объекта класса Platform атрибут экземпляра объекта founded, хранящий
# год создания платформы:
p12.founded = 1995
print(p12.founded)
# print(p11.founded)  # У первого объекта атрибута founded нет
# File "/Chapter_13.py", line 91
#     . .. Фрагмент пропущен ...
#     ^
# SyntaxError: invalid syntax
# Удалить ненужный атрибут можно, использовав языковую конструкцию del и записав в ней удаляемый атрибут в формате:
# <Объект>.<Атрибут>:
# del p11.founded
# Для работы с атрибутами можно использовать следующие функции:
# - getattr() - возвращает значение атрибута с заданным в виде строки именем, принадлежащего указанному объекту. Формат
# функции:
# getattr(<Объект>, <Имя атрибута>[, <Значение по умолчанию>])
# Если атрибут с указанным именем не найден, генерируется исключение AttributeError. Чтобы избежать этого, в третьем
# параметре можно указать значение по умолчанию, возвращаемое, если атрибут не существует;
# - setattr() - заносит указанное значение в атрибут с указанным именем, принадлежащий заданному объекту. Формат
# функции:
# setattr(<Объект>, <Имя атрибута>, <Значение>)
# Вторым параметром можно передать имя несуществующего атрибута - в этом случае будет создан атрибут экземпляра объекта
# с таким именем;
# - delattr(<Объект>, <Имя атрибута>) - удаляет из заданного объекта атрибут, чье имя указано в виде строки;
# - hasattr(<Объект>, <Имя атрибута>) - возвращает True, если атрибут с именем, указанным в виде строки, существует в
# заданном объекте, и False - в противном случае.
# Примеры использования этих функций:
print(getattr(p11, 'type'))  # Серверная
# print(getattr(p11, 'version'))
# Traceback (most recent call last):
#   File "/Chapter_13.py", line 114, in <module>
#     print(getattr(p11, 'version'))
#           ^^^^^^^^^^^^^^^^^^^^^^^
# AttributeError: 'Platform' object has no attribute 'version'
print(getattr(p11, 'version', '0.0'))
setattr(p11, 'version', '1.0')
print(p11.version)
print(hasattr(p12, 'founded'))
delattr(p12, 'founded')
print(hasattr(p12, 'founded'))
# Любые атрибуты и методы, определенные в классе, доступны как изнутри этого класса, так и извне его. Такие атрибуты и
# методы называются общедоступными. Исключение составляют лишь атрибуты и методы, чьи имена начинаются с двойного
# подчеркивания (__) - они доступны только внутри класса (закрытые атрибуты и методы). Закрытые атрибуты и методы будут
# описаны далее.
# Определение класса представляет собой объект типа type:
print(type(Platform))
print(type(Platform) is type)


# 13.2. Атрибуты класса
print('13.2. Атрибуты класса')
# У класса можно создать атрибуты, принадлежащие самому классу, а не создаваемым на его основе объектам (атрибуты
# класса). Для этого применяется расширенный синтаксис определения класса:
# class <Имя класса>:
#   [<Строка документирования>]
#   [<Определения атрибутов класса>]
#   <Определения методов>
# Определение отдельного атрибута класса записывается в формате:
# <Имя атрибута> = <Значение атрибута>
# Пример класса, содержащего два атрибута класса:


class Python:
    type = 'Язык программирования'
    version = '3.10.1'


# Получить доступ к атрибутам класса можно как через сам класс (наиболее часто используемый вариант):
print(Python.type)
Python.version = '3.12.1'
print(Python.version)
# так и через объекты этого класса:
p = Python()
print(p.type)
# Однако если попытаться изменить значение атрибута класса через объект, в этом объекте будет создан одноименный атрибут
# экземпляра объекта:
p.type = 'Среда разработки'
# Якобы меняем значение атрибута класса type В результате будет создан одноименный атрибут экземпляра объекта
print(p.type)
p2 = Python()   # Создаем еще один объект класса Python
print(p2.type)  # Проверяем значение атрибута класса type
# Атрибут класса будет хранить одно и то же значение у всех объектов этого класса. Так, если в атрибуте класса сохранить
# список, все объекты этого класса станут ссылаться на один и тот же объект списка, например:


class Platforms:
    platform_list = []  # Атрибут класса, хранящий список


pls1 = Platforms()
pls2 = Platforms()
# Добавляем элемент в список через первый объект
pls1.platform_list.append('Python')
# Добавляем элемент в список через второй объект
pls2.platform_list.append('JavaScript')
# И убеждаемся, что оба объекта ссылаются на один и тот же список
print(pls1.platform_list)
print(pls2.platform_list)


# 13.3. Конструкторы и деструкторы
print('13.3. Конструкторы и деструкторы')
# В определении класса можно указать два метода, имеющих специальное назначение:
# - __init__() - конструктор - автоматически вызывается при создании объекта текущего класса.
# Первым параметром конструктору, как и другим методам, передается ссылка на текущий объект. Остальными параметрами
# можно передать любые значения, которые могут быть занесены в атрибуты создаваемого объекта или использованы в
# вычислениях.
# Для создания объекта класса, имеющего конструктор, применяется инструкция следующего формата:
# <Класс>([<Значения параметров через запятую>]])
# Указанные значения параметров будут переданы конструктору;
# - __del__() - деструктор - автоматически вызывается перед уничтожением объекта текущего класса, когда перестает
# существовать последняя ссылка на этот объект. Должен принимать один параметр - ссылку на текущий объект.
# Пример класса с конструктором и деструктором показан в test_00094.py.


# 13.4. Наследование
print('13.4. Наследование')
# Наследование - это создание одного класса (производного, или подкласса) на основе другого (базового, или суперкласса).
# Производный класс получает все атрибуты и методы, присутствующие в базовом классе.
# Для определения производного класса применяется инструкция следующего формата:
# class <Имя класса>(<Базовый класс>):
#   <Остальная часть определения класса>
# Если и в базовом, и в производном классе присутствуют методы с одинаковыми именами, при вызове такого метода из
# объекта производного класса будет вызван метод производного класса. То есть метод производного класса произведет
# перекрытие одноименного метода из базового класса. Рассмотрим пример из test_00095.py.
# Однако на практике чаще приходится не полностью заменять какой-либо метод базового класса в производном классе, а
# дополнять его функциональность - производить переопределение метода. В теле переопределяемого метода производного
# класса записывается код, реализующий дополнительную функциональность, и в нужном месте этого кода ставится инструкция
# вызова метода базового класса. Для вызова метода базового класса из метода производного класса можно использовать одну
# из следующих инструкций:
# - вызов функции super() - с применением выражения формата:
# suреr([<Производный класс>, <Ссыпка на текущий объект>]).<Вызов метода базового класса>
# В вызове метода базового класса первый параметр, содержащий ссылку на текущий объект, не указывается.
# У самой функции super() параметры указываются редко, в крайне специфических случаях;
# - <Базовый класс>.<Вызов метода базового класса>
# Здесь в вызове метода базового класса, напротив, следует передать первый параметр, содержащий ссылку на текущий
# объект.
# Рассмотрим пример переопределения двух методов базового класса в производном классе двумя только что описанными
# способами test_00096.py.


# 13.4.1. Множественное наследование
print('13.4.1. Множественное наследование')
# При множественном наследовании производный класс наследует сразу от нескольких базовых классов.
# Для множественного наследования применяется инструкция следующего формата:
# class <Имя класса>(<Базовые классы через запятую>):
#   <Остальная часть определения класса>
# При обращении в производном классе к атрибуту или методу, определенному в одном из базовых классов, просмотр базовых
# классов будет выполняться в том порядке, в котором они указаны.
# Рассмотрим множественное наследование на примере test_00097.py.
# Метод func_one() определен в двух классах: Class1 и Class3. Так как вначале просматриваются все базовые классы,
# непосредственно указанные в определении текущего класса, метод func_one() будет найден в классе Class3 (поскольку он
# указан в числе базовых классов в определении Class4), а не в классе Class1.
# Метод func_two() также определен в двух классах: Class2 и Class3. Так как класс Class2 стоит первым в списке базовых
# классов, то метод будет найден именно в нем. Чтобы наследовать метод из класса Class3, следует указать это явным
# образом. Переделаем определение класса Class4 из предыдущего примера и наследуем метод func_two() из класса Class3
# test_00098.py.
# Рассмотрим порядок поиска идентификаторов при сложной иерархии множественного наследования test_00099.py.
# Последовательность поиска атрибута х будет такой:
# Class7 -> Class4 -> Class3 -> Class6 -> Class5 -> Class2 -> Class1
# Получить кортеж со всей цепочкой наследования позволяет атрибут __mro__ объекта определения класса:
# print(Class7.__mro__)
# Результат выполнения:
# (<class '__main__.Class7'>, <class '__main__.Class4'>, <class '__main__.Class3'>, <class '__main__.Class6'>,
# <class '__main__.Class5'>, <class '__main__.Class2'>, <class '__main__.Class1'>, <class 'object'>)


# 13.4.1.1. Примеси и их использование
print('13.4.1.1. Примеси и их использование')
# Примесь - это класс, предназначенный исключительно для расширения функциональности других классов путем добавления в
# них атрибутов и методов с помощью множественного наследования. Примеси определяются так же, как и обычные классы
# (поскольку ничем от них не отличаются).
# В качестве примера создадим класс-примесь Mixin, после чего создадим еще два класса, добавим к их функциональности
# ту, что определена в примеси Mixin, и проверим ее в действии test_00100.py.
# Примеси активно применяются в различных дополнительных библиотеках - в частности, в популярном веб-фреймворке Django.


# 13.5. Специальные методы
print('13.5. Специальные методы')
# Специальные методы вызываются самим интерпретатором в определенные моменты времени. Два специальных метода -
# конструктор и деструктор - были рассмотрены в разд. 13.3. Помимо них, поддерживаются еще следующие:
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

# 257

