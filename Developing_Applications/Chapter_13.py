#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ГЛАВА 13
print('ГЛАВА 13')
# Объекты и классы
print('Объекты и классы')
# Объект - это сложная структура, хранящая множество каких-либо значений и содержащая инструменты для их обработки.
# Отдельные значения хранятся в атрибутах - переменных, входящих в состав объекта, а инструменты реализованы в виде
# методов - функций, которые также принадлежат объекту.
# Все значения, обрабатываемые Python, представляют собой объекты. Например, строка является объектом, содержащим методы
# format(), strip(), split() и многие другие. Значение даты также является объектом с атрибутами year, month, day,
# методами weelday(), isoformat() и др..
# Класс - это образец, на основе которого создаются объекты, относящиеся к одной разновидности. Класс определяет набор
# атрибутов и методов, поддерживаемых объектами соответствующей разновидности. Например, объекты строк принадлежат
# классу, носящему имя str (как и строковый тип данных), а объекты дат - классу date.
# Стандартная библиотека Python содержит множество классов, называемых встроенными.
# Кроме того, разработчики могут создавать свои, пользовательские классы.


# 13.1. Определение классов, создание объектов и работа с ними
print('13.1. Определение классов, создание объектов и работа с ними')
# Инструкция создания, или определения, пользовательского класса записывается в следующем формате:
# class <Имя класса>:
#   [<Строка документирования>]
#   <Определения методов>
# Имя класса должно удовлетворять тем же требованиям, что и имена переменных.
# Дело в том, что, обработав определение класса, интерпретатор создает переменную, чье имя совпадает с именем созданного
# класса, и присваивает ей определение этого класса (которое также представляет собой объект).
# Определения методов записываются в том же формате, что и определения функций. Первым (или единственным) параметром
# каждый метод должен принимать ссылку на текущий объект этого класса (чтобы в теле метода можно было обратиться к
# атрибутам и методам текущего объекта). Традиционно этому параметру дают имя self.
# Атрибуты создаются в теле методов простым присваиванием им значений, для чего применяются инструкции формата:
# <Объект>.<Атрибут> = <Значение атрибута>
# В качестве <Объекта> следует использовать значение первого параметра, полученного методом (как отмечалось ранее,
# обычно его называют self).
# Кроме того, внутри методов можно обращаться к созданным ранее атрибутам текущего объекта с целью получить их значения,
# применяя следующий синтаксис (известный под названием точечной нотации):
# <Объект>.<Атрибут>
# и вызывать методы, использовав выражение формата:
# <Объект>.<Метод>([Параметры через запятую])
# При вызове метода следует указать только значения второго и последующих параметров, передаваемых ему. Значение первого
# параметра (self) - ссылка на текущий объект - будет передано методу самим интерпретатором.
# Определения классов должны предшествовать инструкциям, создающим на их основе объекты. Как правило, определения класса
# располагают в начале модуля или в отдельном модуле, отделяют от остального кода и друг от друга пустыми строками - для
# наглядности.
# При вводе определения класса в интерпретаторе, работающем в интерактивном режиме, после ввода языковой конструкции
# class и нажатия клавиши <Enter> последующие строки станут выводиться с отступом слева, и можно будет занести строку
# документирования, определения атрибутов и методов. При вводе определения метода после набора языковой конструкции def
# следующие строки станут выводиться с двойным отступом слева, и можно будет занести тело метода. Завершив ввод тела
# очередного метода, следует уменьшить отступ нажатием клавиши <Backspace>, чтобы ввести языковую конструкцию def
# определения следующего метода. Завершив ввод всех методов, нужно нажать <Enter> дважды, чтобы закончить ввод
# определения класса.
# Пример определения класса Platform, содержащего атрибуты name (название программной платформы) и type (тип платформы:
# клиентская или серверная, изначальное значение: 'Серверная'), методы set_name(<Название>) (задает новое название у
# текущей платформы) и get_full_name() (возвращает строку с названием и типом текущей платформы):


class Platform:
    def set_name(self, name):
        self.name = name         # Создаем атрибут name
        self.type = 'Серверная'  # Создаем атрибут type

    def get_full_name(self):
        return self.name + ' (' + self.type + ')'


# Определив класс, на его основе можно создать произвольное количество объектов. Для создания объекта класса примеряется
# следующий синтаксис:
# <Класс>()
# Возвращенный объект класса необходимо присвоить какой-либо переменной, атрибуту другого объекта, передать в качестве
# параметра функции или методу. Если этого не сделать, созданный объект будет потерян.
# Для примера создадим пару объектов только что определенного класса Platform:
p11 = Platform()
p12 = Platform()
# Для обращения к атрибутам и методам объекта применяется точечная нотация, описанная ранее. Укажем у первого из
# созданных объектов название платформы (вызовом метода set_name()),а у второго-название и тип (который занесем в
# атрибут type):
p11.set_name('Python')      # Указываем значение второго параметра метода
p12.set_name('JavaScript')  # Значение первого параметра(ссылка на текущий объект) будет передано методу интерпретатором
p12.type = 'Клиентская'
print(p12.get_full_name())  # Выведет: JavaScript (Клиентская)
print(p11.get_full_name())  # Выведет: Python (Серверная)
# В обычном коде можно создавать у объекта принадлежащие исключительно ему атрибуты (атрибуты экземпляра объекта),
# просто присваивая им значения. Создадим у второго объекта класса Platform атрибут экземпляра объекта founded, хранящий
# год создания платформы:
p12.founded = 1995
print(p12.founded)  # Выведет: 1995
# print(p11.founded)  # У первого объекта атрибута founded нет
# File '/Chapter_13.py', line 91
#     ... Фрагмент пропущен ...
#     ^
# SyntaxError: invalid syntax
# Удалить ненужный атрибут можно, использовав языковую конструкцию del и записав в ней удаляемый атрибут в формате:
# <Объект>.<Атрибут>:
# del p11.founded
# Для работы с атрибутами можно использовать следующие функции:
# - getattr() - возвращает значение атрибута с заданным в виде строки именем, принадлежащего указанному объекту. Формат
# функции:
# getattr(<Объект>, <Имя атрибута>[, <Значение по умолчанию>])
# Если атрибут с указанным именем не найден, генерируется исключение AttributeError. Чтобы избежать этого, в третьем
# параметре можно указать значение по умолчанию, возвращаемое, если атрибут не существует;
# - setattr() - заносит указанное значение в атрибут с указанным именем, принадлежащий заданному объекту. Формат
# функции:
# setattr(<Объект>, <Имя атрибута>, <Значение>)
# Вторым параметром можно передать имя несуществующего атрибута - в этом случае будет создан атрибут экземпляра объекта
# с таким именем;
# - delattr(<Объект>, <Имя атрибута>) - удаляет из заданного объекта атрибут, чье имя указано в виде строки;
# - hasattr(<Объект>, <Имя атрибута>) - возвращает True, если атрибут с именем, указанным в виде строки, существует в
# заданном объекте, и False - в противном случае.
# Примеры использования этих функций:
print(getattr(p11, 'type'))  # Выведет: Серверная
# print(getattr(p11, 'version'))
# Traceback (most recent call last):
#   File '/Chapter_13.py', line 114, in <module>
#     print(getattr(p11, 'version'))
#           ^^^^^^^^^^^^^^^^^^^^^^^
# AttributeError: 'Platform' object has no attribute 'version'
print(getattr(p11, 'version', '0.0'))  # Выведет: 0.0
setattr(p11, 'version', '1.0')
print(p11.version)                     # Выведет: 1.0
print(hasattr(p12, 'founded'))         # Выведет: True
delattr(p12, 'founded')
print(hasattr(p12, 'founded'))         # Выведет: False
# Любые атрибуты и методы, определенные в классе, доступны как изнутри этого класса, так и извне его. Такие атрибуты и
# методы называются общедоступными. Исключение составляют лишь атрибуты и методы, чьи имена начинаются с двойного
# подчеркивания (__) - они доступны только внутри класса (закрытые атрибуты и методы). Закрытые атрибуты и методы будут
# описаны далее.
# Определение класса представляет собой объект типа type:
print(type(Platform))          # Выведет: <class 'type'>
print(type(Platform) is type)  # Выведет: True


# 13.2. Атрибуты класса
print('13.2. Атрибуты класса')
# У класса можно создать атрибуты, принадлежащие самому классу, а не создаваемым на его основе объектам (атрибуты
# класса). Для этого применяется расширенный синтаксис определения класса:
# class <Имя класса>:
#   [<Строка документирования>]
#   [<Определения атрибутов класса>]
#   <Определения методов>
# Определение отдельного атрибута класса записывается в формате:
# <Имя атрибута> = <Значение атрибута>
# Пример класса, содержащего два атрибута класса:


class Python:
    type = 'Язык программирования'
    version = '3.10.1'


# Получить доступ к атрибутам класса можно как через сам класс (наиболее часто используемый вариант):
print(Python.type)         # Выведет: Язык программирования
Python.version = '3.12.1'
print(Python.version)      # Выведет: 3.12.1
# так и через объекты этого класса:
p = Python()
print(p.type)
# Однако если попытаться изменить значение атрибута класса через объект, в этом объекте будет создан одноименный атрибут
# экземпляра объекта:
p.type = 'Среда разработки'
# Якобы меняем значение атрибута класса type В результате будет создан одноименный атрибут экземпляра объекта
print(p.type)   # Среда разработки
p2 = Python()   # Создаем еще один объект класса Python
print(p2.type)  # Проверяем значение атрибута класса type
# Атрибут класса будет хранить одно и то же значение у всех объектов этого класса. Так, если в атрибуте класса сохранить
# список, все объекты этого класса станут ссылаться на один и тот же объект списка, например:


class Platforms:
    platform_list = []  # Атрибут класса, хранящий список


pls1 = Platforms()
pls2 = Platforms()
# Добавляем элемент в список через первый объект
pls1.platform_list.append('Python')
# Добавляем элемент в список через второй объект
pls2.platform_list.append('JavaScript')
# И убеждаемся, что оба объекта ссылаются на один и тот же список
print(pls1.platform_list)  # Выведет: ['Python', 'JavaScript']
print(pls2.platform_list)  # Выведет: ['Python', 'JavaScript']


# 13.3. Конструкторы и деструкторы
print('13.3. Конструкторы и деструкторы')
# В определении класса можно указать два метода, имеющих специальное назначение:
# - __init__() - конструктор - автоматически вызывается при создании объекта текущего класса.
# Первым параметром конструктору, как и другим методам, передается ссылка на текущий объект. Остальными параметрами
# можно передать любые значения, которые могут быть занесены в атрибуты создаваемого объекта или использованы в
# вычислениях.
# Для создания объекта класса, имеющего конструктор, применяется инструкция следующего формата:
# <Класс>([<Значения параметров через запятую>]])
# Указанные значения параметров будут переданы конструктору;
# - __del__() - деструктор - автоматически вызывается перед уничтожением объекта текущего класса, когда перестает
# существовать последняя ссылка на этот объект. Должен принимать один параметр - ссылку на текущий объект.
# Пример класса с конструктором и деструктором показан в test_00094.py.


# 13.4. Наследование
print('13.4. Наследование')
# Наследование - это создание одного класса (производного, или подкласса) на основе другого (базового, или суперкласса).
# Производный класс получает все атрибуты и методы, присутствующие в базовом классе.
# Для определения производного класса применяется инструкция следующего формата:
# class <Имя класса>(<Базовый класс>):
#   <Остальная часть определения класса>
# Если и в базовом, и в производном классе присутствуют методы с одинаковыми именами, при вызове такого метода из
# объекта производного класса будет вызван метод производного класса. То есть метод производного класса произведет
# перекрытие одноименного метода из базового класса. Рассмотрим пример из test_00095.py.
# Однако на практике чаще приходится не полностью заменять какой-либо метод базового класса в производном классе, а
# дополнять его функциональность - производить переопределение метода. В теле переопределяемого метода производного
# класса записывается код, реализующий дополнительную функциональность, и в нужном месте этого кода ставится инструкция
# вызова метода базового класса. Для вызова метода базового класса из метода производного класса можно использовать одну
# из следующих инструкций:
# - вызов функции super() - с применением выражения формата:
# super([<Производный класс>, <Ссыпка на текущий объект>]).<Вызов метода базового класса>
# В вызове метода базового класса первый параметр, содержащий ссылку на текущий объект, не указывается.
# У самой функции super() параметры указываются редко, в крайне специфических случаях;
# - <Базовый класс>.<Вызов метода базового класса>
# Здесь в вызове метода базового класса, напротив, следует передать первый параметр, содержащий ссылку на текущий
# объект.
# Рассмотрим пример переопределения двух методов базового класса в производном классе двумя только что описанными
# способами test_00096.py.


# 13.4.1. Множественное наследование
print('13.4.1. Множественное наследование')
# При множественном наследовании производный класс наследует сразу от нескольких базовых классов.
# Для множественного наследования применяется инструкция следующего формата:
# class <Имя класса>(<Базовые классы через запятую>):
#   <Остальная часть определения класса>
# При обращении в производном классе к атрибуту или методу, определенному в одном из базовых классов, просмотр базовых
# классов будет выполняться в том порядке, в котором они указаны.
# Рассмотрим множественное наследование на примере test_00097.py.
# Метод func_one() определен в двух классах: Class1 и Class3. Так как вначале просматриваются все базовые классы,
# непосредственно указанные в определении текущего класса, метод func_one() будет найден в классе Class3 (поскольку он
# указан в числе базовых классов в определении Class4), а не в классе Class1.
# Метод func_two() также определен в двух классах: Class2 и Class3. Так как класс Class2 стоит первым в списке базовых
# классов, то метод будет найден именно в нем. Чтобы наследовать метод из класса Class3, следует указать это явным
# образом. Переделаем определение класса Class4 из предыдущего примера и наследуем метод func_two() из класса Class3
# test_00098.py.
# Рассмотрим порядок поиска идентификаторов при сложной иерархии множественного наследования test_00099.py.
# Последовательность поиска атрибута х будет такой:
# Class7 -> Class4 -> Class3 -> Class6 -> Class5 -> Class2 -> Class1
# Получить кортеж со всей цепочкой наследования позволяет атрибут __mro__ объекта определения класса:
# print(Class7.__mro__)
# Результат выполнения:
# (<class '__main__.Class7'>, <class '__main__.Class4'>, <class '__main__.Class3'>, <class '__main__.Class6'>,
# <class '__main__.Class5'>, <class '__main__.Class2'>, <class '__main__.Class1'>, <class 'object'>)


# 13.4.1.1. Примеси и их использование
print('13.4.1.1. Примеси и их использование')
# Примесь - это класс, предназначенный исключительно для расширения функциональности других классов путем добавления в
# них атрибутов и методов с помощью множественного наследования. Примеси определяются так же, как и обычные классы
# (поскольку ничем от них не отличаются).
# В качестве примера создадим класс-примесь Mixin, после чего создадим еще два класса, добавим к их функциональности
# ту, что определена в примеси Mixin, и проверим ее в действии test_00100.py.
# Примеси активно применяются в различных дополнительных библиотеках - в частности, в популярном веб-фреймворке Django.


# 13.5. Специальные методы
print('13.5. Специальные методы')
# Специальные методы вызываются самим интерпретатором в определенные моменты времени. Два специальных метода -
# конструктор и деструктор - были рассмотрены в разд. 13.3. Помимо них, поддерживаются еще следующие:


# - __call__() - вызывается при вызове текущего объекта с применением того же синтаксиса, что используется при вызове
# функции. Формат метода:
# __call__(self[, <Параметр 1>[, ..., <Параметр N>]])
class MyClass:
    def __init__(self, m):
        self.msg = m

    def __call__(self, new_value=None):
        if new_value:
            print(new_value)
        else:
            print(self.msg)


c1 = MyClass('Значение1')  # Создание объекта
c2 = MyClass('Значение2')  # Создание объекта
c1()                       # Выведет: Значение1
c2()                       # Выведет: Значение2
c2('Новое значение')       # Выведет: Новое значение


# - __getattr__(self, <Имя атрибута>) - вызывается при обращении к несуществующему атрибуту текущего объекта:
class MyClass:
    def __init__(self):
        self.i = 20

    def __getattr__(self, item):
        print('Вызван метод __getattr__()')
        return 0


c = MyClass()
# Атрибут i существует
print(c.i)  # Выведет: 20. Метод _getattr_() не вызывается
# Атрибут s не существует
print(c.s)  # Выведет: Вызван метод _getattr_() О


# __getattribute__(self, <Имя атрибута>) - вызывается при обращении к любому, даже существующему атрибуту текущего
# объекта. Необходимо учитывать, что использование точечной нотации (для обращения к атрибутам) внутри этого метода
# приведет к зацикливанию. Чтобы избежать зацикливания, следует вызвать метод __getattribute__() объекта object и внутри
# этого метода вернуть значение атрибута или сгенерировать исключение AttributeError. Пример:
class MyClass:
    def __init__(self):
        self.i = 20
    
    def __getattribute__(self, attr):
        print('Вызван метод __getattribute__()')
        return object.__getattribute__(self, attr)  # Только так!!!


c = MyClass()
print(c.i)  # Выведет: Вызван метод __getattribute__() 20


# - __setattr__(self, <Имя атрибута>, <Значение>) - вызывается при попытке присваивания значения атрибуту текущего
# объекта. Если внутри метода необходимо присвоить значение атрибуту, следует использовать словарь из атрибута __dict__,
# поскольку при применении точечной нотации метод __setattr__() будет вызван повторно, что приведет к зацикливанию.
# Пример:
class MyClass:
    def __setattr__(self, attr, value):
        print('Вызван метод __setattr__()')
        self.__dict__[attr] = value          # Только так!!!


c = MyClass()
c.i = 10    # Выведет: Вызван метод __setattr__()
print(c.i)  # Выведет: 10


# - __delattr__(self, <Имя атрибута>) - вызывается при удалении атрибута текущего объекта с помощью инструкции
# del <Объект>.<Атрибут>;
# - __len__(self) - вызывается при использовании функции len() применительно к текущему объекту, а также для проверки
# объекта на логическое значение при отсутствии в классе метода __bool__(). Метод должен возвращать положительное целое
# число. Пример:
class MyClass:
    def __len__(self):
        return 50


c = MyClass()
print(len(c))  # Выведет: 50


# - __bool__(self) - вызывается при использовании функции bool() применительно к текущему объекту. Должен возвращать
# логическое значение;

# - __int__(self) - вызывается при преобразовании текущего объекта в целое число с помощью функции int(). Должен
# возвращать целое число;

# - __float__(self) - вызывается при преобразовании текущего объекта в вещественное число с помощью функции float().
# Должен возвращать вещественное число;

# - __complex__(self) - вызывается при преобразовании текущего объекта в комплексное число с помощью функции complex().
# Должен возвращать комплексное число;

# - __round__(self, n) - вызывается при округлении текущего объекта функцией round(). Должен возвращать вещественное
# число;

# - __index__(self) - вызывается при преобразовании текущего объекта в целое число при извлечении среза, вызове функций
# bin(), oct() или hex(). Должен возвращать целое число;

# - __str__(self) - вызывается при использовании функций str() и print() применительно к текущему объекту. Должен
# возвращать строку. Если отсутствует, будет использован метод __repr__() (описан далее). Пример:
class MyClass:
    def __init__(self, m):
        self.msg = m
        
    def __str__(self):
        return 'Вызван метод __str__() {0}'.format(self.msg)


c = MyClass('Значение')
print(str(c))  # Выведет: Вызван метод __str__() Значение
print(c)       # Выведет: Вызван метод __str__() Значение


# - __repr__(self) - вызывается при выводе текущего объекта интерпретатором, работающим в интерактивном режиме, и
# использовании функции repr() применительно к текущему объекту. Должен возвращать строку. Пример:
class MyClass:
    def __init__(self, m):
        self.msg = m

    def __repr__(self):
        return 'Вызван метод __repr__() {0}'.format(self.msg)


c = MyClass('Значение')
print(repr(c))  # Выведет: Вызван метод __repr__() Значение


# - __hash__(self) - должен возвращать строковое представление текущего объекта, содержащее только цифры. Такое
# представление можно получить, использовав функцию hash(<Значение>). Этот метод следует переопределить, если объекты
# текущего класса планируется использовать в качестве ключей словаря или внутри множества. Пример:
class MyClass:
    def __init__(self, y):
        self.x = y

    def __hash__(self):
        return hash(self.x)


c = MyClass(10)
d = dict()
d[c] = 'Значение'
print(d[c])  # Выведет: Значение
# Классы поддерживают еще несколько специальных методов, которые применяются лишь в особых случаях и будут рассмотрены в
# главе 15.


# 13.6. Перегрузка операторов
print('13.6. Перегрузка операторов')
# Перегрузкой оператора называется изменение функциональности какого-либо из операторов, поддерживаемых Python,
# применительно к объектам определенного класса. Чтобы перегрузить оператор, необходимо в классе определить
# соответствующий специальный метод.
# Для перегрузки математических операторов используются следующие методы:
# - х + у - сложение: х.__add__(у);
# - у + х - сложение (объект класса справа): х.__radd__(у);
# - х += у - сложение и присваивание: х.__iadd__(у);
# - х - у - вычитание: х.__sub__(у);
# - у - х - вычитание (объект класса справа): х.__rsub__(у);
# - х -= у - вычитание и присваивание: х.__isub__(у);
# - х * у - умножение: x.__mul__(y);
# - у * х - умножение (объект класса справа): x.__rmul__(y);
# - х *= у - умножение и присваивание: x.__imul__(y);
# - х / у - деление: х.__truediv__(у);
# - у / х - деление (объект класса справа): х.__rtruediv__(у);
# - х /= у - деление и присваивание: x.__itruediv__(y);
# - х // у - деление с округлением вниз: х.__floordiv__(у);
# - у // х - деление с округлением вниз (объект класса справа): x.__rfloordiv__(у);
# - х //= у - деление с округлением вниз и присваивание: x.__ifloordiv__(y);
# - х % у - остаток от деления: х.__mod__(у);
# - у % х - остаток от деления (объект класса справа): х.__rmod__(у);
# - х %= у - остаток от деления и присваивание: х.__imod__(у);
# - х ** у - возведение в степень: х.__pоw__(у);
# - у ** х - возведение в степень (объект класса справа): х.__rpow__(у);
# - х **= у - возведение в степень и присваивание: х.__ipow__(у);
# - -х - унарный минус: х.__neg__();
# - +х - унарный плюс: х.__pos__();
# - abs(х) - абсолютное значение: х.__abs__().
# Пример перегрузки математических операторов приведен в test_00101.py.
# Специальные методы для перегрузки двоичных операторов:
# - ~х - двоичная инверсия: х.__invert__();
# - х & у - двоичное И: х.__and__(у);
# - у & х - двоичное И (объект класса справа): x.__rand__(y);
# - х &= у - двоичное И и присваивание: х.__iand__(у);
# - х | у - двоичное ИЛИ: х.__or__(у);
# - y | х - двоичное ИЛИ (объект класса справа): x.__ror__(у);
# - х |= у - двоичное ИЛИ и присваивание: x.__ior__(y);
# - х ^ у - двоичное исключающее ИЛИ: х.__xor__(у);
# - у ^ х - двоичное исключающее ИЛИ (объект класса справа): x.__rxor__(y);
# - х ^= у - двоичное исключающее ИЛИ и присваивание: х.__ixor__(у);
# - х << у - сдвиг влево: х.__lshift__(у);
# - у << х - сдвиг влево (объект класса справа): x.__rlshift__(y);
# - х <<= у - сдвиг влево и присваивание: x.__ilshift__(y);
# - х >> у - сдвиг вправо: х.__rshift__(у);
# - у >> х - сдвиг вправо (объект класса справа): x.__rrshift__(у);
# - х >>= у - сдвиг вправо и присваивание: x.__irshift__(y).
# Перегрузка операторов сравнения производится с помощью следующих специальных методов:
# - х == у - равно: x.__eq__(y);
# - х != у - не равно: x.__ne__(y);
# - х < у - меньше: х.__lt__(у);
# - х > у - больше: x.__gt__(y);
# - х <= у - меньше или равно: х.__lе__(у);
# - х >= у - больше или равно: x.__ge__(y);
# - у in х - проверка на вхождение: х.__contains__(у).
# Пример перегрузки операторов сравнения приведен в test_00102.py.


# 13.7. Статические методы и методы класса
print('13.7. Статические методы и методы класса')
# Статический метод - это метод, принадлежащий классу, а не объекту. Создается он так же, как и обычный метод, только
# перед его определением указывается декоратор @staticmethod. Ссылка на текущий объект с первым параметром такому методу
# не передается, поэтому в теле статического метода невозможно получить доступ к обычным атрибутам и методам.
# Статический метод можно вызвать как непосредственно у класса, записав инструкцию формата:
# <Класс>.<Метод>([<Параметры через запятую>])
# так и у любого объекта этого класса - посредством выражений формата, приведенного в разд. 13.1.
# Пример использования статических методов показан в test_00103.py.
# Метод класса похож на статический, только ему первым параметром передается ссылка на текущий класс (не объект). Перед
# определением метода класса следует поставить декоратор @classmethod. Пример использования методов класса приведен в
# test_00104.py.
# Статические методы и методы класса часто применяются для выполнения каких-либо вычислений общего характера или для
# создания специфических объектов класса, содержащих определенные значения в своих атрибутах.


# 13.8. Абстрактные методы
print('13.8. Абстрактные методы')
# Абстрактный метод предназначен не для непосредственного вызова, а для перекрытия в производных классах. В качестве
# тела такого метода указывается инструкция с пустым оператором pass (описан в разд. 3.5), а перед его определением
# ставится декоратор @abstractmethod из модуля abc. Кроме того, класс, содержащий абстрактные методы, должен быть
# производным от класса АВС из того же модуля.
# При попытке создать объект производного класса, в котором не перекрыт абстрактный метод, генерируется исключение
# TypeError. Следует помнить, что это исключение генерируется только в том случае, если класс с абстрактными методами
# является производным от класса АВС (в противном случае ничего не происходит). Рассмотрим определение абстрактных
# методов на примере test_00105.py.
# Можно создавать абстрактные статические методы и абстрактные методы класса, для чего необходимые декораторы
# указываются одновременно, друг за другом test_00106.py.


# 13.9. Закрытые атрибуты и методы
print('13.9. Закрытые атрибуты и методы')
# Закрытые атрибуты и методы, в отличие от общедоступных, доступны лишь внутри класса, из его собственных методов. При
# попытке обратиться к закрытому атрибуту или методу извне класса генерируется исключение AttributeError.
# Превратить атрибут или метод в закрытый можно, предварив его имя двойным символом подчеркивания (__). Пример:


class MyClass:
    def __init__(self, a):
        self.__a = a  # Закрытый атрибут

    def __func(self):
        print(self.__a)  # Закрытый метод

    def func(self):    # Общедоступный метод
        self.__func()  # Вызываем закрытый метод из общедоступного


obj = MyClass(123)
# print(obj.__a)       # Пытаемся получить значение закрытого атрибута - ошибка
# Traceback (most recent call last):
#   File "/media/Samsung/Programming/Python/Scripts/Developing_Applications/Chapter_13.py", line 524, in <module>
#     print(obj.__a)       # Пытаемся получить значение закрытого атрибута - ошибка
#           ^^^^^^^
# AttributeError: 'MyClass' object has no attribute '__a'
# print(obj.__func())  # Пытаемся вызвать закрытый метод - ошибка
# Traceback (most recent call last):
#   File "/media/Samsung/Programming/Python/Scripts/Developing_Applications/Chapter_13.py", line 530, in <module>
#     print(obj.__func())  # Пытаемся вызвать закрытый метод - ошибка
#           ^^^^^^^^^^
# AttributeError: 'MyClass' object has no attribute '__func'. Did you mean: 'func'?
print(obj.func())
# Тем не менее доступ к закрытым атрибутам и методам все же можно получить извне класса, обратившись по идентификатору
# формата:
# _<Имя класса>__<Имя атрибута или метода без двойного подчеркивания>
print(obj._MyClass__a)       # Получаем значение закрытого атрибута __a
print(obj._MyClass__func())  # Вызываем закрытый метод _func()
# Также можно указать набор атрибутов (но, к сожалению, не методов), которые будут доступны извне класса (остальные
# атрибуты автоматически станут закрытыми). Список со строковыми именами этих атрибутов следует присвоить атрибуту
# класса __slots__, а если общедоступным планируется сделать лишь один атрибут, можно присвоить строку с его именем.
# Пример показан в test_00107.py.


# 13.10. Свойства
print('13.10. Свойства')
# Свойство - это своего рода атрибут, при обращении к которому вызывается один из трех следующих методов, определенных в
# классе:
# - геттер - вызывается при попытке получить значение свойства. Должен возвращать результат, который и станет значением
# свойства;
# Обычно геттер возвращает значение, хранящееся в каком-либо закрытом атрибуте. Однако иногда он вычисляет возвращаемое
# значение, основываясь на содержимом других атрибутов.
# Если геттер отсутствует, свойство не будет доступно на чтение;
# - сеттер - вызывается при попытке присвоить свойству новое значение. Должен принимать в качестве параметра новое
# значение и не должен возвращать результат.
# Обычно сеттер заносит новое значение свойства в специально предназначенный для его хранения закрытый атрибут. Помимо
# этого, он может выполнять какие-либо дополнительные действия.
# Если сеттер отсутствует, свойство не будет доступно для записи;
# - делетер - вызывается при попытке удалить свойство.
# Обычно делетер либо удаляет закрытый атрибут, в котором хранится значение свойства, либо заносит в него значение None.
# Также он может выполнять какие-либо дополнительные действия.
# Если делетер отсутствует, свойство будет невозможно удалить.
# Свойство создается вызовом функции property(). Формат функции:
# property(fget=None][, ][fset=None[, ][fdel=None] [, ][doc=None])
# Параметр fget задает геттер, параметр fset - сеттер, fdel - делетер, doc - строку документирования.
# В качестве результата возвращается объект, представляющий созданное свойство, который сразу следует сохранить в
# каком-либо атрибуте класса. Через этот атрибут и будет в дальнейшем выполняться доступ к свойству. Рассмотрим создание
# свойства на примере test_00108.py.
# Также поддерживается альтернативный способ создания свойств. Сначала у будущего геттера указывается декоратор
# property, после чего объект геттера получает поддержку методов setter() и deleter(). Далее у будущего сеттера следует
# вызвать упомянутый ранее метод setter() геттера в качестве декоратора, а у будущего делетера - точно таким же образом
# вызвать метод deleter() геттера. Соответствующий пример приведен в test_00109.py.
# Можно создать абстрактное свойство - в этом случае все реализующие его методы должны быть переопределены в производном
# классе. Абстрактное свойство создается с помощью декоратора @abstractmethod и класса ABC из модуля abc
# (см. разд. 13.8). Пример показан в test_00110.py.


# 13.11. Декораторы классов
print('13.11. Декораторы классов')
# Помимо декораторов функций, Python поддерживает декораторы классов - функции, изменяющие поведение самих классов.
# В качестве параметра декоратор класса должен принимать ссылку на класс, поведение которого необходимо изменить, и
# должен возвращать ссылку на тот же класс или какой-либо другой. Пример декорирования класса показан в test_00111.py.
