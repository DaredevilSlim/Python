#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ГЛАВА 14
print('ГЛАВА 14')
# Исключения и их обработка
print('Исключения и их обработка')
# Исключение - это объект, генерируемый интерпретатором Python в случае возникновения ошибки и хранящий сведения о ней.
# Обработка, или перехват, исключения - это реагирование на его возникновение с целью ликвидировать последствия ошибки.
# В программе могут возникать ошибки трех типов:
# - синтаксические - ошибки в синтаксисе кода: неправильное написание языковых конструкций, идентификаторов, отсутствие
# закрывающей или открывающей кавычек и т. д. Как правило, интерпретатор предупреждает о наличии такой ошибки, и
# выполнение программы прерывается. Пример синтаксической ошибки:
# print("Нет завершающей кавычки!)
# File "/Chapter_14.py", line 14
#     print("Нет завершающей кавычки!)
#           ^
# SyntaxError: unterminated string literal (detected at line 14)
# - логические - ошибки в логике программы. Как правило, интерпретатор не предупреждает о наличии такой ошибки, и
# программа успешно выполняется, но выданный ею результат оказывается не тем, на который мы рассчитывали. Выявить и
# исправить такие ошибки весьма трудно;
# - ошибки времени выполнения - ошибки, возникающие во время работы программы вследствие событий, которые не были
# предусмотрены программистом. Классическим примером служит деление на ноль:


def test(x, y):
    return x / y


print(test(4, 2))  # Нормально
# print(test(4, 0))  # Ошибка
# Traceback (most recent call last):
#   File "/Chapter_14.py", line 31, in <module>
#     print(test(4, 0))  # Нормально
#           ^^^^^^^^^^
#   File "/Chapter_14.py", line 27, in test
#     return x / y
#            ~~^~~
# ZeroDivisionError: division by zero
# В Python исключения также генерируются в качестве уведомлений о наступлении каких-либо событий. Например, метод
# index() генерирует исключение ValueError, если искомый фрагмент не входит в обрабатываемую строку:
# print('Строка'.index('текст'))
# Traceback (most recent call last):
#   File "/Chapter_14.py", line 42, in <module>
#     print('Строка'.index('текст'))
#           ^^^^^^^^^^^^^^^^^^^^^^^
# ValueError: substring not found


# 14.1. Обработчики исключений
print('14.1. Обработчики исключений')
# Обработчик исключений - инструкция, предназначенная для обработки исключений. Формат этой инструкции:
# try:
#   <Блок, в котором могут возникать исключения>
# except [<Класс исключения 1>[as <Переменная>]]:
#   <Блок, выполняемый при возникновении исключений класса 1>
# ...,
# except [<Класс исключения N>[as <Переменная>]]:
# <Блок, выполняемый при возникновении исключения класса N>
# else:
#   <Блок, выполняемый, если исключение не возникло>]
# finally:
#   <Блок, выполняемый в любом случае>]
# Языковых конструкций except может быть произвольное количество. В переменную, указанную в конструкции except, будет
# занесен объект исключения, и в соответствующем блоке можно будет извлечь из него какие-либо сведения о возникшем
# исключении.
# Пример обработки исключения класса zeroDivisionError, генерируемого при делении на ноль, приведен в test_00112.py.
# Один обработчик исключений можно вложить в другой. Если вложенный обработчик не обработал возникшее исключение, оно
# всплывет во «внешний» обработчик. Если исключение в программе вообще нигде не обрабатывается, оно будет передано
# обработчику по умолчанию, встроенному в интерпретатор, который остановит выполнение программы и выведет стандартное
# сообщение об ошибке. Пример вложенных обработчиков приведен в test_00113.py.
# В этом примере во вложенном обработчике не указано исключение ZeroDivisionError, по этому исключение «всплывет» в
# обработчике более высокого уровня.
# После обработки исключения выполняются инструкции, расположенные сразу после обработчика. В нашем примере выполнится
# инструкция, выводящая значение переменной х, - print(х). Инструкция print("Выражение после вложенного обработчика")
# выполнена не будет.
# В языковой конструкции except можно указать сразу несколько исключений, записав их через запятую внутри круглых скобок
# test_00114.py.
# Пример получения сведений об обрабатываемом исключении приведен в test_00115.py.
# Для получения сведений об исключении можно воспользоваться функцией exc_info() из модуля sys, которая возвращает
# кортеж из трех элементов: класса исключения, объекта исключения и объекта с трассировочной информацией. Преобразовать
# эти значения в удобочитаемый вид позволяет модуль traceback. Пример использования функции ехс_info() и модуля
# traceback приведен в test_00116.py.
# Если в языковой конструкции except не указан класс исключения, то записанный в ней блок будет перехватывать все
# исключения. На практике следует избегать пустых инструкций except, иначе можно перехватить исключение, которое
# является лишь сигналом системе, а не ошибкой. Пример перехвата всех исключений приведен в test_00117.py.
# Если в обработчике присутствует языковая конструкция else, то указанный в ней блок будет выполнен только при
# отсутствии ошибок. А блок в языковой конструкции finally выполнится вне зависимости от того, возникло исключение или
# нет. Для примера выведем последовательность выполнения этих блоков test_00118.py.
# Необходимо заметить, что при наличии исключения и отсутствии языковой конструкции except блок в конструкции finally
# будет выполнен, но исключение останется необработанным и «всплывет» в обработчике более высокого уровня. Если таковой
# отсутствует, исключение передается обработчику по умолчанию, который прервет выполнение программы и выведет сообщение
# об ошибке, например:
# try:
#     x = 10 / 0
# finally:
#     print('Блок finally')
# Traceback (most recent call last):
#   File "/Chapter_14.py", line 95, in <module>
#     x = 10 / 0
#         ~~~^~~
# ZeroDivisionError: division by zero
# Переделаем нашу программу суммирования произвольного количества целых чисел, введенных пользователем в test_00026.py,
# таким образом, чтобы при вводе строки вместо числа программа не завершалась с фатальной ошибкой test_00119.py.


# 14.2. Обработчики контекстов
print('14.2. Обработчики контекстов')
# Контекст - это объект, который следует создать, выполнить с ним заданные действия и корректно уничтожить, вне
# зависимости от того, возникли исключения при выполнении действий с ним или нет. Пример контекста - объект,
# представляющий файл, который в любом случае должен быть закрыт после работы с ним. Класс, на основе которого создается
# объект-контекст, называется менеджером контекста.
# Обработчик контекста - это выражение, создающее контекст (или сразу несколько таковых), выполняющее с ним заданные
# действия и самостоятельно уничтожающее его. Такое выражение записывается в любом из двух следующих форматов:
# with <Выражение, создающее контекст 1>[as <Переменная 1>]'
# ...,
#   <Выражение, создающее контекст N>[as <Переменная N>]]:
#   <Блок, работающий с созданными контекстами>
# with (<Выражение, создающее контекст 1>[as <Переменная 1>],
# ...,
#   <Выражение, создающее контекст N>[as <Переменная N>]]):
#   <Блок, работающий с созданными контекстами>
# Контексты, созданные заданными выражениями, заносятся в указанные переменные, и эти переменные будут доступны в блоке,
# который работает с созданными контекстами.
# Класс, являющийся менеджером контекста, должен поддерживать два специальных метода:
# - __enter__(self) - вызывается сразу после создания объекта текущего класса. Должен возвращать ссылку на созданный
# объект;
# - __exit__() - выполняется либо по завершении исполнения блока в выражении обработчика контекста (если исключение не
# возникло), либо сразу после возникновения исключения. Формат метода:
# __exit__(self, <Класс исключения>, <Объект исключения>, <Объект с трассировочной информацией>)
# Если исключение не возникло, последние три параметра получат значение None, и метод не должен возвращать результат.
# В противном случае метод должен вернуть значение True, если возникшее исключение было им обработано, или False, если
# он не обработал исключение (которое в этом случае будет передано вышестоящему обработчику).
# Пример обработчика контекста приведен в test_00120.py.
# Второй формат обработчиков контекстов (с круглыми скобками) поддерживается, начиная с Python 3.10, и позволяет
# разбивать языковую конструкцию with на несколько строк:
# with (Class1() as obj1, Class2() as obj2, Class3() as obj3, Class4() as obj4, Class5() as obj5):
# Некоторые встроенные классы (например, класс файла) также являются менеджерами контекста. Они будут рассмотрены в
# последующих главах.


# 14.3. Классы встроенных исключений
print('14.3. Классы встроенных исключений')
# Иерархия встроенных в Python классов исключений схематично выглядит так:
# BaseException
#   SystemExit
#   Keyboardinterrupt
#   GeneratorExit
#   Exception
#       Stopiteration
#       ArithmeticError
#           FloatingPointError, OverflowError, ZeroDivisionError
#       AssertionError
#       AttributeError
#       BufferError
#       EOFError
#       ImportError
#           ModuleNotFoundError
#       LookupError
#           IndexError, KeyError
#       MemoryError
#       NameError
#           UnboundLocalError
#       OSError
#           BlockingIOError
#           ChildProcessError
#           ConnectionError
#               BrokenPipeError, ConnectionAbortedError, ConnectionRefusedError, ConnectionResetError
#           FileExistsError
#           FileNotFoundError
#           InterruptedError
#           IsADirectoryError
#           NotADirectoryError
#           PermissionError
#           ProcessLookupError
#           TimeoutError
#       RuntimeError
#           NotimplementedError, RecursionError
#       SyntaxError
#           IndentationError
#               TabError
#       SystemError
#       TypeError
#       ValueError
#           UnicodeError
#               UnicodeDecodeError, UnicodeEncodeError
#               UnicodeTranslateError
#       Warning
#           BytesWarning, DeprecationWarning, FutureWarning, ImportWarning, PendingDeprecationWarning,
#           ResourceWarning, RuntimeWarning, SyntaxWarning, UnicodeWarning, UserWarning
# Можно указать базовый класс для перехвата всех исключений соответствующих производных классов. Например, указав
# базовый класс ArithmeticError, можно перехватывать исключения классов FloatingPointError, OverflowError и
# ZeroDivisionError:
# try:
#   х = 1 / 0              # Ошибка: деление на 0
# except ArithmeticError:  # Указываем базовый класс
#   print('Обработали деление на 0')
# Основные классы встроенных исключений:
# - BaseException - базовый класс для всех прочих классов исключений;
# - Exception - базовый класс для большинства исключений, встроенных в Python, а также пользовательских исключений;
# - AssertionError - генерируется языковой конструкцией assert;
# - AttributeError - попытка обращения к несуществующему атрибуту или методу объекта;
# - EOFError - достигнут конец файла, из которого выполняется чтение;
# - ImportError - невозможно выполнить импорт модуля или пакета вследствие ошибки в инструкции импорта;
# - IndentationError - неправильно расставлены отступы в программе;
# - IndexError - указанный индекс не существует в последовательности;
# - KeyError - указанный ключ не существует в отображении;
# - Keyboardinterrupt - нажата комбинация клавиш <Ctrl>+<C>;
# - MemoryError - интерпретатору существенно не хватает оперативной памяти, и он вынужден срочно удалить неиспользуемые
# объекты, чтобы освободить ее;
# - ModuleNotFoundError - импортируемый модуль или пакет не найден;
# - NameError - попытка обращения к несуществующему идентификатору;
# - NotimplementedError - попытка обращения к абстрактному методу;
# - OSError - базовый класс для всех исключений, генерируемых в ответ на возникновение системных ошибок (отсутствие
# запрошенного файла, недостаток места на диске и пр.);
# - overflowError - число, получившееся в результате выполнения арифметической операции, слишком велико, чтобы Python
# смог его обработать;
# - RecursionError - превышено максимальное количество проходов рекурсии;
# - RuntimeError - неклассифицированная ошибка времени выполнения;
# - Stopiteration - генерируется методом __next__() как сигнал об окончании итераций;
# - SyntaxError - синтаксическая ошибка;
# - SystemError - ошибка в самом интерпретаторе Python;
# - TabError - в программном коде встретился символ табуляции, использование которого для создания отступов недопустимо;
# - TypeError - тип объекта не соответствует ожидаемому;
# - UnboundLocalError - в теле функции создается локальная переменная после обращения к одноименной глобальной
# переменной;
# - UnicodeDecodeError - ошибка преобразования последовательности байтов в Unicode-строку;
# - UnicodeEncodeError - ошибка преобразования Unicode-строки в последовательность байтов;
# - UnicodeError - базовый класс для исключений, генерируемых при ошибке преобразования Unicode-строк в
# последовательности байтов и наоборот;
# - UnicodeTranslationError - ошибка преобразования Unicode-строки в другую кодировку;
# - ValueError - неприемлемое значение параметра, переданного функции или методу;
# - ZeroDivisionError - деление на ноль.


# 14.4. Генерирование исключений
print('14.4. Генерирование исключений')
# Для программного генерирования исключений предназначена инструкция, записываемая в одном из следующих форматов:
# raise <Объект исключения>
# raise <Класс исключения>
# raise <Объект или класс вторичного исключения> from <Объект первичного исключения>
# raise
# Первый формат генерирует исключение, чей объект указан в инструкции. При создании объекта исключения можно передать
# конструктору класса данные, которые могут быть извлечены в обработчике (см.разд. 14.1). Пример генерирования
# исключения ValueError:
# raise ValueError('Описание исключения')
# Traceback (most recent call last):
#   File "/Chapter_14.py", line 246, in <module>
#     raise ValueError('Описание исключения')
# ValueError: Описание исключения
# Пример обработки этого исключения показан в test_00121.py.
# Второй формат инструкции генерирует исключение на основе указанного класса, при этом объект исключения создается
# автоматически:
# try:
#   raise ValueError  # Эквивалентно: raise ValueError()
# except ValueError:
#   print ("Сообщение об ошибке")
# Третий формат инструкции при возникновении одного исключения (первичного) генерирует другое (вторичное). Первичное
# исключение сохраняется в атрибуте __cause__ объекта вторичного исключения. Пример использования этого формата можно
# увидеть в test_00122.py.
# Как видно из результата, мы получили информацию не только по исключению valueError, но и по исключению
# zeroDivisionError. Следует заметить, что при отсутствии языковой конструкции from информация о первичном исключении
# сохраняется в объекте вторичного исключения неявным образом. Если убрать конструкцию from в предыдущем примере, мы
# получим следующий результат:
# Traceback (most recent call last):
#   File "/test_00122.py", line 6, in <module>
#     x = 1 / 0
#         ~~^~~
# ZeroDivisionError: division by zero
#
# During handling of the above exception, another exception occurred:
#
# Traceback (most recent call last):
#   File "/test_00122.py", line 8, in <module>
#     raise ValueError() #from err
#     ^^^^^^^^^^^^^^^^^^
# ValueError
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
# 279
