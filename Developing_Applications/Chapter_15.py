#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from enum import Enum, unique, auto, IntEnum, Flag, IntFlag, EnumMeta

# ГЛАВА 15
print('ГЛАВА 15')
# Итераторы, контейнеры и перечисления
print('Итераторы, контейнеры и перечисления')
# Python позволяет создавать классы особого назначения: итераторы, контейнеры и перечисления.


# 15.1. Итераторы
print('15.1. Итераторы')
# Итератор - это класс, который при каждом обращении выдает очередной элемент заданной последовательности. Объект такого
# класса можно перебрать в цикле перебора последовательности. Можно сказать, что итератор аналогичен функции-генератору
# (см. разд. 11.3), только является классом.
# Чтобы превратить класс в итератор, следует переопределить в нем два специальных метода:
# - __iter__(self) - служит признаком того, что класс является итератором. Должен возвращать текущий объект.
# Как правило, этот метод выполняет всевозможные предустановки.
# Если в классе определены методы __iter__() и __getitem__() (о последнем будет рассказано позже), предпочтение отдается
# первому методу;
# - __next__(self) - вызывается при выполнении каждой итерации и должен возвращать очередной элемент последовательности.
# Если последовательность закончилась, в этом методе следует сгенерировать исключение StopIteration, которое сообщит
# вызывающему коду о завершении перебора.
# Рассмотрим класс, хранящий строку и на каждой итерации возвращающий очередной ее символ, начиная с конца в
# test_00127.py.
# Также мы можем переопределить специальный метод __len()__, возвращающий размер последовательности, и специальные
# методы __str()__ и __repr()__, выдающие строковое представление объекта (были рассмотрены в разд. 13.5). Перепишем код
# нашего класса итератора, добавив в него определение методов __len()__ и __str()__ в test_00128.py.
# Теперь мы можем получить длину последовательности, хранящейся в объекте класса ReverseString, и его строковое
# представление:


# 15.2. Контейнеры
print('15.2. Контейнеры')
# Контейнер - это класс с функциональностью либо пронумерованной последовательности (контейнер-последовательность) с
# произвольным доступом к любому ее элементу по его индексу, либо отображения (контейнер-отображение).


# 15.2.1. Контейнеры-последовательности
print('15.2.1. Контейнеры-последовательности')
# Чтобы превратить класс в контейнер-последовательность, следует переопределить в нем следующие специальные методы:
# - __getitem__(self, <Индекс>) - вызывается при извлечении элемента последовательности с заданным индексом и должен
# возвращать этот элемент. Если индекс не является целым числом или срезом, метод должен генерировать исключение
# TypeError, а если такого индекса не существует,- исключение IndexError;
# - __setitem__(self, <Индекс>, <Значение>) - вызывается в случае присваивания нового значения элементу
# последовательности с заданным индексом. Не должен возвращать результата. В случае задания индекса недопустимого типа
# или отсутствия такого индекса в последовательности метод должен генерировать те же исключения, что и метод
# __getitem__();
# - __delitem__(self, <Индекс>) - вызывается в случае удаления элемента последовательности с заданным индексом.
# Не должен возвращать результата. В случае задания индекса недопустимого типа или отсутствия такого индекса в
# последовательности метод должен генерировать те же исключения, что и метод __getitem__();
# - __contains__(self, <Значение>) - вызывается при проверке существования в последовательности элемента с заданным
# значением. Должен возвращать True, если такой элемент есть, и False - в противном случае.
# В контейнере-последовательности можно дополнительно реализовать функциональность итератора (см. разд. 15.1),
# переопределив специальные методы __iter__(), __next__() и __len__(). Чаще всего так и поступают.
# Мы давно знаем, что строки в Python являются неизменяемыми. Напишем класс MutableString, представляющий строку,
# которую можно изменять теми же способами, что и список в test_00129.py.
# Проверим, как наш класс обрабатывает нештатные ситуации, обратившись по несуществующему индексу:


# 15.2.2. Контейнеры-отображения
print('15.2.2. Контейнеры-отображения')
# Превратить класс в контейнер-отображение можно, переопределив описанные в разд. 15.2.1 методы: __getitem__(),
# __setitem__(), __delitem__() и __contains__(). При этом следует учесть, что вместо индексов здесь будут использоваться
# ключи произвольного типа (как правило, строкового). А при обращении по несуществующему ключу следует генерировать
# исключение KeyError.
# Напишем класс Version, который будет хранить версию интерпретатора Python, разбитую на части: старшая версия, младшая
# версия и модификация. Доступ к частям версии будет осуществляться по строковым ключам test_00130.py. Ради простоты
# функциональность итератора реализовывать не станем, а также заблокируем операцию удаления элемента словаря, генерируя
# в методе __delitem__() исключение NotimplementedError.


# 15.3. Перечисления
print('15.3. Перечисления')
# Перечисление - это набор каких-либо именованных значений, называемых элементами. Перечисление можно рассматривать как
# своего рода словарь, только неизменяемый. Перечисление представляет собой класс, содержащий непосредственные
# определения атрибутов класса, каждый из которых представляет один из элементов. Имя атрибута класса станет именем
# соответствующего элемента. Соглашения Python-программирования требуют, чтобы имена элементов перечисления были набраны
# в верхнем регистре.
# Соответственно, для доступа к нужному элементу перечисления следует обратиться к представляющему его атрибуту класса
# посредством привычной точечной нотации.
# Класс перечисления должен быть производным от одного из следующих четырех классов, определенных в модуле enum:
# - Enum - базовый класс для создания перечислений, чьи элементы способны хранить значения произвольного типа. Элементы
# такого перечисления могут содержать одинаковые значения.
# Пример перечисления, содержащего элементы с названиями различных веб-фреймворков, в том числе два элемента с
# одинаковыми значениями:


class Frameworks(Enum):
    LARAVEL = 'Laravel'
    DJANGO = 'Django'
    EXPRESS = 'Express'
    RAILS = 'Ruby on Rails'
    RUBY_ON_RAILS = 'Ruby on Rails'


print(Frameworks.DJANGO)
print(Frameworks.LARAVEL == Frameworks.RAILS)
print(Frameworks.RUBY_ON_RAILS == Frameworks.RAILS)
# Создать перечисление, элементы которого гарантированно .содержат только уникальные значения, можно, указав у его
# класса декоратор unique из модуля enum:
# @unique
# class Frameworks2(Enum):
#     LARAVEL = 'Laravel'
#     DJANGO = 'Django'
#     EXPRESS = 'Express'
#     RAILS = 'Ruby on Rails'
#     RUBY_ON_RAILS = 'Ruby on Rails'
# Traceback (most recent call last):
#   File '/media/Samsung/Programming/Python/Scripts/Developing_Applications/Chapter_15.py', line 106, in <module>
#     @unique
#      ^^^^^^
#   File '/usr/src/Python-3.12.2/Lib/enum.py', line 1597, in unique
#     raise ValueError('duplicate values found in %r: %s' %
# ValueError: duplicate values found in <enum 'Frameworks2'>: RUBY_ON_RAILS -> RAILS


# Пример перечисления с целыми числами:
class Colors(Enum):
    RED = 1
    GREEN = 2
    BLUE = 3
    WHITE = RED + GREEN + BLUE


print(Colors.RED)
print(Colors.WHITE)
# Однако выполнять арифметические операции с элементами такого перечисления нельзя, поскольку их значения не являются
# целыми числами:


# Если конкретные значения элементов целочисленного перечисления не важны, для их занесения можно использовать функцию
# auto() из модуля enum. Эта функция возвращает последовательно увеличивающиеся целые числа, начиная с 1. Пример:
class Colors2(Enum):
    RED = auto()
    GREEN = auto()
    BLUE = auto()
    WHITE = auto()


print(Colors2.RED)
print(Colors2.WHITE)


# - IntEnum - базовый класс для создания перечислений, элементы которых хранят лишь целочисленные значения. Значения
# элементов преобразуются в целые числа и, следовательно, могут быть использованы в арифметических операциях и
# выражениях сравнения с целыми числами. Пример:
class Colors3(IntEnum):
    RED = 1
    GREEN = 2
    BLUE = 3
    WHITE = RED + GREEN + BLUE


print(Colors3.GREEN)
print(Colors3.GREEN + 3)
print(Colors3.GREEN * Colors3.BLUE)
print(Colors3.WHITE == 6)


# - Flag - базовый класс для перечислений, элементы которых хранят целочисленные значения. Значения элементов могут
# выступать в качестве операндов для двоичных операторов (описаны в разд. 3.2). Функция auto() при использовании в таком
# перечислении последовательно выдает значения 1 и числа, являющиеся степенями числа 2 (2, 4, 8, 16 и т. д.). Пример:
class Colors4(Flag):
    BLACK = 0
    RED = auto()
    GREEN = auto()
    BLUE = auto()
    WHITE = RED | GREEN | BLUE


print(Colors4.BLACK)
print(Colors4.RED)
print(Colors4.GREEN)
print(Colors4.BLUE)
print(Colors4.WHITE)
print(Colors4.RED & Colors4.GREEN)
print(Colors4.RED | Colors4.GREEN)
print(bool(Colors4.WHITE & Colors4.BLUE))
# Однако при манипуляциях с элементами такого перечисления использовать в качестве операндов двоичных операторов целые
# числа нельзя:
# print(Colors4.RED | 2)
# Traceback (most recent call last):
#   File '/Chapter_15.py', line 184, in <module>
#     print(Colors4.RED | 2)
#           ~~~~~~~~~~~~^~~
# TypeError: unsupported operand type(s) for |: 'Colors4' and 'int'


# - IntFlag - аналогичен Flag, только значения элементов преобразуются в целые числа. Следовательно, при манипуляциях с
# элементами такого перечисления можно использовать в качестве операндов двоичных операторов целочисленные значения.
# Пример:
class Colors5(IntFlag):
    BLACK = 0
    RED = auto()
    GREEN = auto()
    BLUE = auto()
    WHITE = RED | GREEN | BLUE


print(Colors5.RED | 2)
print(Colors5.WHITE == 7)
# Все классы перечислений принадлежат типу EnumMeta из модуля enum:
print(type(Colors))                  # <class 'enum.EnumType'>
print(isinstance(Colors, EnumMeta))  # True
# Значения элементов перечислений являются объектами их классов:
print(type(Colors.RED))                # <enum 'Colors'>
print(isinstance(Colors.RED, Colors))  # True
# Действия, которые можно выполнять над элементами перечислений, были описаны ранее. Помимо того, над элементами
# перечислений можно производить следующие операции:
# - обращение к элементу в стиле словарей, используя имя элемента в качестве ключа:
print(Frameworks['EXPRESS'])  # Frameworks.EXPRESS
# - обращение к элементу по его значению, записывая его в круглых скобках после имени класса перечисления:
print(Frameworks('Laravel'))  # Frameworks.LARAVEL
# - получение имени атрибута класса перечисления, соответствующего заданному элементу, и его значения из свойств
# элементов name и value соответственно:
print(Frameworks.RAILS.name, Frameworks.RAILS.value)  # RAILS Ruby on Rails
# - проверка на вхождение или невхождение элемента в перечисление с помощью операторов in и not in соответственно:
f = Frameworks.DJANGO
print(f in Frameworks)
print(f not in Frameworks)
print(f in Colors)
# Перечисление можно использовать в качестве итератора (необходимая для этого функциональность определена в базовом
# классе):
print(list(Colors))  # [<Colors.RED: 1>, <Colors.GREEN: 2>, <Colors.BLUE: 3>, <Colors.WHITE: 6>]
for f in Frameworks:
    print(f.value, end=' | ')
print()
# Помимо элементов, классы перечислений могут содержать методы, включая статические. При этом обычные методы всегда
# вызываются у элемента перечисления (и соответственно первым параметром любому методу передается ссылка на объект,
# представляющий элемент перечисления, у которого вызывается этот метод), а статические методы - у самого класса
# перечисления. Для примера рассмотрим код перечисления Frameworks3 test_00131.py.
# В методе __str__() использована встроенная переменная __class__, хранящая ссылку на объект определения текущего
# класса. Атрибут __name__ этого объекта содержит имя класса в виде строки.
# Можно определить класс перечисления, содержащий только методы и не включающий элементы, а потом наследовать от него
# производный класс, уже содержащий элементы. Производный класс получит от базового класса поддержку всех его методов.
# Однако попытка создать производный класс на основе базового, содержащего элементы, приведет к ошибке.
# Перечисления можно использовать как альтернативу словарей везде, где требуется хранить неизменяемый набор именованных
# значений. Перечисления занимают меньше оперативной памяти, чем словари, и быстрее обрабатываются.
# В составе стандартной библиотеки Python присутствует модуль struct, позволяющий создавать нечто похожее на
# перечисления. Однако он не столь удобен в работе, как инструменты, предлагаемые модулем enum.
