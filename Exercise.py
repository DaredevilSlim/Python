#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Полезное
# http://pythontutor.ru

# Замер времени выполнения скрипта
# from datetime import datetime
# start = datetime.now()
# тело скрипта
# end = datetime.now()
# print('Seconds -', end - start)
# print('Milliseconds -', (end - start).total_seconds() * 1000)


# Неделя 1
# Напишите программу, которая приветствует пользователя, выводя слово Hello, введенное имя и знаки препинания по образцу
# (см. пример входных и выходных данных). Программа должна считывать в строковую переменную значение и писать
# соответствующее приветствие. Обратите внимание, что после запятой должен обязательно стоять пробел, а перед
# восклицательным знаком пробела нет. Операцией конкатенации строк (+) пользоваться нельзя.
# Формат ввода - Вводится строка, длина которой не превышает 100 символов.
# Формат вывода - Выведите ответ на задачу.
name = input()
print('Hello, ', name, '!', sep='')


# Напишите программу, которая по данному числу N от 1 до 9 выводит на экран N пингвинов. Изображение одного пингвина
# имеет размер 5×9 символов, между двумя соседними пингвинами также имеется пустой (из пробелов) столбец. Разрешается
# вывести пустой столбец после последнего пингвина. Для упрощения рисования скопируйте пингвина из примера в среду
# разработки.
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Учтите, что вывод данных на экран производится построчно(то есть строка за строкой). Не забудьте, что для
# вывода обратной косой черты надо написать две обратные косые черты подряд.
count = int(input())
p1 = '   _~_    ' * count
p2 = '  (o o)   ' * count
p3 = ' /  V  \\  ' * count
p4 = '/(  _  )\\ ' * count
p5 = '  ^^ ^^   ' * count
print(p1, p2, p3, p4, p5, sep='\n')


# N школьников делят K яблок поровну, не делящийся остаток остается в корзинке. Сколько яблок достанется каждому
# школьнику?
# Формат ввода - Программа получает на вход числа N и K - натуральные, не превышают 10000.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
k = int(input())
print(k // n)


# N школьников делят K яблок поровну, не делящийся остаток остается в корзинке. Сколько яблок останется в корзинке?
# Формат ввода - Программа получает на вход числа N и K - натуральные, не превышают 10000.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
k = int(input())
print(k % n)


# Формат ввода - Вводится целое неотрицательное число N. N≤100.
# Формат вывода - Выведите 2ᴺ.
n = int(input())
print(2 ** n)


# Дано натуральное число. Выведите его последнюю цифру.
# Формат ввода - Вводится единственное целое неотрицательное число (гарантируется, что оно не превышает 10000).
# Формат вывода - Выведите ответ на задачу.
n = int(input())
print(n % 10)


# Дано двузначное число. Найдите число десятков в нем.
# Формат ввода - Вводится единственное число (гарантируется, что оно соответствует условию задачи).
# Формат вывода - Выведите ответ на задачу.
n = int(input())
print(n // 10)


# Дано натуральное число. Найдите цифру, стоящую в разряде десятков в его десятичной записи (вторую справа цифру).
# Формат ввода - Вводится единственное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
print((n // 10) % 10)


# Дано трехзначное число. Найдите сумму его цифр.
# Формат ввода - Вводится целое положительное число. Гарантируется, что оно соответствует условию задачи.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
print((n // 100) + ((n // 10) % 10) + (n % 10))


# Запишите букву 'A' (латинскую, заглавную) 100 раз подряд. Сдайте на проверку программу, которая выводит эту строчку
# (только буквы, без кавычек или пробелов).
print('A' * 100)


# Дано число N. С начала суток прошло N минут. Определите, сколько часов и минут будут показывать электронные часы в
# этот момент.
# Формат ввода - Вводится число N - целое, положительное, не превышает 10 в 7.
# Формат вывода - Программа должна вывести два числа: количество часов (от 0 до 23) и количество минут (от 0 до 59).
# Учтите, что число N может быть больше, чем количество минут в сутках.
n = int(input())
print(((n // 60) % 24), (n % 60))


# Пирожок в столовой стоит A рублей и B копеек. Определите, сколько рублей и копеек нужно заплатить за N пирожков.
# Формат ввода - Программа получает на вход три числа: A, B, N - целые, неотрицательные, не превышают 10000.
# Формат вывода - Программа должна вывести два числа: стоимость покупки в рублях и копейках.
a = int(input())
b = int(input())
p = int(input())
print(((((a * 100) + b) * p) // 100), ((((a * 100) + b) * p) % 100))


# Напишите программу, которая считывает целое число и выводит текст, аналогичный приведенному в примере(пробелы важны!).
# Нельзя пользоваться конкатенацией строк (используйте print с несколькими параметрами).
# Формат ввода - Вводится целое число (гарантируется, что число находится в диапазоне от -1000 до +1000).
# Формат вывода - Выведите две строки, согласно образцу.
n = int(input())
print('The next number for the number ', n, ' is ', n + 1, '.', sep='')
print('The previous number for the number ', n, ' is ', n - 1, '.', sep='')


# Вводится число 0 или 1, необходимо вывести 1 или 0 соответственно.
# Формат ввода - Число 0 или 1.
# Формат вывода - Число 0 или 1.
n = int(input())
print((10 ** n) % 10)


# Дано целое число N. Выведите следующее за ним четное число.
# Формат ввода - Вводится целое положительное число, не превышающее 1000.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
print(((n // 2) * 2) + 2)


# Заданное число N записали 100 раз подряд и затем возвели в квадрат. Что получилось?
# Формат ввода - Вводится целое неотрицательное число N не превышающее 1000.
# Формат вывода - Выведите ответ на задачу.
n = int(input() * 100)
print(n ** 2)


# Длина Московской кольцевой автомобильной дороги - 109 километров. Байкер Вася стартует с нулевого километра МКАД и
# едет со скоростью v километров в час. На какой отметке он остановится через t часов?
# Формат ввода - Программа получает на вход значение v и t. Если v>0, то Вася движется в положительном направлении по
# МКАД, если же значение v<0, то в отрицательном. (Гарантируется, что исходные числа - целые и находятся в промежутке
# от -1000 до +1000)
# Формат вывода - Программа должна вывести целое число от 0 до 108 - номер отметки, на которой остановится Вася.
v = int(input())
t = int(input())
print((v * t) % 109)


# Электронные часы показывают время в формате h:mm:ss, то есть сначала записывается количество часов (число от 0 до,
# потом обязательно двузначное количество минут, затем обязательно двузначное количество секунд. Количество минут и
# секунд при необходимости дополняются до двузначного числа нулями.
# С начала суток прошло N секунд. Выведите, что покажут часы.
# Формат ввода - Вводится число N - целое, положительное, не превышает 10 в 7-й.
# Формат вывода - Выведите показания часов, соблюдая формат.
# Примечания - Вывести числа можно по отдельности(дополнить нулями).
s = int(input())
hh = (s // 3600) % 24
mm = (s // 60) % 60
ss = (s % 3600) % 60
print(hh, ':', (mm // 10), (mm % 10), ':', (ss // 10), (ss % 10), sep='')


# Даны два момента времени в пределах одних и тех же суток. Для каждого момента указан час, минута и секунда. Известно,
# что второй момент времени наступил не раньше первого. Определите сколько секунд прошло между двумя моментами времени.
# Формат ввода - Программа на вход получает шесть целых чисел через перевод строки. Первые три целых числа соответствуют
# часам, минутам и секундам первого момента, следующие три числа соответствуют второму моменту.
# Часы задаются числом от 0 до 23 включительно. Минуты и секунды - от 0 до 59.
# Формат вывода - Выведите число секунд между этими моментами времени.
h1 = int(input())
m1 = int(input())
s1 = int(input())
h2 = int(input())
m2 = int(input())
s2 = int(input())
t1 = (h1 * 3600) + (m1 * 60) + s1
t2 = (h2 * 3600) + (m2 * 60) + s2
print(t2 - t1)


# За день машина проезжает N километров. Сколько дней нужно, чтобы проехать маршрут длиной M километров?
# Формат ввода - Программа получает на вход числа N и M (целые, положительные).
# Формат вывода - Выведите ответ на задачу.
n = int(input())
m = int(input())
print((m + n - 1) // n)


# Улитка ползет по вертикальному шесту высотой H метров, поднимаясь за день на A метров, а за ночь спускаясь на B
# метров. На какой день улитка доползет до вершины шеста?
# Формат ввода - Программа получает на вход натуральные числа H, A, B. Гарантируется, что A>B, A<H.
# Формат вывода - Программа должна вывести одно натуральное число.
# Примечание - Два способа округления в большую сторону при целочисленном делении
# (x + y - 1) // y
# ((x - 1) // y) + 1
h = int(input())
a = int(input())
b = int(input())
print(((h - b - 1) // (a - b)) + 1)
# или
h = int(input())
a = int(input())
b = int(input())
print(((h - a - 1) // (a - b)) + 2)


# Дано четырехзначное число. Определите, является ли его десятичная запись симметричной. Если число симметричное, то
# выведите 1, иначе выведите любое другое целое число. Число может иметь меньше четырех знаков, тогда нужно считать, что
# его десятичная запись дополняется слева незначащими нулями.
# Формат ввода - Вводится единственное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
n1 = n % 10
n2 = ((n // 10) % 10)
n3 = (((n // 10) // 10) % 10)
n4 = ((((n // 10) // 10) // 10) % 10)
r1 = (n2 * 10) + n1
r2 = (n3 * 10) + n4
print((r1 - r2) + 1)


# Напишите программу, которая считывает два целых числа A и B и выводит наибольшее значение из них. Числа - целые от 1
# до 1000. При решении задачи можно пользоваться только целочисленными арифметическими операциями. Нельзя пользоваться
# нелинейными конструкциями: ветвлениями, циклами, функциями.
# Формат ввода - Вводятся два числа.
# Формат вывода - Выведите ответ на задачу.
n1 = int(input())
n2 = int(input())
r1 = (n1 + n2)
r2 = abs(n1 - n2)
print((r1 + r2) // 2)
# Или
n1 = int(input())
n2 = int(input())
r1 = (n1 + n2)
r2 = (n1 - n2)
r3 = int(((r2 * r2) ** 0.5))
print((r1 + r3) // 2)


# В этой задаче необходимо проверить, делится ли число A на число B нацело. Использовать можно только арифметические
# операции, использование любых видов ветвлений, функций и т.п. запрещено.
# Формат ввода - Вводятся два натуральных числа A и B.
# Формат вывода - Выведите "YES", если A кратно B и "NO" в противном случае.
n1 = int(input())
n2 = int(input())
r = (n1 % n2)
y = (0 ** r)
n = (0 ** y)
print('Yes' * y, 'No' * n, sep='')


# Неделя 2
# Максимум из двух
# Напишите программу, которая считывает два целых числа A и B и выводит наибольшее значение из них. Числа - целые от 1
# до 1000.
# Формат ввода - Вводятся два числа.
# Формат вывода - Выведите ответ на задачу.
a = int(input())
b = int(input())
if a > b or a == b:
    print(a)
else:
    print(b)


# Какое число больше?
# Даны два целых числа. Программа должна вывести число 1, если первое число больше второго, число 2, если второе больше
# первого или число 0, если они равны.
# Формат ввода - Вводятся два целых числа.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Эту задачу желательно решить с использованием каскадных инструкций if... elif... else.
n1 = int(input())
n2 = int(input())
if n1 == n2:
    print(0)
elif n1 > n2:
    print(1)
else:
    print(2)


# Максимум трех чисел
# Даны три целых числа. Найдите наибольшее из них (программа должна вывести ровно одно целое число).
# Какое наименьшее число операторов сравнения (>, <, >=, <=) необходимо для решения этой задачи?
# Формат ввода - Вводится три целых числа.
# Формат вывода - Выведите ответ на задачу.
n1 = int(input())
n2 = int(input())
n3 = int(input())
if n1 >= n2 and n1 >= n3:
    print(n1)
elif n2 >= n3:
    print(n2)
else:
    print(n3)


# Дано натуральное число. Требуется определить, является ли год с данным номером високосным. Если год является
# високосным, то выведите YES, иначе выведите NO. Напомним, что в соответствии с григорианским календарем, год является
# високосным, если его номер кратен 4, но не кратен 100, а также если он кратен 400.
# Формат ввода - Вводится одно натуральное число.
# Формат вывода - Выведите ответ на задачу.
year = int(input())
if ((year % 4) == 0) and ((year % 100) != 0):
    print('YES')
elif ((year % 400) == 0) and (0 == (year % 100)):
    print('YES')
else:
    print('NO')


# Шахматный король ходит по горизонтали, вертикали и диагонали, но только на 1 клетку. Даны две различные клетки
# шахматной доски, определите, может ли король попасть с первой клетки на вторую одним ходом. Формат ввода - Программа
# получает на вход четыре числа от 1 до 8 каждое, задающие номер столбца и номер строки сначала для первой клетки,
# потом для второй клетки.
# Формат вывода - Программа должна вывести YES, если из первой клетки ходом короля можно попасть во вторую или NO в
# противном случае.
cur_ver = int(input())  # Текущая Вертикаль(ТВ)
cur_hor = int(input())  # Текущая Горизонталь(ТГ)
exp_ver = int(input())  # Ожидаемая Вертикаль(ОВ)
exp_hor = int(input())  # Ожидаемая Горизонталь(ОГ)
# Значение ОВ увеличилось на 1(ОВ == ТВ + 1)
if exp_ver == (cur_ver + 1):  # (6 == 5 + 1)
    # Значение ОГ при этом увеличилось на 1(ОГ == ТГ + 1)
    if exp_hor == (cur_hor + 1):  # (6 == 5 + 1)
        print('YES')
    # Значение ОГ при этом уменьшилось на 1(ОГ == ТГ - 1)
    elif exp_hor == (cur_hor - 1):  # (4 == 5 - 1)
        print('YES')
    # Значение ОГ при этом осталось неизменным(ОГ == ТГ)
    elif exp_hor == cur_hor:  # (5 == 5)
        print('YES')
    # Все прочие случаи выходящие за рамки условия
    else:
        print('NO')
# Значение ОВ уменьшилось на 1(ОВ == ТВ - 1)
elif exp_ver == (cur_ver - 1):  # (4 == 5 - 1)
    # Значение ОГ при этом увеличилось на 1(ОГ == ТГ + 1)
    if exp_hor == (cur_hor + 1):  # (6 == 5 + 1)
        print('YES')
    # Значение ОГ при этом уменьшилось на 1(ОГ == ТГ - 1)
    elif exp_hor == (cur_hor - 1):  # (4 == 5 - 1)
        print('YES')
    # Значение ОГ при этом осталось неизменным(ОГ == ТГ)
    elif exp_hor == cur_hor:  # (5 == 5)
        print('YES')
    # Все прочие случаи выходящие за рамки условия
    else:
        print('NO')
# Значение ОВ осталось неизменным(ОВ == ТВ)
elif exp_ver == cur_ver:  # (5 == 5)
    # Значение ОГ при этом увеличилось на 1(ОГ == ТГ + 1)
    if exp_hor == (cur_hor + 1):  # (6 == 5 + 1)
        print('YES')
    # Значение ОГ при этом уменьшилось на 1(ОГ == ТГ - 1)
    elif exp_hor == (cur_hor - 1):  # (4 == 5 - 1)
        print('YES')
    # Все прочие случаи выходящие за рамки условия
    else:
        print('NO')
else:
    print('NO')


# В доме несколько подъездов. В каждом подъезде одинаковое количество квартир. Квартиры нумеруются подряд, начиная с
# единицы. Может ли в некотором подъезде первая квартира иметь номер x, а последняя – номер y?
# Формат ввода - Вводятся два натуральных числа x и y (x ≤ y), не превышающие 10000.
# Формат вывода - Выведите слово YES (заглавными латинскими буквами), если такое возможно, и NO в противном случае.
x = int(input())
y = int(input())
if (y % ((y - x) + 1)) == 0:
    print('YES')
else:
    print('NO')


# Заданы две клетки шахматной доски. Если они покрашены в один цвет, то выведите слово YES, а если в разные цвета – NO.
# Формат ввода - Вводятся 4 числа - координаты клеток.
# Формат вывода - Выведите ответ на задачу.
cur_ver = int(input())
cur_hor = int(input())
exp_ver = int(input())
exp_hor = int(input())
cur_pos = cur_ver + cur_hor
exp_pos = exp_ver + exp_hor
if (cur_pos % 2) == (exp_pos % 2):
    print('YES')
else:
    print('NO')


# Шоколадка имеет вид прямоугольника, разделенного на n×m долек. Шоколадку можно один раз разломить по прямой на две
# части. Определите, можно ли таким образом отломить от шоколадки ровно k долек.
# Формат ввода - Программа получает на вход три числа: n, m, k
# Формат вывода - Программа должна вывести одно из двух слов: YES или NO.
n = int(input())
m = int(input())
k = int(input())
if (n * m) <= k:
    print('NO')
elif k >= n or k >= m:
    if (k % n) == 0 or k == n:
        print('YES')
    elif (k % m) == 0 or k == m:
        print('YES')
    else:
        print('NO')
else:
    print('NO')
# Или
n = int(input())
m = int(input())
k = int(input())
if (n * m) <= k:
    print('NO')
elif (k % n) == 0 or k == n:
    print('YES')
elif (k % m) == 0 or k == m:
    print('YES')
else:
    print('NO')


# Для данного числа n<100 закончите фразу “На лугу пасется...” одним из возможных продолжений: “n коров”, “n корова”,
# “n коровы”, правильно склоняя слово “корова”.
# Формат ввода - Вводится натуральное число.
# Формат вывода - Программа должна вывести введенное число n и одно из слов: коров, корова или коровы. Между числом и
# словом должен стоять ровно один пробел.
n = int(input())
if (n % 10) == 1:
    if (n // 10) != 1:
        print(n, 'корова')
    else:
        print(n, 'коров')
elif (n % 10) in [2, 3, 4]:
    if (n // 10) != 1:
        print(n, 'коровы')
    else:
        print(n, 'коров')
elif (n % 10) in [5, 6, 7, 8, 9, 0]:
    print(n, 'коров')


# В математике функция sign(x) (знак числа) определена так:
# sign(x)=1, если x>0,
# sign(x)=-1, если x<0,
# sign(x)=0, если x=0.
# Для данного числа x выведите значение sign(x).
# Формат ввода - Вводится одно целое число.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Эту задачу желательно решить с использованием каскадных инструкций if... elif... else.
x = int(input())
if x > 0:
    print(1)
elif x < 0:
    print(-1)
else:
    print(0)


# Даны координаты двух точек на плоскости, требуется определить, лежат ли они в одной координатной четверти или нет
# (все координаты отличны от нуля).
# Формат ввода - Вводятся 4 числа: координаты первой точки (x1,y1) и координаты второй точки (x2,y2).
# Формат вывода - Программа должна вывести слово YES, если точки находятся в одной координатной четверти, в противном
# случае вывести слово NO.
x1 = int(input())
y1 = int(input())
x2 = int(input())
y2 = int(input())
if x1 > 0:
    if y1 > 0:
        if x2 > 0:
            if y2 > 0:
                print('YES')
            else:
                print('NO')
        else:
            print('NO')
    elif y1 < 0:
        if x2 > 0:
            if y2 < 0:
                print('YES')
            else:
                print('NO')
        else:
            print('NO')
    else:
        print('NO')
elif x1 < 0:
    if y1 > 0:
        if x2 < 0:
            if y2 > 0:
                print('YES')
            else:
                print('NO')
        else:
            print('NO')
    elif y1 < 0:
        if x2 < 0:
            if y2 < 0:
                print('YES')
            else:
                print('NO')
        else:
            print('NO')
    else:
        print('NO')
else:
    print('NO')


# На доске стоит белая шашка. Требуется определить, может ли она попасть в заданную клетку, делая ходы по правилам
# (не превращаясь в дамку). Белые шашки могут ходить по черным клеткам по диагонали вверх-влево или вверх-вправо. Ходов
# может быть несколько!
# Формат ввода - Вводится клетка, где стоит шашка, а затем клетка, куда шашка должна попасть.
# Каждая клетка описывается номером вертикали, а затем номером горизонтали.
# Формат вывода - Выведите слово YES (заглавными буквами), если шашка может попасть из начальной клетки в указанную, и
# NO в противном случае.
# Примечания - Доска имеет размер 8x8, вертикали и горизонтали нумеруются числами от 1 до 8 начиная с левого нижнего
# угла. Исходная и конечная клетки не совпадают.
cur_ver = int(input())
cur_hor = int(input())
exp_ver = int(input())
exp_hor = int(input())
cur_pos = cur_ver + cur_hor
exp_pos = exp_ver + exp_hor
if (cur_pos % 2) == 0 and (exp_pos % 2) == 0:
    if exp_hor > cur_hor:
        if exp_hor == (cur_hor + (exp_hor - cur_hor)):
            if exp_ver == (cur_ver + (exp_ver - cur_ver)):
                print('YES')
            elif exp_ver == (cur_ver - (exp_ver - cur_ver)):
                print('YES')
            else:
                print('NO')
        else:
            print('NO')
    else:
        print('NO')
else:
    print('NO')


# Даны три стороны треугольника a,b,c. Определите тип треугольника с заданными сторонами. Выведите одно из четырех слов:
# rectangular для прямоугольного треугольника, acute для остроугольного треугольника, obtuse для тупоугольного
# треугольника или impossible, если треугольника с такими сторонами не существует.
# Формат ввода - Вводятся три целых числа.
# Формат вывода - Выведите ответ на задачу.
a = int(input())
b = int(input())
c = int(input())
if ((a + b) > c) and ((b + c) > a) and ((a + c) > b):
    if b <= a >= c:
        if a == (((b * b) + (c * c)) ** 0.5):
            print('rectangular')
        elif a > (((b * b) + (c * c)) ** 0.5):
            print('obtuse')
        elif a < (((b * b) + (c * c)) ** 0.5):
            print('acute')
        else:
            print('impossible')
    elif a <= b >= c:
        if b == (((a * a) + (c * c)) ** 0.5):
            print('rectangular')
        elif b > (((a * a) + (c * c)) ** 0.5):
            print('obtuse')
        elif b < (((a * a) + (c * c)) ** 0.5):
            print('acute')
        else:
            print('impossible')
    elif b <= c >= a:
        if c == (((b * b) + (a * a)) ** 0.5):
            print('rectangular')
        elif c > (((b * b) + (a * a)) ** 0.5):
            print('obtuse')
        elif c < (((b * b) + (a * a)) ** 0.5):
            print('acute')
        else:
            print('impossible')
else:
    print('impossible')


# Даны три целых числа A, B, C. Определить, есть ли среди них хотя бы одно четное и хотя бы одно нечетное.
# Формат ввода - Числа A, B, C, не превышающие по модулю 10000.
# Формат вывода - Одна строка – "YES" или "NO".
a = int(input())
b = int(input())
c = int(input())
a_mod = int((a * a) ** 0.5)
b_mod = int((b * b) ** 0.5)
c_mod = int((c * c) ** 0.5)
if ((a_mod % 2) == 0) or ((b_mod % 2) == 0) or ((c_mod % 2) == 0):
    if ((a_mod % 2) != 0) or ((b_mod % 2) != 0) or ((c_mod % 2) != 0):
        print('YES')
    else:
        print('NO')
else:
    print('NO')


# Дано три числа. Упорядочите их в порядке неубывания. Программа должна считывать три числа a,b,c, затем программа
# должна менять их значения так, чтобы стали выполнены условия a≤b≤c, затем программа выводит тройку a,b,c.
# Формат ввода - Вводятся три числа.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Дополнительные ограничения: нельзя использовать дополнительные переменные (то есть единственной
# допустимой операцией присваивания является обмен значений двух переменных типа (a, b) = (b, a).
a = int(input())
b = int(input())
c = int(input())
if a <= b <= c:
    print(a, b, c)
elif a >= b >= c:
    a, c = c, a
    print(a, b, c)
elif a >= c >= b:
    a, b = b, a
    c, b = b, c
    print(a, b, c)
elif b >= a >= c:
    c, b = b, c
    a, b = b, a
    print(a, b, c)
elif b >= c >= a:
    b, c = c, b
    print(a, b, c)
elif c >= a >= b:
    a, b = b, a
    print(a, b, c)
# Или
a = int(input())
b = int(input())
c = int(input())
if a >= b:
    if b >= c:
        a, b, c = a, b, c
        print(a, b, c)
    elif b <= c:
        if a >= c:
            a, b, c = a, c, b
            print(a, b, c)
        elif a <= c:
            a, b, c = c, a, b
            print(a, b, c)
elif a <= b:
    if b >= c:
        if a >= c:
            a, b, c = b, a, c
            print(a, b, c)
        elif a <= c:
            a, b, c = b, c, a
            print(a, b, c)
    elif b <= c:
        a, b, c = c, b, a
        print(a, b, c)


# Даны три целых числа. Определите, сколько среди них совпадающих. Программа должна вывести одно из чисел:
# 3(если все совпадают), 2 (если два совпадает) или 0 (если все числа различны).
# Формат ввода - Вводятся три целых числа.
# Формат вывода - Выведите ответ на задачу.
a = int(input())
b = int(input())
c = int(input())
if a == b == c:
    print(3)
elif a == b or a == c or b == c:
    print(2)
else:
    print(0)


# За многие годы заточения узник замка Иф проделал в стене прямоугольное отверстие размером D×E. Замок Иф сложен из
# кирпичей, размером A×B×C. Определите, сможет ли узник выбрасывать кирпичи в море через это отверстие, если стороны
# кирпича должны быть параллельны сторонам отверстия.
# Формат ввода - Программа получает на вход числа A,B,C,D,E.
# Формат вывода - Программа должна вывести слово YES или NO.
a = int(input())
b = int(input())
c = int(input())
d = int(input())
e = int(input())
if d >= a and e >= b or d >= b and e >= a:
    print('YES')
elif d >= a and e >= c or d >= c and e >= a:
    print('YES')
elif d >= b and e >= c or d >= c and e >= b:
    print('YES')
else:
    print('NO')


# Есть две коробки, первая размером A₁×B₁×C₁, вторая размером A₂×B₂×C₂. Определите, можно ли разместить одну из этих
# коробок внутри другой, при условии, что поворачивать коробки можно только на 90 градусов вокруг ребер.
# Формат ввода - Программа получает на вход числа A₁,B₁,C₁,A₂,B₂,C₂.
# Формат вывода - Программа должна вывести одну из следующих строчек:
# Boxes are equal, если коробки одинаковые, The first box is smaller than the second one, если первая коробка может
# быть положена во вторую, The first box is larger than the second one, если вторая коробка может быть положена в
# первую, Boxes are incomparable, во всех остальных случаях.
a1 = int(input())
b1 = int(input())
c1 = int(input())
a2 = int(input())
b2 = int(input())
c2 = int(input())
if a1 >= b1:
    if b1 >= c1:
        a1, b1, c1 = a1, b1, c1
    elif b1 <= c1:
        if a1 >= c1:
            a1, b1, c1 = a1, c1, b1
        elif a1 <= c1:
            a1, b1, c1 = c1, a1, b1
elif a1 <= b1:
    if b1 >= c1:
        if a1 >= c1:
            a1, b1, c1 = b1, a1, c1
        elif a1 <= c1:
            a1, b1, c1 = b1, c1, a1
    elif b1 <= c1:
        a1, b1, c1 = c1, b1, a1

if a2 >= b2:
    if b2 >= c2:
        a2, b2, c2 = a2, b2, c2
    elif b2 <= c2:
        if a2 >= c2:
            a2, b2, c2 = a2, c2, b2
        elif a2 <= c2:
            a2, b2, c2 = c2, a2, b2
elif a2 <= b2:
    if b2 >= c2:
        if a2 >= c2:
            a2, b2, c2 = b2, a2, c2
        elif a2 <= c2:
            a2, b2, c2 = b2, c2, a2
    elif b2 <= c2:
        a2, b2, c2 = c2, b2, a2

if a1 == a2:
    if b1 == b2:
        if c1 == c2:
            print('Boxes are equal')
        elif c1 > c2:
            print('The first box is larger than the second one')
        elif c1 < c2:
            print('The first box is smaller than the second one')
    elif b1 > b2:
        if c1 == c2:
            print('The first box is larger than the second one')
        elif c1 > c2:
            print('The first box is larger than the second one')
        else:
            print('Boxes are incomparable')
    elif b1 < b2:
        if c1 == c2:
            print('The first box is smaller than the second one')
        elif c1 < c2:
            print('The first box is smaller than the second one')
        else:
            print('Boxes are incomparable')
elif a1 > a2:
    if b1 == b2:
        if c1 == c2:
            print('The first box is larger than the second one')
        elif c1 > c2:
            print('The first box is larger than the second one')
        else:
            print('Boxes are incomparable')
    elif b1 > b2:
        if c1 == c2:
            print('The first box is larger than the second one')
        elif c1 > c2:
            print('The first box is larger than the second one')
        else:
            print('Boxes are incomparable')
    else:
        print('Boxes are incomparable')
elif a1 < a2:
    if b1 == b2:
        if c1 == c2:
            print('The first box is smaller than the second one')
        elif c1 < c2:
            print('The first box is smaller than the second one')
        else:
            print('Boxes are incomparable')
    elif b1 < b2:
        if c1 == c2:
            print('The first box is smaller than the second one')
        elif c1 < c2:
            print('The first box is smaller than the second one')
        else:
            print('Boxes are incomparable')
    else:
        print('Boxes are incomparable')
else:
    print('Boxes are incomparable')


# На склад, который имеет форму прямоугольного параллелепипеда, привезли ноутбуки, упакованные в коробки. Каждая коробка
# также имеет форму прямоугольного параллелепипеда. По правилам хранения коробки с ноутбуками должны быть размещены на
# складе с выполнением следующих двух условий:
# - Стороны коробок должны быть параллельны сторонам склада.
# - Коробку при помещении на склад разрешается расположить где угодно (с выполнением предыдущего условия), в том числе
# на другой коробке, но все коробки должны быть ориентированы одинаково (т.е. нельзя одну коробку расположить “стоя”, а
# другую -“лежа”). Напишите программу, которая по размерам склада и размерам коробки с ноутбуком определит максимальное
# количество ноутбуков, которое может быть размещено на складе.
# Формат ввода - Программа получает на вход шесть натуральных чисел. Первые три задают длину, высоту и ширину склада.
# Следующие три задают соответственно длину, высоту и ширину коробки с ноутбуком.
# Формат вывода - Программа должна вывести одно число - максимальное количество ноутбуков, которое может быть размещено
# на складе.
a1 = int(input())
b1 = int(input())
c1 = int(input())
a2 = int(input())
b2 = int(input())
c2 = int(input())

count1 = (a1 // a2) * (b1 // b2) * (c1 // c2)
count2 = (a1 // a2) * (b1 // c2) * (c1 // b2)
count3 = (a1 // b2) * (b1 // a2) * (c1 // c2)
count4 = (a1 // c2) * (b1 // a2) * (c1 // b2)
count5 = (a1 // b2) * (b1 // c2) * (c1 // a2)
count6 = (a1 // c2) * (b1 // b2) * (c1 // a2)

if count1 >= count2:
    if count1 >= count3:
        if count1 >= count4:
            if count1 >= count5:
                if count1 >= count6:
                    print(count1)
                elif count1 <= count6:
                    print(count6)
            elif count1 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)
        elif count1 <= count4:
            if count4 >= count5:
                if count4 >= count6:
                    print(count4)
                elif count4 <= count6:
                    print(count6)
            elif count4 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)
    elif count1 <= count3:
        if count3 >= count4:
            if count3 >= count5:
                if count3 >= count6:
                    print(count3)
                elif count3 <= count6:
                    print(count6)
            elif count3 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)
        elif count3 <= count4:
            if count4 >= count5:
                if count4 >= count6:
                    print(count4)
                elif count4 <= count6:
                    print(count6)
            elif count4 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)
elif count1 <= count2:
    if count2 >= count3:
        if count2 >= count4:
            if count2 >= count5:
                if count2 >= count6:
                    print(count2)
                elif count2 <= count6:
                    print(count6)
            elif count2 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)
        elif count2 <= count4:
            if count4 >= count5:
                if count4 >= count6:
                    print(count4)
                elif count4 <= count6:
                    print(count6)
            elif count4 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)
    elif count2 <= count3:
        if count3 >= count4:
            if count3 >= count5:
                if count3 >= count6:
                    print(count3)
                elif count3 <= count6:
                    print(count6)
            elif count3 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)
        elif count3 <= count4:
            if count4 >= count5:
                if count4 >= count6:
                    print(count4)
                elif count4 <= count6:
                    print(count6)
            elif count4 <= count5:
                if count5 >= count6:
                    print(count5)
                elif count5 <= count6:
                    print(count6)


# В кафе мороженое продают по три шарика и по пять шариков. Можно ли купить ровно k шариков мороженого?
# Формат ввода - Вводится число k (целое,положительное)
# Формат вывода - Программа должна вывести слово YES, если при таких условиях можно набрать ровно k шариков (не больше
# и не меньше), в противном случае - вывести NO.
k = int(input())
if k not in (1, 2, 4, 7):
    print('YES')
else:
    print('NO')


# Сложное уравнение
# Решить в целых числах уравнение: (ax+b) / (cx+d) =0
# Формат ввода - Вводятся 4 числа: a,b,c,d; c и d не равны нулю одновременно.
# Формат вывода - Необходимо вывести все решения, если их число конечно, “NO” (без кавычек), если решений нет, и “INF”
# (без кавычек), если решений бесконечно много.
a = int(input())
b = int(input())
c = int(input())
d = int(input())
if a == 0 and b == 0:
    print('INF')
elif a != 0 and b == 0 or a == 0 and b != 0 or a != 0 and b != 0:
    x = -b // a
    if (a * x + b) == 0 and (c * x + d) != 0:
        print(x)
    else:
        print('NO')
else:
    print('NO')


# Котлеты
# На сковородку одновременно можно положить k котлет. Каждую котлету нужно с каждой стороны обжаривать m минут
# непрерывно. За какое наименьшее время удастся поджарить с обеих сторон n котлет?
# Формат ввода - Программа получает на вход три числа: k,m,n.
# Формат вывода - Программа должна вывести одно число: наименьшее количество минут.
k = int(input())
m = int(input())
n = int(input())
if k >= n:
    print(2 * m)
elif k < n:
    if ((2 * n) % k) == 0:
        print(((2 * n) // k) * m)
    elif ((2 * n) % k) > 0:
        print((((2 * n) // k) + 1) * m)


# Вдоль прямой выложены три спички. Необходимо переложить одну из них так, чтобы при поджигании любой спички сгорали все
# три. Для того чтобы огонь переходил с одной спички на другую, необходимо чтобы эти спички соприкасались
# (хотя бы концами).
# Требуется написать программу, определяющую, какую из трех спичек необходимо переместить.
# Формат ввода - Вводятся шесть целых чисел : l₁,r₁,l₂,r₂,l₃,r₃ –– координаты первой, второй и третьей спичек
# соответственно (0 ≤ lᵢ < rᵢ ≤ 100). Каждая спичка описывается координатами левого и правого концов по горизонтальной
# оси OX.
# Формат вывода - Выведите номер искомой спички. Если возможных ответов несколько, то выведите наименьший из них.
# В случае, когда нет необходимости перемещать какую-либо спичку, выведите 0. Если же требуемого результата достигнуть
# невозможно, то выведите -1.
l1 = int(input())
r1 = int(input())
l2 = int(input())
r2 = int(input())
l3 = int(input())
r3 = int(input())
if l1 == l2 == l3 or r1 == r2 == r3:
    print(0)
elif l1 >= l2 and r1 >= l2:
    if l2 >= l3 and r2 >= l3:
        print(0)
elif l1 >= l3 and r1 >= l3:
    if l3 >= l2 and r3 >= l2:
        print(0)
elif l2 >= l1 and r2 >= l1:
    if l1 >= l3 and r1 >= l3:
        print(0)
elif l2 >= l3 and r2 >= l3:
    if l3 >= l1 and r3 >= l1:
        print(0)
elif l3 >= l1 and r3 >= l1:
    if l1 >= l2 and r1 >= l2:
        print(0)
elif l3 >= l2 and r3 >= l2:
    if l2 >= l1 and r2 >= l1:
        print(0)


# В одну транспортную компанию поступил заказ на перевозку двух ящиков из одного города в другой. Для перевозки ящики
# решено было упаковать в специальный контейнер.
# Ящики и контейнер имеют вид прямоугольных параллелепипедов. Длина, ширина и высота первого ящика - l₁,w₁ и h₁,
# соответствующие размеры второго ящика – l₂,w₂ и h₂. Контейнер имеет длину, ширину и высоту lc,wc и hc.
# Поскольку ящики содержат хрупкое оборудование, после упаковки в контейнер каждый из них должен остаться в строго
# вертикальном положении. Таким образом, ящики можно разместить рядом или один на другом. Для надежного закрепления в
# контейнере стороны ящиков должны быть параллельны его сторонам. Иначе говоря, если исходно ящики были расположены так,
# что все их стороны параллельны соответствующим сторонам контейнера, то каждый из них разрешается перемещать и
# поворачивать относительно вертикальной оси на угол, кратный 90 градусам.
# Разумеется, после упаковки оба ящика должны полностью находиться внутри контейнера и не должны пересекаться.
# Выясните, можно ли поместить ящики в контейнер с соблюдением указанных условий.
# Формат ввода - Во входных данных записаны числа l₁, w₁, h₁, l₂,w₂, h₂, lc, wc и hc. Все размеры - целые положительные
# числа, не превышающие 1000. Числа в строках разделены пробелами.


# По данному целому числу N распечатайте все квадраты натуральных чисел,не превосходящие N, в порядке возрастания.
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
i = 0
x = 0
while i <= n:
    x += 1
    i = x * x
    if i <= n:
        print(i, end=' ')


# Дано целое число, не меньшее 2. Выведите его наименьший натуральный делитель, отличный от 1.
# Формат ввода - Вводится целое положительное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
div = 0
min_div = 0
while div != n:
    div += 1
    current = n // div
    if (n % div) == 0 and current > 1:
        min_div = current
print(min_div)


# По данному числу N распечатайте все целые степени двойки, не превосходящие N, в порядке возрастания.Операцией
# возведения в степень пользоваться нельзя!
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
i = 1
while i <= n:
    if i <= n:
        print(i, end=' ')
    i = i + i


# Дано натуральное число N. Выведите слово YES, если число N является точной степенью двойки, или слово NO в противном
# случае. Операцией возведения в степень пользоваться нельзя!
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
i = 1
while i <= n:
    if (n - i) == 0:
        x = 'YES'
    else:
        x = 'NO'
    i = i + i
print(x)


# По данному натуральному числу N выведите такое наименьшее целое число k, что 2ᵏ≥N.
# Операцией возведения в степень пользоваться нельзя!
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
i = 1
x = 0
while i < n:
    x += 1
    i = i + i
print(x)


# В первый день спортсмен пробежал x километров, а затем он каждый день увеличивал пробег на 10% от предыдущего
# значения.
# По данному числу y определите номер дня, на который пробег спортсмена составит не менее y километров.
# Формат ввода - Программа получает на вход действительные числа x и y
# Формат вывода - Программа должна вывести одно натуральное число.
x = float(input())
y = float(input())
i = 1
while x < y:
    x = (x + (x * 0.1))
    i += 1
print(i)
# Или
x = float(input())
y = float(input())
i = 1
while x < y:
    x += x * 0.1
    i += 1
print(i)


# Последовательность состоит из натуральных чисел, не превосходящих 10⁹, и завершается числом 0.Определите значение
# наибольшего элемента последовательности.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
now = int(input())
max_num = now
while now != 0:
    if now != 0 and now > max_num:
        max_num = now
    now = int(input())
print(max_num)


# По данному натуральном n вычислите сумму 1²+2²+3²+...+n².
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
i = 0
x = 0
while i < n:
    i += 1
    x += i * i
print(x)


# Программа получает на вход последовательность целых неотрицательных чисел, каждое число записано в отдельной строке.
# Последовательность завершается числом 0, при считывании которого программа должна закончить свою работу и вывести
# количество членов последовательности (не считая завершающего числа 0).
# Числа, следующие за числом 0, считывать не нужно.
# Формат ввода - Вводится последовательность целых чисел, заканчивающаяся числом 0.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
i = 0
while n != 0:
    i += 1
    n = int(input())
print(i)


# Определите сумму всех элементов последовательности, завершающейся числом 0.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
count = 0
while n != 0:
    count += n
    n = int(input())
print(count)


# Определите среднее значение всех элементов последовательности, завершающейся числом 0.Использовать массивы в данной
# задаче нельзя.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
count = 0
x = 0
while n != 0:
    count += n
    x += 1
    n = int(input())
    if n == 0:
        count = count / x
print(count)


# Определите количество четных элементов в последовательности, завершающейся числом 0.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
n = int(input())
x = 0
while n != 0:
    if n != 0 and (n % 2) == 0:
        x += 1
    n = int(input())
print(x)


# Последовательность состоит из натуральных чисел и завершается числом 0.Определите, сколько элементов этой
# последовательности больше предыдущего элемента.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
n = int(input())
biggest = 0
x = 0
while n != 0:
    biggest = n
    n = int(input())
    if n > biggest:
        x += 1
print(x)


# Последовательность состоит из натуральных чисел и завершается числом 0. Определите значение второго по величине
# элемента в этой последовательности, то есть элемента, который будет наибольшим, если из последовательности удалить
# одно вхождение наибольшего элемента.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
n1 = int(input())
n2 = n1
n3 = 0
while n1 != 0:
    n1 = int(input())
    if n1 != 0:
        if n1 >= n2:
            if n2 >= n3:
                n3 = n2
            n2 = n1
        elif n1 <= n2:
            if n1 >= n3:
                n3 = n1
print(n3)


# Последовательность состоит из натуральных чисел и завершается числом 0. Определите, какое количество элементов этой
# последовательности, равны ее наибольшему элементу. Формат ввода - Вводится последовательность целых чисел,
# оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
n1 = int(input())
n2 = n1
n3, x = 0, 1
while n1 != 0:
    n1 = int(input())
    if n1 > n2:
        n2 = n1
        n3 = 0
        x += 1
    elif n1 == n2:
        n2 = n1
        if n3 == 0:
            n3, x = n2, 2
        else:
            x += 1
    elif n1 < n2:
        if n3 == 0:
            n3, x = n2, 1
print(x)


# Последовательность Фибоначчи определяется так:
# F[0] = 0, F[1] = 1, ..., F[n] = F[n-1] + F[n-2].
# По данному числу n определите n-е число Фибоначчи F[n].
# Формат ввода - Вводится натуральное число n.
# Формат вывода - Выведите ответ на задачу.
n1 = int(input())
n2 = 0
n3 = 1
n4 = 0
while n1 > 0:
    if n1 > 0:
        n4 = n2 + n3
        n3 = n2
        n2 = n4
        n1 -= 1
print(n4)


# Последовательность Фибоначчи определяется так:
# F[0]=0, F[1]=1, ..., F[n]=F[n-1]+F[n-2].
# Дано натуральное число A. Определите, каким по счету числом Фибоначчи оно является,то есть выведите такое число n,
# что F[n]=A
# Если А не является числом Фибоначчи,выведите число -1.
# Формат ввода - Вводится натуральное число A.
# Формат вывода - Выведите ответ на задачу.
nf1 = int(input())
nf2 = 0
nf3 = 1
x = 1
while nf3 < nf1:
    if nf1 > 0:
        nf3 = nf2 + nf3
        nf2 = nf3 - nf2
        x += 1
if nf3 == nf1:
    print(x)
else:
    print(-1)


# Исполнитель "Разветвитель" преобразует натуральные числа. У него есть две команды: “Вычесть 1” и “Разделить на 2”,
# первая команда уменьшает число на 1, вторая команда уменьшает число в два раза, если оно четное,иначе происходит
# ошибка. Дано два натуральных числа A и B (A>B). Напишите алгоритм для "Разветвителя", который преобразует число A в
# число B и при этом содержит минимальное число команд. Команды алгоритма нужно выводить по одной в строке, первая
# команда обозначается, как -1, вторая команда как :2.
# Формат ввода - Вводятся два натуральных числа A и B.
# Формат вывода - Выведите ответ на задачу.
a = int(input())
b = int(input())
while a > b:
    if (a // b) > 1:
        if ((a - 1) % 2) == 0:
            a -= 1
            print('-1')
            a //= 2
            print(':2')
        elif ((a - 1) % 2) != 0:
            a //= 2
            print(':2')
    elif (a // b) == 1:
        a -= 1
        print('-1')


# Обращение числа
# Переставьте цифры числа в обратном порядке.
# Формат ввода - Задано единственное число N
# Формат вывода - Необходимо вывести цифры данного числа в обратном порядке.
nr1 = int(input())
nr2 = 0
while nr1 > 0:
    if nr1 > 0:
        nr2 = nr1 % 10
        print(n2, end='')
        nr1 = nr1 // 10


# Количество палиндромов
# Назовем число палиндромом, если оно не меняется при перестановке его цифр в обратном порядке. Напишите программу,
# которая по заданному числу K выводит количество натуральных палиндромов, не превосходящих K.
# Формат ввода - Задано единственное число K (1≤K≤100000).
# Формат вывода - Необходимо вывести количество натуральных палиндромов, не превосходящих K.
k = int(input())
x = 0
while k > 0:
    k1 = k // 10000
    k2 = (k // 1000) % 10
    k3 = (k // 100) % 10
    k4 = (k // 10) % 10
    k5 = k % 10
    if k1 > 0:
        if k1 == k5:
            if k2 == k4:
                x += 1
    elif k1 == 0:
        if k2 > 0:
            if k2 == k5:
                if k3 == k4:
                    x += 1
        elif k2 == 0:
            if k3 > 0:
                if k3 == k5:
                    x += 1
            elif k3 == 0:
                if k4 > 0:
                    if k4 == k5:
                        x += 1
                elif k4 == 0:
                    if k5 > 0:
                        x += 1
    k -= 1
print(x)


# Максимальное число подряд идущих равных
# Дана последовательность натуральных чисел, завершающаяся числом 0. Определите,какое наибольшее число подряд идущих
# элементов этой последовательности равны друг другу.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
n1 = int(input())
n2 = n1
x = 0
x1 = 1
while n1 != 0:
    n1 = int(input())
    if n1 == n2:
        x1 += 1
    elif n1 != n2:
        if x1 > x:
            x, x1 = x1, 1
        elif x1 < x:
            x, x1 = x, 1
        else:
            x, x1 = x1, 1
    n2 = n1
print(x)


# Максимальная длина монотонного фрагмента
# Дана последовательность натуральных чисел, завершающаяся число 0.Определите наибольшую длину монотонного фрагмента
# последовательности(то есть такого фрагмента, где все элементы либо больше предыдущего,либо меньше).
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
nm1 = int(input())
nm2 = n1
nm3 = 0
x = 0
x1 = 1
while nm1 != 0:
    nm1 = int(input())
    if nm1 == nm2 or nm1 == 0:
        if x1 > x:
            x, x1 = x1, 1
        elif x1 < x:
            x, x1 = x, 1
        else:
            x, x1 = x1, 1
    elif nm1 > nm2:
        if nm2 == nm3:
            x1 += 1
        elif nm2 > nm3:
            x1 += 1
        elif nm2 < nm3:
            if x1 > x:
                x, x1 = x1, 1
            elif x1 < x:
                x, x1 = x, 1
            else:
                x, x1 = x1, 1
            x1 += 1
    elif nm1 < nm2:
        if nm2 < nm3:
            x1 += 1
        elif nm2 == nm3:
            x1 += 1
        elif nm2 > nm3:
            if x1 > x:
                x, x1 = x1, 1
            elif x1 < x:
                x, x1 = x, 1
            else:
                x, x1 = x1, 1
            x1 += 1
    nm3 = nm2
    nm2 = nm1
print(x)
# Или
n_max1 = int(input())
n_max2 = n1
n_max3 = 0
x = 0
x1 = 1
while n_max1 != 0:
    n_max1 = int(input())
    if n_max1 == n_max2 or n_max1 == 0:
        if x1 > x:
            x, x1 = x1, 1
        elif x1 < x:
            x, x1 = x, 1
        else:
            x, x1 = x1, 1
    elif n_max1 > n_max2 == n_max3:
        x1 += 1
    elif n_max1 > n_max2 > n_max3:
        x1 += 1
    elif n_max1 > n_max2 < n_max3:
        if x1 > x:
            x, x1 = x1, 1
        elif x1 < x:
            x, x1 = x, 1
        else:
            x, x1 = x1, 1
        x1 += 1
    elif n_max1 < n_max2 < n_max3:
        x1 += 1
    elif n_max1 < n_max2 == n_max3:
        x1 += 1
    elif n_max1 < n_max2 > n_max3:
        if x1 > x:
            x, x1 = x1, 1
        elif x1 < x:
            x, x1 = x, 1
        else:
            x, x1 = x1, 1
        x1 += 1
    n_max3 = n_max2
    n_max2 = n_max1
print(x)


# Наименьшее расстояние между локальными максимумами
# Определите наименьшее расстояние между двумя локальными максимумами последовательности натуральных чисел,
# завершающейся числом 0. Локальным максимумом называется такое число в последовательности, которое больше своих
# соседей. Если в последовательности нет двух локальных максимумов, выведите число 0.Начальное и конечное значение при
# этом локальными максимумами не считаются.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
# Примечания - Пояснение к тестам:
# В первом тесте локальными максимумами являются все двойки (они больше соседей). Между последними - расстояние
# наименьшее.
# Во втором тесте нет локального максимума.


# Неделя 3
# Площадь треугольника
# Даны длины сторон треугольника. Вычислите площадь треугольника.
# Формат ввода - Вводятся три положительных числа.
# Формат вывода - Выведите ответ на задачу.
a = float(input())
b = float(input())
c = float(input())
p = (a + b + c) / 2
s = (p * (p - a) * (p - b) * (p - c)) ** 0.5
print('{0:.6f}'.format(s))


# Сумма ряда
# По данному числу n вычислите сумму 1+(1 / 2²)+(1 / 3²)+...+(1 / n²).
# Формат ввода - Вводится целое положительное число.
# Формат вывода - Выведите ответ на задачу.
n = float(input())
s = 0
while n != 0:
    if n == 1:
        s += 1
        n -= 1
    else:
        s += 1 / (n * n)
        n -= 1
print('{0:.5f}'.format(s))


# Дробная часть
# Дано положительное действительное число X. Выведите его дробную часть.
# Формат ввода - Вводятся положительное действительное число.
# Формат вывода - Выведите ответ на задачу.
x = float(input())
x = x % 1
print('{0:.6f}'.format(x))


# Цена товара
# Цена товара обозначена в рублях с точностью до копеек, то есть действительным числом с двумя цифрами после десятичной
# точки. Запишите в две целочисленные переменные стоимость товара в виде целого числа рублей и целого числа копеек и
# выведите их на экран. При решении этой задачи нельзя пользоваться условными инструкциями и циклами.
# Формат ввода - Вводится неотрицательное действительное число.
# Формат вывода - Выведите ответ на задачу.
p = float(input())
p1 = int(p // 1)
p2 = round((p % 1) * 100)
print(p1, p2)


# Округление по российским правилам
# По российский правилам числа округляются до ближайшего целого числа,а если дробная часть числа равна 0.5, то число
# округляется вверх. Дано неотрицательное число x, округлите его по этим правилам. Обратите внимание, что функция round
# не годится для этой задачи!
# Формат ввода - Вводится неотрицательное число.
# Формат вывода - Выведите ответ на задачу.
n = float(input())
n1 = (int((n * 10) / 1)) % 10
if n1 >= 5:
    n = int(n // 1) + 1
else:
    n = int(n // 1)
print(n)


# Проценты
# Процентная ставка по вкладу составляет P процентов годовых, которые прибавляются к сумме вклада. Вклад составляет X
# рублей Y копеек. Определите размер вклада через год. При решении этой задачи нельзя пользоваться условными
# инструкциями и циклами.
# Формат ввода - Программа получает на вход целые числа P, X, Y.
# Формат вывода - Программа должна вывести два числа: величину вклада через год в рублях и копейках. Дробная часть
# копеек отбрасывается.
p = int(input())
x = int(input())
y = int(input())
p1 = x + ((x * p) / 100)
p2 = ((y + ((y * p) / 100)) // 1) / 100
p3 = p1 + p2
p4 = int(p3 / 1)
p5 = round((p3 % 1) * 100)
print(p4, p5)
# Или
p = int(input())
x = int(input())
y = int(input())
s = x + (y / 100)
s = s + ((s * p) / 100)
x = int(s / 1)
y = int(s * 100) % 100
print(x, y)


# Сложные проценты
# Процентная ставка по вкладу составляет P процентов годовых, которые прибавляются к сумме вклада через год. Вклад
# составляет X рублей Y копеек. Определите размер вклада через K лет.
# Формат ввода - Программа получает на вход целые числа P, X, Y, K.
# Формат вывода - Программа должна вывести два числа: величину вклада через K лет в рублях и копейках. Дробное число
# копеек по истечение года отбрасывается. Перерасчет суммы вклада (с отбрасыванием дробных частей копеек) происходит
# ежегодно.
p = int(input())
x = int(input())
y = int(input())
k = int(input())
while k != 0:
    if k > 0:
        s = x + (y / 100)
        s = s + ((s * p) / 100)
        x = int(s / 1)
        y = int(s * 100) % 100
        k -= 1
print(x, y)


# Схема Горнера
# Дан многочлен P(x)=a[n] xⁿ+a[n₋₁] xⁿ⁻¹+...+a[₁] x+a[₀] и число x. Вычислите значение этого многочлена,
# воспользовавшись схемой Горнера:
# Формат ввода - Сначала программе подается на вход целое неотрицательное число n≤20, затем действительное число x,
# затем следует n+1 вещественное число - коэффициенты многочлена от старшего к младшему.
# Формат вывода - Программа должна вывести значение многочлена.
# Примечания - При решении этой задачи нельзя использовать массивы и операцию возведения в степень. Программа должна
# иметь сложность O(n).
#


# Стандартное отклонение
# Дана последовательность натуральных чисел x₁ x₂ ..., xn. Стандартным отклонением называется величина
# σ = sqrt(((((x₁-s)²+(x₂-s)²+…+(xn-s)²) / (n-1))))
# где s = ((x₁+x₂+…+xn) / n) - среднее арифметическое последовательности, а sqrt - квадратный корень. Определите
# стандартное отклонение для данной последовательности натуральных чисел,завершающейся числом 0.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
#


# Квадратное уравнение - 1
# Даны действительные коэффициенты a, b, c, при этом a != 0. Решите квадратное уравнение ax²+bx+c=0 и выведите все его
# корни.
# Формат ввода - Вводятся три действительных числа.
# Формат вывода - Если уравнение имеет два корня, выведите два корня в порядке возрастания, если один корень - выведите
# одно число, если нет корней - не выводите ничего.
from math import sqrt
a = float(input())
b = float(input())
c = float(input())
d = b ** 2 - 4 * a * c
if d > 0:
    x1 = (-b - sqrt(b ** 2 - (4 * a * c))) / (2 * a)
    x2 = (-b + sqrt(b ** 2 - (4 * a * c))) / (2 * a)
    if x1 < x2:
        print('{0:.5f} {1:.5f}'.format(x1, x2))
    elif x1 > x2:
        print('{0:.5f} {1:.5f}'.format(x2, x1))
elif d == 0:
    x1 = -b / (2 * a)
    print('{0:.5f}'.format(x1))


# Квадратное уравнение - 2
# Даны произвольные действительные коэффициенты a, b, c. Решите уравнение ax²+bx+c=0.
# Формат ввода - Вводятся три действительных числа.
# Формат вывода - Если данное уравнение не имеет корней, выведите число 0. Если уравнение имеет один корень, выведите
# число 1, а затем этот корень. Если уравнение имеет два корня, выведите число 2, а затем два корня в порядке
# возрастания. Если уравнение имеет бесконечно много корней, выведите число 3.


# Система линейных уравнений - 1
# Даны вещественные числа a, b, c, d, e, f. Известно, что система линейных уравнений:
# ax + by = e
# cx + dy = f
# имеет ровно одно решение. Выведите два числа x и y, являющиеся решением этой системы.
# Формат ввода - Вводятся шесть чисел a, b, c, d, e, f - коэффициенты уравнений системы.
# Формат вывода - Выведите ответ на задачу.
a = float(input())
b = float(input())
c = float(input())
d = float(input())
e = float(input())
f = float(input())
x = (e * d - b * f) / (a * d - b * c)
y = (a * f - e * c) / (a * d - b * c)
print('{0:.6f} {1:.6f}'.format(x, y))


# Система линейных уравнений - 2
# Даны числа a, b, c, d, e, f. Решите систему линейных уравнений
# ax + by = e
# cx + dy = f
# Формат ввода - Вводятся 6 чисел a, b, c, d, e, f- коэффициенты уравнений.
# Формат вывода - Вывод программы зависит от вида решения этой системы.
# Если система не имеет решений, то программа должна вывести единственное число 0.
# Если система имеет бесконечно много решений, каждое из которых имеет вид y=px+q, то программа должна вывести число 1,
# а затем значения p и q.
# Если система имеет единственное решение (x₀,y₀), то программа должна вывести число 2, а затем значения x₀ и y₀.
# Если система имеет бесконечно много решений вида x=x₀, y - любое, то программа должна вывести число 3, а затем
# значение x₀.
# Если система имеет бесконечно много решений вида y=y₀, x - любое, то программа должна вывести число 4, а затем
# значение y₀.
# Если любая пара чисел (x,y) является решением, то программа должна вывести число 5.
#


# Делаем срезы
# Формат ввода - Дана строка.
# Формат вывода:
# Сначала выведите третий символ этой строки.
# Во второй строке выведите предпоследний символ этой строки.
# В третьей строке выведите первые пять символов этой строки.
# В четвертой строке выведите всю строку, кроме последних двух символов.
# В пятой строке выведите все символы с четными индексами (считая, что индексация начинается с 0, поэтому символы
# выводятся начиная с первого).
# В шестой строке выведите все символы с нечетными индексами, то есть начиная со второго символа строки.
# В седьмой строке выведите все символы в обратном порядке.
# В восьмой строке выведите все символы строки через один в обратном порядке, начиная с последнего.
# В девятой строке выведите длину данной строки.
s = input()
print(s[2:3])
print(s[-2:-1])
print(s[0:5])
print(s[0:-2])
print(s[::2])
print(s[1::2])
print(s[::-1])
print(s[::-2])
print(len(s))


# Первое и последнее вхождение
# Дана строка. Если в этой строке буква f встречается только один раз, выведите её индекс. Если она встречается два и
# более раз, выведите индекс её первого и последнего появления. Если буква f в данной строке не встречается, ничего не
# выводите. При решении этой задачи нельзя использовать метод count и циклы.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
first = s.find('f')
last = s[::-1].find('f')
last = (len(s) - 1) - last
if first == last and first != -1:
    print(first)
elif first != last and first != -1:
    print(first, last)


# Удаление фрагмента
# Дана строка, в которой буква h встречается минимум два раза.Удалите из этой строки первое и последнее вхождение буквы
# h,а также все символы, находящиеся между ними.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
first = s.find('h')
last = s[::-1].find('h')
last = (len(s) - 1) - last
if first != last and first != -1:
    print(s[:first], s[last + 1:], sep='')


# Дублирование фрагмента
# Дана строка, в которой буква h встречается как минимум два раза. Повторите последовательность символов, заключенную
# между первым и последним появлением буквы h два раза, сами буквы h повторять не надо.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
first = s.find('h')
last = s[::-1].find('h')
last = (len(s) - 1) - last
if first != last and first != -1:
    print(s[:first + 1], s[first + 1:last] * 2, s[last:], sep='')


# Второе вхождение
# Дана строка. Найдите в этой строке второе вхождение буквы f, и выведите индекс этого вхождения. Если буква f в данной
# строке встречается только один раз, выведите число -1, а если не встречается ни разу, выведите число -2. При решении
# этой задачи нельзя использовать метод count.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
first = s.find('f')
second = s.find('f', first + 1)
if second != -1:
    print(second)
elif first != -1 and second == -1:
    print(-1)
elif first == -1:
    print(-2)


# Переставить два слова
# Дана строка, состоящая ровно из двух слов, разделенных пробелом. Переставьте эти слова местами. Результат запишите в
# строку и выведите получившуюся строку. При решении этой задачи нельзя пользоваться циклами и инструкцией if.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
space = s.find(' ')
word1 = s[:space]
word2 = s[space + 1:]
print(word2, word1)


# Количество слов
# Дана строка, состоящая из слов, разделенных пробелами. Определите, сколько в ней слов.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
space = s.count(' ')
print(space + 1)


# Замена подстроки
# Дана строка. Замените в этой строке все цифры 1 на слово one.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
print(s.replace('1', 'one'))


# Удаление символа
# Дана строка. Удалите из этой строки все символы @.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
print(s.replace('@', ''))


# Замена внутри фрагмента
# Дана строка. Замение в этой строке все появления буквы h на букву H, кроме первого и последнего вхождения.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
first_pos = s.find('h')
first = s[:first_pos + 1]
last_pos = s.rfind('h')
last = s[last_pos:]
middle = s[first_pos + 1:last_pos]
print(first, middle.replace('h', 'H'), last, sep='')


# Вставка символов
# Дана строка. Получите новую строку, вставив между двумя символами исходной строки символ *. Выведите полученную
# строку.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
s = input()
old = s
new = ''
while old != '':
    if (len(old)) == 1:
        new += old[0:1]
        old = old[1:]
    elif (len(old)) != 1:
        new += old[0:1] + '*'
        old = old[1:]
print(new)


# Удалить каждый третий символ
# Дана строка. Удалите из нее все символы, чьи индексы делятся на 3.Символы строки нумеруются, начиная с нуля.
# Формат ввода - Вводится строка.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Ввод и вывод осуществлять с помощью файлов
s = input()
old = s
zero = 0
one = 1
new = ''
while old != '':
    if old != '':
        letter = s[zero:one]
        if (s.find(letter) % 3) != 0:
            new += letter
        zero += 1
        one += 1
    old = old[1:]
print(new)


# Неделя 4
# Минимум 4 чисел
# Напишите функцию min4(a, b, c, d), вычисляющую минимум четырех чисел, которая не содержит инструкции if, а использует
# стандартную функцию min от двух чисел. Считайте четыре целых числа и выведите их минимум.
# Формат ввода - Вводятся четыре целых числа.
# Формат вывода - Выведите ответ на задачу.
def min4(am, bm, cm, dm):
    min_am_bm = min(am, bm)
    min_cm_dm = min(cm, dm)
    minimum = min(min_am_bm, min_cm_dm)
    return minimum


a = int(input())
b = int(input())
c = int(input())
d = int(input())
print(min4(a, b, c, d))


# Длина отрезка
# Даны четыре действительных числа: x₁, y₁, x₂, y₂. Напишите функцию distance(x1, y1, x2, y2), вычисляющую расстояние
# между точкой (x₁,y₁) и (x₂,y₂). Считайте четыре действительных числами выведите результат работы этой функции.
# Формат ввода - Вводятся четыре действительных числа.
# Формат вывода - Выведите ответ на задачу.
def distance(px1, py1, px2, py2):
    dist = (((px2 - px1) ** 2) + ((py2 - py1) ** 2)) ** 0.5
    return dist


x1 = float(input())
y1 = float(input())
x2 = float(input())
y2 = float(input())
print('{0:.5f}'.format(distance(x1, y1, x2, y2)))


# Периметр треугольника
# Напишите функцию, вычисляющую длину отрезка по координатам его концов. С помощью этой функции напишите программу,
# вычисляющую периметр треугольника по координатам трех его вершин.
# Формат ввода - На вход программе подается 6 целых чисел - координат x₁, y₁, x₂, y₂, x₃, y₃ вершин треугольника. Все
# числа по модулю не превосходят 30 000.
# Формат вывода - Выведите значение периметра этого треугольника с точностью до 6 знаков после десятичной точки.
def distance(px1, py1, px2, py2):
    dist = (((px2 - px1) ** 2) + ((py2 - py1) ** 2)) ** 0.5
    return dist


def perimeter(ax1, ay1, bx2, by2, cx3, cy3):
    ab = distance(ax1, ay1, bx2, by2)
    bc = distance(bx2, by2, cx3, cy3)
    ac = distance(ax1, ay1, cx3, cy3)
    per = ab + bc + ac
    return '{0:.6f}'.format(per)


x1 = float(input())
y1 = float(input())
x2 = float(input())
y2 = float(input())
x3 = float(input())
y3 = float(input())
print(perimeter(x1, y1, x2, y2, x3, y3))


# Принадлежит ли точка квадрату - 1
# Даны два действительных числа x и y. Проверьте, принадлежит ли точка с координатами (x,y) заштрихованному квадрату
# (включая его границу). Если точка принадлежит квадрату, выведите слово YES, иначе выведите слово NO. На
# рисунке сетка проведена с шагом 1.
# Решение должно содержать функцию IsPointInSquare(x, y), возвращающую True, если точка принадлежит квадрату и False,
# если не принадлежит. Основная программа должна считать координаты точки, вызвать функцию IsPointInSquare и в
# зависимости от возвращенного значения вывести на экран необходимое сообщение. Функция IsPointInSquare не должна
# содержать инструкцию if.
# Формат ввода - Вводятся два действительных числа.
# Формат вывода - Выведите ответ на задачу.
def is_point_in_square(px, py):
    return abs(px) <= 1 and abs(py) <= 1


x = float(input())
y = float(input())
if is_point_in_square(x, y):
    print('YES')
else:
    print('NO')


# Принадлежит ли точка квадрату - 2
# Даны два действительных числа x и y. Проверьте, принадлежит ли точка с координатами(x,y) заштрихованному квадрату
# (включая его границу). Если точка принадлежит квадрату, выведите слово YES,иначе выведите слово NO. На рисунке сетка
# проведена с шагом 1.
# Решение должно содержать функцию is_point_in_square(x, y), возвращающую True, если точка принадлежит квадрату и False,
# если не принадлежит. Основная программа должна считать координаты точки, вызвать функцию is_point_in_square в
# зависимости от возвращенного значения вывести на экран необходимое сообщение.
# Функция IsPointInSquare не должна содержать инструкцию if.
# Формат ввода - Вводятся два действительных числа.
# Формат вывода - Выведите ответ на задачу.


# Принадлежит ли точка кругу
# Даны пять действительных чисел: x, y, xc, yc, r.
# Проверьте, принадлежит ли точка (x,y) кругу с центром (xc, yc) и радиусом r.
# Если точка принадлежит кругу, выведите слово YES, иначе выведите слово NO.
# Решение должно содержать функцию IsPointInCircle(x, y, xc, yc, r), возвращающую True, если точка принадлежит кругу и
# False, если не принадлежит.
# Основная программа должна считать координаты точки, вызвать функцию IsPointInCircle и в зависимости от возвращенного
# значения вывести на экран необходимое сообщение. Функция IsPointInCircle не должна содержать инструкцию if.
# Формат ввода - Вводится пять действительных чисел.
# Формат вывода - Выведите ответ на задачу.
def is_point_in_circle(px, py, cx, cy, cr):
    px_cx = abs(px - cx)
    py_cy = abs(py - cy)
    return ((px_cx ** 2) + (py_cy ** 2)) <= cr ** 2


xp = float(input())
yp = float(input())
xc = float(input())
yc = float(input())
rc = float(input())
if is_point_in_circle(xp, yp, xc, yc, rc):
    print('YES')
else:
    print('NO')


# Принадлежит ли точка области
# Проверьте, принадлежит ли точка данной закрашенной области:
# Если точка принадлежит области (область включает границы), выведите слово YES, иначе выведите слово NO. Решение
# должно содержать функцию IsPointInArea(x, y), возвращающую True, если точка принадлежит области и False, если не
# принадлежит. Основная программа должна считать координаты точки, вызвать функцию IsPointInArea и в зависимости от
# возвращенного значения вывести на экран необходимое сообщение. Функция IsPointInArea не должна содержать инструкцию
# if.
# Формат ввода - Вводится два действительных числа.
# Формат вывода - Выведите ответ на задачу.


# Исключающее ИЛИ
# Напишите функцию xor(x, y) реализующую функцию "Исключающее ИЛИ" двух логических переменных x и y.
# Функция xor должна возвращать True, если ровно один из ее аргументов x или y, но не оба одновременно равны True.
# Формат ввода - Вводится 2 числа - x и y (x и y равны 0 или 1, 0 соответствует значению False, 1 соответствует
# значению True).
# Формат вывода - Необходимо вывести 0 или 1 - значение функции от x и y.
def xor(xx, yy):
    return xx ^ yy


x = int(input())
y = int(input())
if xor(x, y):
    print(1)
else:
    print(0)


# Или
def xor(xx, yy):
    if (xx == 0 and yy == 0) or (xx == 1 and yy == 1):
        return 0
    return 1


x = int(input())
y = int(input())
if xor(x, y):
    print(1)
else:
    print(0)


# Минимальный делитель числа
# Дано натуральное число n>1. Выведите его наименьший делитель, отличный от 1. Решение оформите в виде функции
# MinDivisor(n). Алгоритм должен иметь сложность порядка корня квадратного из n.
# Указание. Если у числа n нет делителя не превосходящего корня из n, то число n - простое и ответом будет само число
# n. А у всех составных чисел обязательно есть делители, отличные от единицы и не превосходящие корня из n.
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
from math import sqrt


def min_divisor(nn, div_min=2):
    if nn > 1:
        while nn % div_min != 0:
            if div_min >= sqrt(nn):
                return nn
            div_min += 1
        return div_min
    return nn


n = int(input())
print(min_divisor(n))


# Проверка числа на простоту
# Дано натуральное число n>1. Проверьте, является ли оно простым. Программа должна вывести слово YES, если
# число простое и NO, если число составное. Решение оформите в виде функции IsPrime(n), которая возвращает True для
# простых чисел и False для составных чисел. Количество действий в программе должно быть пропорционально квадратному
# корню из n.
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
from math import sqrt


def is_prime(nn, div_prime=2):
    if nn > 1:
        if nn == div_prime:
            return 1
        while nn % div_prime != 0:
            if div_prime >= sqrt(nn):
                return 1
            div_prime += 1
        return 0
    return 0


n = int(input())
if is_prime(n):
    print('YES')
else:
    print('NO')


# Возведение в степень
# Дано действительное положительное число a и целое неотрицательное число n. Вычислите aⁿ не используя циклы и
# стандартную функцию pow, а используя рекуррентное соотношение aⁿ=a⋅aⁿ⁻¹.
# Решение оформите в виде функции power(a, n).
# Формат ввода - Вводятся действительное положительное число a и целое неотрицательное число n.
# Формат вывода - Выведите ответ на задачу.
def power(aa, nn):
    if nn == 0:
        return 1
    return aa * power(aa, (nn - 1))


a = float(input())
n = int(input())
print(power(a, n))


# Отрицательная степень
# Дано действительное положительное число a и целое число n. Вычислите aⁿ. Решение оформите в виде функции power(a, n).
# Стандартной функцией возведения в степень пользоваться нельзя.
# Формат ввода - Вводится действительное положительное число a и целое число n.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Здесь не нужна рекурсия.
def power(aa, nn):
    aa1 = aa
    if nn == 0:
        return 1
    elif nn > 0:
        while nn != 1:
            aa = aa * aa1
            nn -= 1
        return aa
    elif nn < 0:
        while nn != -1:
            aa = aa * aa1
            nn += 1
        return 1 / aa


a = float(input())
n = int(input())
print(power(a, n))


# Или
def power(aa, nn):
    aa1 = aa
    if nn > 0:
        while nn != 1:
            aa = aa * aa1
            nn -= 1
        return aa
    elif nn < 0:
        while nn != -1:
            aa = aa * aa1
            nn += 1
        return 1 / aa
    return 1


a = float(input())
n = int(input())
print(power(a, n))


# Сложение без сложения
# Напишите рекурсивную функцию sum(a, b), возвращающую сумму двух целых неотрицательных чисел. Из всех арифметических
# операций допускаются только +1 и -1. Также нельзя использовать циклы.
# Формат ввода - Вводятся два целых числа.
# Формат вывода - Выведите ответ на задачу.
def sum_aa_bb(aa, bb):
    if aa == 0:
        return bb
    elif bb == 0:
        return aa
    elif aa <= bb:
        return sum_aa_bb(aa - 1, bb + 1)
    elif aa >= bb:
        return sum_aa_bb(aa + 1, bb - 1)


a = int(input())
b = int(input())
print(sum_aa_bb(a, b))


# Быстрое возведение в степень
# Возводить в степень можно гораздо быстрее, чем за n умножений! Для этого нужно воспользоваться следующими
# рекуррентными соотношениями: aⁿ = (a²)ⁿ/² при четном n, aⁿ=a⋅aⁿ⁻¹ при нечетном n. Реализуйте алгоритм быстрого
# возведения в степень. Если вы все сделаете правильно,то сложность вашего алгоритма будет O(log n).
# Формат ввода - Вводится действительное число a и целое число n.
# Формат вывода - Выведите ответ на задачу.
def power(aa, nn):
    if nn == 0:
        return 1
    elif nn % 2 == 0:
        return power(aa * aa, nn / 2)
    return aa * power(aa, (nn - 1))


a = float(input())
n = int(input())
print(power(a, n))


# Алгоритм Евклида
# Для быстрого вычисления наибольшего общего делителя двух чисел используют алгоритм Евклида.Он построен на следующем
# соотношении: НОД(a,b)=НОД(b,a % b).
# Реализуйте рекурсивный алгоритм Евклида в виде функции gcd(a, b).
# Формат ввода - Вводится два целых числа.
# Формат вывода - Выведите ответ на задачу.
def gcd(aa, bb):
    if aa >= bb:
        if (aa % bb) == 0:
            return bb
        return gcd(bb, (aa % bb))
    else:
        if (bb % aa) == 0:
            return aa
        return gcd(aa, (bb % aa))


a = int(input())
b = int(input())
print(gcd(a, b))


# Сократите дробь
# Даны два натуральных числа n и m.
# Сократите дробь (n/m), то есть выведите два других числа p и q таких, что (n/m)=(p/q) и дробь (p/q) - несократимая.
# Решение оформите в виде функции ReduceFraction(n, m), получающая значения n и m и возвращающей кортеж из двух чисел
# (return p, q).
# Формат ввода - Вводятся два натуральных числа.
# Формат вывода - Выведите ответ на задачу.
def gcd(aa, bb):
    if aa >= bb:
        if (aa % bb) == 0:
            return bb
        return gcd(bb, (aa % bb))
    else:
        if (bb % aa) == 0:
            return aa
        return gcd(aa, (bb % aa))


def reduce_fraction(nnf, mmf):
    div_fraction = gcd(nnf, mmf)
    if div_fraction == 1:
        return nnf, mmf
    return reduce_fraction(nnf // div_fraction, mmf // div_fraction)


n = int(input())
m = int(input())
p, q = reduce_fraction(n, m)
print(p, q)


# Числа Фибоначчи
# Напишите функцию fibonacci(n), которая по данному целому неотрицательному n возвращает n-e число Фибоначчи. В этой
# задаче нельзя использовать циклы - используйте рекурсию.
# Формат ввода - Вводится целое число.
# Формат вывода - Выведите ответ на задачу.
def fibonacci(nn, nn1=0, nn2=1):
    nn3 = nn1 + nn2
    nn2 = nn1
    nn1 = nn3
    if nn <= 2:
        return 1
    elif nn >= 3:
        return nn3 + fibonacci(nn - 1, nn1, nn2)


n = int(input())
print(fibonacci(n))


# Число сочетаний
# По данным числам n и k (0≤k≤n) вычислите C из. Для решения используйте рекуррентное соотношение
# Решение оформите в виде функции C(n, k).
# Формат ввода - Вводятся целые числа n и k.
# Формат вывода - Выведите ответ на задачу.
def factorial(mmf):
    if mmf == 0:
        return 1
    return mmf * factorial(mmf - 1)


def c(nn, kk):
    if kk == 1:
        return nn
    elif kk == 0:
        return 1
    return factorial(nn) // (factorial(kk) * factorial(nn - kk))


n = int(input())
k = int(input())
print(c(n, k))


# Сумма последовательности
# Дана последовательность чисел, завершающаяся числом 0. Найдите сумму всех этих чисел, не используя цикл.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не
# входит, а служит как признак ее окончания).
# Формат вывода - Выведите ответ на задачу.
def sum_nn():
    nn = int(input())
    if nn == 0:
        return nn
    return nn + sum_nn()


print(sum_nn())


# Разворот последовательности
# Дана последовательность целых чисел, заканчивающаяся числом 0. Выведите эту последовательность в обратном порядке.
# При решении этой задачи нельзя пользоваться массивами и прочими динамическими структурами данных. Рекурсия вам
# поможет.
# Формат ввода - Вводится последовательность целых чисел, оканчивающаяся числом 0.
# Формат вывода - Выведите ответ на задачу.
def rec():
    nn = int(input())
    if nn != 0:
        rec()
        print(nn)
    elif nn == 0:
        print(0)


rec()


# Ханойские башни
# Головоломка “Ханойские башни” состоит из трех стержней, пронумерованных числами 1, 2, 3. На стержень 1 надета
# пирамидка из n дисков различного диаметра в порядке возрастания диаметра. Диски можно перекладывать с одного стержня
# на другой по одному, при этом диск нельзя класть на диск меньшего диаметра.Необходимо переложить всю пирамидку со
# стержня 1 на стержень 3 за минимальное число перекладываний.
# Напишите программу, которая решает головоломку; для данного числа дисков n печатает последовательность перекладываний
# в формате a b c, где a - номер перекладываемого диска, b - номер стержня с которого снимается данный диск, c - номер
# стержня на который надевается данный диск.
# Например, строка 1 2 3 означает перемещение диска номер 1 со стержня2 на стержень 3. В одной строке печатается одна
# команда. Диски пронумерованы числами от 1 до n в порядке возрастания диаметров.
# Программа должна вывести минимальный (по количеству произведенных операций) способ перекладывания пирамидки из данного
# числа дисков.
# Указание: подумайте, как переложить пирамидку из одного диска? Из двух дисков? Из трех дисков? Из четырех дисков?
# Пусть мы научились перекладывать пирамидку из n дисков с произвольного стержня на любой другой, как переложить
# пирамидку из n+1 диска,если можно пользоваться решением для n дисков.
# Напишите функцию move (n, x, y), которая печатает последовательность перекладываний дисков для перемещения пирамидки
# высоты n со стержня номер x на стержень номер y.
# Формат ввода - Вводится натуральное число - количество дисков.
# Формат вывода - Выведите ответ на задачу.


# Теорема Лагранжа
# Теорема Лагранжа утверждает, что любое натуральное число можно представить в виде суммы четырех точных квадратов.
# По данному числу n найдите такое представление: напечатайте от 1 до 4 натуральных чисел, квадраты которых дают в сумме
# данное число.
# Формат ввода - Программа получает на вход одно натуральное число n < 10000.
# Формат вывода - Программа должна вывести от 1 до 4 натуральных чисел, квадраты которых дают в сумме данное число.


# Сумма кубов
# Напишите программу, которая представляет переданное натуральное число в виде суммы не более чем 7 кубов других
# натуральных чисел.
# Формат ввода - Входная строка содержит целое число N, которое нужно представить в виде суммы кубов.
# Формат вывода - Программа должна вывести любое разложение переданного ей числа в виде суммы не более чем 7 кубов
# других натуральных чисел. Если такое разложение невозможно, программа должна вывести число 0.


# Только квадраты
# Напишите программу, которая выбирает из полученной последовательности квадраты целых чисел выводит их в обратном
# порядке. Использовать массив для хранения последовательности не разрешается.
# Формат ввода - Во входных строках записаны целые числа, по одному в каждой строке. В последней строке записано
# число 0.
# Формат вывода - Программа должна вывести элементы полученной последовательности, которые представляют собой квадраты
# целых чисел, в обратном порядке в одну строчку, разделив их пробелами. Если таких нет, программа должна вывести
# число 0.


# Неделя 5
# Ряд - 1
# Даны два целых числа A и B (при этом A≤B). Выведите все числа от A до B включительно.
# Формат ввода - Вводятся два целых числа.
# Формат вывода - Выведите ответ на задачу.
a = int(input())
b = int(input())
for i in range(a, b + 1):
    print(i, end=' ')


# Ряд - 2
# Даны два целых числа A и В. Выведите все числа от A до B включительно, в порядке возрастания,если A < B, или в порядке
# убывания в противном случае.
# Формат ввода - Вводятся два целых числа.
# Формат вывода - Выведите ответ на задачу.
a = int(input())
b = int(input())
if a < b:
    for up in range(a, b + 1):
        print(up, end=' ')
else:
    for down in range(a, b - 1, -1):
        print(down, end=' ')


# Ряд - 3
# Дано натуральное число n. Напечатайте все нечетные натуральные числа в порядке убывания данного числа имеющего
# n-знаков(n-цифр).
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
for i in range(10 ** n - 1, (10 ** (n - 1) - 1), -1):
    if i % 2:
        print(i, end=' ')


# Сумма квадратов
# По данному натуральном n вычислите сумму 1²+2²+3²+...+n².
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
x = 0
while n != 0:
    if n != 0:
        x += n * n
    n -= 1
print(x)

# Или
n = int(input())
x = 0
for i in range(n + 1):
    x += i * i
print(x)


# Флаги
# Напишите программу, которая по данному числу n от 1 до 9 выводит на экран n флагов. Изображение одного флага имеет
# размер 4×4 символов, между двумя соседними флагами также имеется пустой (из пробелов) столбец. Разрешается вывести
# пустой столбец после последнего флага. Внутри каждого флага должен быть записан его номер - число от 1 до n.
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
print('+___ ' * n)
for i in range(1, n + 1):
    print('|', i, ' /', sep='', end=' ')
print()
print('|__\\ ' * n)
print('|    ' * n)


# Количество нулей
# Дано несколько чисел. Подсчитайте, сколько из них равны нулю, и выведите это количество.
# Формат ввода - Сначала вводится число N, затем вводится ровно N целых чисел.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
x = 0
while n != 0:
    m = int(input())
    if m == 0:
        x += 1
    n -= 1
print(x)
# Или
n = int(input())
x = 0
for i in range(n):
    m = int(input())
    if m == 0:
        x += 1
print(x)


# Лесенка
# По данному натуральному n≤9 выведите лесенку из n ступенек, i-я ступенька состоит из чисел от 1 до i без пробелов.
# Формат ввода - Вводится натуральное число.
# Формат вывода - Выведите ответ на задачу.
n = int(input())
for i in range(1, n + 1):
    for ii in range(1, i + 1):
        print(ii, end='')
    print()


# Замечательные числа - 1
# Найдите и выведите все двузначные числа, которые равны удвоенному произведению своих цифр.
# Формат ввода - Программа не требует ввода данных с клавиатуры, просто выводит список искомых чисел.
# Формат вывода - Выведите ответ на задачу.
for i in range(9, 100):
    if 2 * ((i // 10) * (i % 10)) == i:
        print(i)


# Уравнение Диофанта - 2
# Даны числа a, b, c, d, e. Подсчитайте количество таких целых чисел от 0 до 1000, которые являются корнями уравнения
# (ax³+bx²+cx+d)/(x-e)=0,и выведите их количество.
# Формат ввода - Вводятся целые числа a, b, c, d и e.
# Формат вывода - Выведите ответ на задачу.


# Сумма факториалов
# По данному натуральном n вычислите сумму 1!+2!+3!+...+n!.В решении этой задачи можно использовать только один цикл.
# Формат ввода - Вводится натуральное число n.
# Формат вывода - Выведите ответ на задачу.
def sum_factorial(num):
    if num == 0:
        return 1
    return num * sum_factorial(num - 1)


x = 0
n = int(input())
for i in range(1, n + 1):
    x += sum_factorial(i)
print(x)


# Потерянная карточка
# Для настольной игры используются карточки с номерами от 1 до N.Одна карточка потерялась. Найдите ее, зная номера
# оставшихся карточек.
# Формат ввода - Дано число N, далее N-1 номер оставшихся карточек (различные числа от 1 до N).
# Формат вывода - Программа должна вывести номер потерянной карточки.
# Примечания - Для самых умных – массивами и аналогичными структурами данных пользоваться нельзя.


# Замечательные числа - 4
# Даны два четырехзначных числа A и B. Выведите все четырехзначные числа на отрезке от A до B, запись которых является
# палиндромом.
# Формат ввода - Вводятся два целых числа A и B
# Формат вывода - Выведите ответ на задачу.


# Четные индексы
# Выведите все элементы списка с четными индексами (то есть A[0], A[2], A[4], ...). Программа должна быть эффективной и
# не выполнять лишних действий!
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_for_view = list(input().split(' '))
print(*list_for_view[::2])


# Четные элементы
# Выведите все четные элементы списка.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_of_num = list(map(int, input().split()))
for i in list_of_num:
    if (i % 2) == 0:
        print(i, end=' ')


# Количество положительных
# Найдите количество положительных элементов в данном списке.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_of_num = list(map(int, input().split()))
x = 0
for i in list_of_num:
    if i > 0:
        x += 1
print(x)


# Последний максимум
# Найдите наибольшее значение в списке и индекс последнего элемента, который имеет данное значение за один проход по
# списку, не модифицируя этот список и не используя дополнительного списка.
# Выведите два значения.
list_of_num = list(map(int, input().split()))
x_all = 0
x_biggest = 0
n_biggest = 0
for i in list_of_num:
    if i >= n_biggest:
        n_biggest = i
        x_biggest = x_all
    x_all += 1
print(n_biggest, x_biggest)


# Больше предыдущего
# Дан список чисел. Выведите все элементы списка, которые больше предыдущего элемента.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_of_num = list(map(int, input().split()))
index = 0
for i in list_of_num[1:]:
    first = list_of_num[index]
    if i > first:
        print(i, end=' ')
    index += 1


# Возрастает ли список?
# Дан список. Определите, является ли он монотонно возрастающим(то есть верно ли, что каждый элемент этого списка больше
# предыдущего). Выведите YES, если массив монотонно возрастает и NO в противном случае. Решение оформите в виде функции
# is_ascending(A). В данной функции должен быть один цикл while, не содержащий вложенных условий и циклов - используйте
# схему линейного поиска.
def is_ascending(list_a):
    list_len = len(list_a) - 1
    ind = 0
    while ind < list_len and list_a[ind] < list_a[ind + 1]:
        ind += 1
    return 0 if ind < list_len else 1


input_list = list(map(int, input().split()))
if is_ascending(input_list):
    print('YES')
else:
    print('NO')


# Соседи одного знака
# Дан список чисел. Если в нем есть два соседних элемента одного знака, выведите эти числа. Если соседних элементов
# одного знака нет - не выводите ничего. Если таких пар соседей несколько - выведите первую пару.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_of_num = list(map(int, input().split()))
index = 0
for i in list_of_num[1:]:
    first = list_of_num[index]
    second = i
    if (first > 0 and second > 0) or (first < 0 and second < 0):
        print(first, second)
        break
    index += 1


# Больше своих соседей
# Дан список чисел. Определите, сколько в этом списке элементов, которые больше двух своих соседей и выведите количество
# таких элементов.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_of_num = list(map(int, input().split()))
index = 0
x = 0
for i in list_of_num[1:-1]:
    first = list_of_num[index]
    second = i
    third = list_of_num[index + 2]
    if first < second > third:
        x += 1
    index += 1
print(x)


# Наибольший элемент
# Дан список чисел. Выведите значение наибольшего элемента в списке, а затем индекс этого элемента в списке. Если
# наибольших элементов несколько, выведите индекс первого из них.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_i = list(map(int, input().split()))
max_i = list_i[0]
r_index_i = 0
len_list_i = len(list_i)
for i in range(1, len_list_i):
    if list_i[i] > max_i:
        max_i = list_i[i]
        r_index_i = i
print(max_i, r_index_i)


# Наименьший положительный
# Выведите значение наименьшего из всех положительных элементов в списке. Известно, что в списке есть хотя бы один
# положительный элемент, а значения всех элементов списка по модулю не превосходят 1000.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_min_i = list(map(int, input().split()))
min_i = 1000
for i in list_min_i:
    if i > 0:
        if i < min_i:
            min_i = i
print(min_i)


# Или
def max_val_in_list(list_of_val):
    max_val = list_of_val[0]
    len_list_of_val = len(list_of_val)
    for iv in range(1, len_list_of_val):
        if list_of_val[iv] > max_val:
            max_val = list_of_val[iv]
    return max_val


list_min_i = list(map(int, input().split()))
min_i = max_val_in_list(list_min_i)
for i in list_min_i:
    if i > 0:
        if i < min_i:
            min_i = i
print(min_i)


# Наименьший нечетный
# Выведите значение наименьшего нечетного элемента списка, гарантируется, что хотя бы один нечетный элемент в списке
# есть.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
def max_val_in_list(list_of_val):
    max_val = list_of_val[0]
    len_list_of_val = len(list_of_val)
    for iv in range(1, len_list_of_val):
        if list_of_val[iv] > max_val:
            max_val = list_of_val[iv]
    return max_val


list_i_min = list(map(int, input().split()))
i_min = max_val_in_list(list_i_min)
for i in list_i_min:
    if i < i_min and (i % 2) != 0:
        i_min = i
print(i_min)


# Вывести в обратном порядке
# Выведите элементы данного списка в обратном порядке, не изменяя сам список.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_ii = list(map(int, input().split()))
for i in list_ii[::-1]:
    print(i, end=' ')


# Переставить в обратном
# Переставьте элементы данного списка в обратном порядке, затем выведите элементы полученного списка. Эта задача
# отличается от предыдущей тем, что вам нужно изменить значения элементов самого списка, поменяв местами A[0] c A[n-1],
# A[1] с A[n-2], а затем вывести элементы списка подряд.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_ii = list(map(int, input().split()))
reversed_list = list_ii[::-1]
for i in reversed_list:
    print(i, end=' ')


# Удалить элемент
# Дан список из чисел и индекс элемента в списке k. Удалите из списка элемент с индексом k, сдвинув влево все элементы,
# стоящие правее элемента с индексом k.
# Программа получает на вход список, затем число k. Программа сдвигает все элементы,а после этого удаляет последний
# элемент списка при помощи метода pop().
# Программа должна осуществлять сдвиг непосредственно в списке, а не делать это при выводе элементов. Также нельзя
# использовать дополнительный список.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке. В следующей строке вводится одно
# целое число.
# Формат вывода - Выведите ответ на задачу.
list_k = list(map(int, input().split()))
k = int(input())
len_list_k = len(list_k)
for i in range(len_list_k):
    if i == k == 0:
        list_k[i:i + 2] = list_k[i + 1::-1]
        k += 1
    elif i == k != 0:
        list_k[i:i + 2] = list_k[i + 1:i - 1:-1]
        k += 1
list_k.pop()
print(*list_k)


# Вставить элемент
# Дан список целых чисел, число k и значение C. Необходимо вставить в список на позицию с индексом k элемент, равный C,
# сдвинув все элементы, имевшие индекс не менее k, вправо.
# Поскольку при этом количество элементов в списке увеличивается, после считывания списка в его конец нужно будет
# добавить новый элемент, используя метод append.
# Вставку необходимо осуществлять уже в считанном списке, не делая этого при выводе и не создавая дополнительного
# списка.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке. В следующей строке вводятся два
# целых числа.
# Формат вывода - Выведите ответ на задачу.
list_c = list(map(int, input().split()))
k, c = list(map(int, input().split()))
list_c.append(c)
l_c = len(list_c)
for i in range(l_c):
    if i == k == 0:
        list_c[:l_c] = list_c[l_c::-1]
        list_c[i + 1:l_c] = list_c[l_c:i:-1]
    elif i == k:
        list_c[i:l_c] = list_c[l_c:i - 1:-1]
        list_c[i + 1:l_c] = list_c[l_c:i:-1]
print(*list_c)


# Ближайшее число
# Напишите программу, которая находит в массиве элемент, самый близкий по величине к данному числу.
# Формат ввода - В первой строке задается одно натуральное число N, не превосходящее 1000 – размер массива. Во второй
# строке содержатся N чисел – элементы массива(целые числа, не превосходящие по модулю 1000). В третьей строке вводится
# одно целое число x, не превосходящее по модулю 1000.
# Формат вывода - Вывести значение элемента массива, ближайшее к x. Если таких чисел несколько, выведите любое из них.
n = int(input())
list_n = list(map(int, input().split()))
x = int(input())
b = [abs(list_n[i] - x) for i in range(n)]
print(list_n[b.index(min(b))])


# Или
n = int(input())
list_n = list(map(int, input().split()))
x = int(input())
b = []
for i in range(n):
    b.append(abs(list_n[i] - x))
min_x = min(b)
pos_min_x = b.index(min_x)
print(list_n[pos_min_x])


# Шеренга
# Петя перешел в другую школу. На уроке физкультуры ему понадобилось определить свое место в строю.Помогите ему это
# сделать.
# Формат ввода - Программа получает на вход невозрастающую последовательность натуральных чисел, означающих рост каждого
# человека в строю. После этого вводится число X – рост Пети. Все числа во входных данных натуральные и не превышают
# 200.
# Формат вывода - Выведите номер, под которым Петя должен встать в строй. Если в строю есть люди с одинаковым ростом,
# таким же, как у Пети, то он должен встать после них.
li_p = list(map(int, input().split()))
p = int(input())
li_p_len = len(li_p)
ind_p = 0
for i in range(li_p_len):
    if int(li_p[i]) >= p:
        ind_p = i + 1
print(ind_p + 1)


# Или
def is_p_pos(li_h, p_h):
    li_h_len = len(li_h)
    ind_h = 0
    while ind_h < li_h_len and int(li_h[ind_h]) >= p_h:
        ind_h += 1
    return ind_h + 1


list_p = list(map(int, input().split()))
p = int(input())
print(is_p_pos(list_p, p))


# Количество различных элементов
# Дан список, упорядоченный по неубыванию элементов в нем. Определите, сколько в нем различных элементов.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_e = list(map(int, input().split()))
ind_e, count_e = 0, 1
for i in range(1, len(list_e)):
    e = list_e[ind_e]
    if e < list_e[i]:
        count_e += 1
    ind_e += 1
print(count_e)


# Переставить соседние
# Переставьте соседние элементы списка (A[0] c A[1],A[2] c A[3] и т.д.). Если элементов нечетное число, то последний
# элемент остается на своем месте.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
li_re = list(map(int, input().split()))
new_re = []
k = 0
if (len(li_re) % 2) == 0:
    for i in li_re[::2]:
        new_re.append(li_re[k + 1])
        new_re.append(li_re[k])
        k += 2
elif (len(li_re) % 2) != 0:
    for i in li_re[:-1:2]:
        new_re.append(li_re[k + 1])
        new_re.append(li_re[k])
        k += 2
    new_re.append(li_re[-1])
print(*new_re)


# Циклический сдвиг вправо
# Циклически сдвиньте элементы списка вправо(A[0] переходит на место A[1],A[1] на место A[2], ..., последний элемент
# переходит на место A[0]). Используйте минимально возможное количество операций присваивания.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
li_fl = list(map(int, input().split()))
last_fl = li_fl.pop()
print(*[last_fl] + li_fl)


# Переставить min и max
# В списке все элементы различны. Поменяйте местами минимальный и максимальный элемент этого списка.
# Формат ввода - Вводится список целых чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
li_el = list(map(int, input().split()))
ind_max = li_el.index(max(li_el))
max_el = li_el[ind_max]
ind_min = li_el.index(min(li_el))
min_el = li_el[ind_min]
li_el.insert(ind_max, min_el)
li_el.pop(ind_max + 1)
li_el.insert(ind_min, max_el)
li_el.pop(ind_min + 1)
print(*li_el)


# Наибольшее произведение двух чисел
# Дан список, заполненный произвольными целыми числами. Найдите в этом списке два числа, произведение которых
# максимально. Выведите эти числа в порядке неубывания.
# Решение должно иметь сложность O(n), где n - размер списка.
list_el = list(map(int, input().split()))
list_pos, list_neg = [], []
for i in list_el:
    if i > 0:
        list_pos.append(i)
    elif i < 0:
        list_neg.append(i)
if len(list_pos) >= 2 <= len(list_neg):
    f_pos = list_pos.pop(list_pos.index(max(list_pos)))
    s_pos = list_pos.pop(list_pos.index(max(list_pos)))
    f_neg = list_neg.pop(list_neg.index(min(list_neg)))
    s_neg = list_neg.pop(list_neg.index(min(list_neg)))
    if (f_pos * s_pos) > (f_neg * s_neg):
        print(s_pos, f_pos)
    elif (f_pos * s_pos) < (f_neg * s_neg):
        print(f_neg, s_neg)
elif len(list_pos) >= 2 > len(list_neg):
    f_pos = list_pos.pop(list_pos.index(max(list_pos)))
    s_pos = list_pos.pop(list_pos.index(max(list_pos)))
    print(s_pos, f_pos)
elif len(list_pos) < 2 <= len(list_neg):
    f_neg = list_neg.pop(list_neg.index(min(list_neg)))
    s_neg = list_neg.pop(list_neg.index(min(list_neg)))
    print(f_neg, s_neg)


# Наибольшее произведение трех чисел
# В данном списке из n≤10⁵ целых чисел найдите три числа, произведение которых максимально.
# Решение должно иметь сложность O(n), где n - размер списка.
# Выведите три искомых числа в любом порядке.
# https://tproger.ru/problems/max-multiplication-of-three-numbers/


# Количество совпадающих пар
# Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу. Считается, что любые два элемента,
# равные друг другу образуют одну пару, которую необходимо посчитать.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_pair = list(map(int, input().split()))
count_pair = 0
while len(list_pair) > 1:
    f_el = list_pair[0]
    list_pair_len = len(list_pair)
    for i in range(1, list_pair_len):
        if f_el == list_pair[i]:
            count_pair += 1
    list_pair = list_pair[1:]
print(count_pair)


# Уникальные элементы
# Дан список. Выведите те его элементы, которые встречаются в списке только один раз. Элементы нужно выводить в том
# порядке, в котором они встречаются в списке.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_uni = list(map(int, input().split()))
list_uni_len = len(list_uni)
new_list_uni = []
for i in range(list_uni_len):
    if list_uni.count(list_uni[i]) == 1:
        new_list_uni.append(list_uni[i])
print(*new_list_uni)


# Кегельбан
# N кеглей выставили в один ряд, занумеровав их слева направо числами от 1 до N. Затем по этому ряду бросили K шаров,
# при этом i-й шар сбил все кегли с номерами от lᵢ до rᵢ включительно. Определите, какие кегли остались стоять на месте.
# Формат ввода - Программа получает на вход количество кеглей N и количество бросков K. Далее идет K пар чисел lᵢ, rᵢ,
# при этом 1 ≤ lᵢ ≤ rᵢ ≤ N ≤ 100.
# Формат вывода - Программа должна вывести последовательность из N символов, где j-й символ есть “I”, если j-я кегля
# осталась стоять, или “.”, если j-я кегля была сбита.


# Ферзи
# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей
# на доске, определите, есть ли среди них пара бьющих друг друга.
# Формат ввода - Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей.
# Формат вывода - Если ферзи не бьют друг друга, выведите слово NO, иначе выведите YES.


# Сжатие списка
# Дан список целых чисел. Требуется “сжать” его, переместив все ненулевые элементы в левую часть списка, не меняя их
# порядок, а все нули - в правую часть. Порядок ненулевых элементов изменять нельзя, дополнительный список использовать
# нельзя, задачу нужно выполнить за один проход по списку. Распечатайте полученный список.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
l_com = list(map(int, input().split()))
l_com_len = len(l_com)
non_zero_list, zero_list = [], []
for i in range(l_com_len):
    if l_com[i] != 0:
        non_zero_list.append(l_com[i])
    elif l_com[i] == 0:
        zero_list.append(l_com[i])
non_zero_list.extend(zero_list)
print(*non_zero_list)


# Самое частое число
# Дан список. Не изменяя его и не используя дополнительные списки, определите, какое число в этом списке встречается
# чаще всего. Если таких чисел несколько, выведите любое из них.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
l_often = list(map(int, input().split()))
l_often_len = len(l_often)
often_e = l_often[0]
max_often = l_often.count(l_often[0])
for i in range(1, l_often_len):
    if l_often.count(l_often[i]) > max_often:
        max_often = l_often.count(l_often[i])
        often_e = l_often[i]
print(often_e)


# Неделя 6
# Слияние списков
# Даны два списка A и B упорядоченных по неубыванию. Объедините их в один упорядоченный список С (то есть он должен
# содержать len(A)+len(B) элементов). Решение оформите в виде функции merge(A, B), возвращающей новый список. Алгоритм
# должен иметь сложность O(len(A)+len(B)). Модифицировать исходные списки запрещается. Использовать функцию sorted и
# метод sort запрещается.
# Формат ввода - Программа получает на вход два неубывающих списка, каждый в отдельной строке.
# Формат вывода - Программа должна вывести последовательность неубывающих чисел, полученных объединением двух данных
# списков.
def merge(fa, sb):
    fa_len, sb_len = len(fa), len(sb)
    new_list = []
    fa_i, sb_i = 0, 0
    while (fa_len + sb_len) != 0:
        if fa_len != 0 != sb_len:
            if fa[fa_i] <= sb[sb_i]:
                new_list.append(fa[fa_i])
                fa_i += 1
                fa_len -= 1
            elif fa[fa_i] >= sb[sb_i]:
                new_list.append(sb[sb_i])
                sb_i += 1
                sb_len -= 1
        elif fa_len != 0 == sb_len:
            new_list.extend(fa[fa_i:])
            fa_len -= fa_len - sb_len
        elif fa_len == 0 != sb_len:
            new_list.extend(sb[sb_i:])
            sb_len -= sb_len - fa_len
    return new_list


f_li = list(map(int, input().split()))
s_li = list(map(int, input().split()))
print(*merge(f_li, s_li))


# Пересечение множеств
# Даны два списка, упорядоченных по возрастанию (каждый список состоит из различных элементов).
# Найдите пересечение множеств элементов этих списков, то есть те числа, которые являются элементами обоих списков.
# Алгоритм должен иметь сложность O(len(A)+len(B)).
# Решение оформите в виде функции Intersection(A, B). Функция должна возвращать список пересечения данных списков в
# порядке возрастания элементов. Модифицировать исходные списки запрещается.
# Формат ввода - Программа получает на вход два возрастающих списка, каждый в отдельной строке.
# Формат вывода - Программа должна вывести последовательность возрастающих чисел, являющихся элементами обоих списков.
def merge(fia, seb):
    fia_len, seb_len = len(fia), len(seb)
    new_list_e = []
    fia_i, seb_i = 0, 0
    while (fia_len + seb_len) != 0:
        if fia_len != 0 != seb_len:
            if fia[fia_i] == seb[seb_i]:
                new_list_e.append(fia[fia_i])
                fia_i += 1
                seb_i += 1
                fia_len -= 1
                seb_len -= 1
            elif fia[fia_i] > seb[seb_i]:
                seb_i += 1
                seb_len -= 1
            elif fia[fia_i] < seb[seb_i]:
                fia_i += 1
                fia_len -= 1
        elif fia_len != 0 == seb_len:
            fia_len -= fia_len - seb_len
        elif fia_len == 0 != seb_len:
            seb_len -= seb_len - fia_len
    return new_list_e


fi_li = list(map(int, input().split()))
se_li = list(map(int, input().split()))
print(*merge(fi_li, se_li))


# Сортировка
# Отсортируйте данный массив, используя встроенную сортировку.
# Формат ввода - Первая строка входных данных содержит количество элементов в массиве N, N ≤ 10⁵. Далее идет N целых
# чисел, не превосходящих по абсолютной величине 10⁹.
# Формат вывода - Выведите эти числа в порядке неубывания.
cou = int(input())
list_of_e = list(map(int, input().split()))
list_of_e.sort()
print(*list_of_e)


# Обувной магазин
# В обувном магазине продается обувь разного размера. Известно, что одну пару обуви можно надеть на другую, если она
# хотя бы на три размера больше. В магазин пришел покупатель.Требуется определить, какое наибольшее количество пар обуви
# сможет предложить ему продавец так, чтобы он смог надеть их все одновременно.
# Формат ввода - Сначала вводится размер ноги покупателя(обувь меньшего размера он надеть не сможет), в следующей строке
# - размеры каждой пары обуви в магазине через пробел. Размер - натуральное число, не превосходящее 100.
# Формат вывода - Выведите единственное число - максимальное количество пар обуви, которое сможет надеть покупатель.
size = int(input())
list_sizes = list(map(int, input().split()))
list_sizes.sort()
count_sh = 0
for i in list_sizes:
    if i >= size:
        count_sh += 1
        size = i + 3
print(count_sh)


# Создание архива
# Системный администратор вспомнил, что давно не делал архива пользовательских файлов. Однако, объем диска, куда он
# может поместить архив, может быть меньше чем суммарный объем архивируемых файлов.
# Известно, какой объем занимают файлы каждого пользователя.
# Напишите программу, которая по заданной информации о пользователях и свободному объему на архивном диске определит
# максимальное число пользователей, чьи данные можно поместить в архив, при этом используя свободное место как можно
# более полно.
# Формат ввода - Программа получает на вход в одной строке число S – размер свободного места на диске(натуральное, не
# превышает 10000), и число N – количество пользователей(натуральное, не превышает 100), после этого идет N чисел -
# объем данных каждого пользователя (натуральное, не превышает 1000), записанных каждое в отдельной строке.
# Формат вывода - Выведите наибольшее количество пользователей, чьи данные могут быть помешены в архив.
f_u = list(map(int, input().split()))
free = f_u[0]
count_us = f_u[1]
l_u_d_s = []
while count_us > 0:
    if count_us != 0:
        l_in = int(input())
        l_u_d_s.append(l_in)
    count_us -= 1
l_u_d_s.sort()
s_u_d_s = sum(l_u_d_s)
c_us = f_u[1]
while s_u_d_s > free:
    s_u_d_s -= l_u_d_s.pop()
    c_us -= 1
print(c_us)


# Гражданская оборона
# Штаб гражданской обороны Тридесятой области решил обновить план спасения на случай ядерной атаки. Известно, что все n
# селений Тридесятой области находятся вдоль одной прямой дороги. Вдоль дороги также расположены m бомбоубежищ, в
# которых жители селений могут укрыться на случай ядерной атаки.
# Чтобы спасение в случае ядерной тревоги проходило как можно эффективнее, необходимо для каждого селения определить
# ближайшее к нему бомбоубежище.
# Формат ввода - В первой строке вводится число n - количество селений(1 <= n <= 100000). Вторая строка содержит n
# различных целых чисел, i-е из этих чисел задает расстояние от начала дороги до i-го селения. В третьей строке входных
# данных задается число m - количество бомбоубежищ (1 <= m <= 100000). Четвертая строка содержит m различных целых
# чисел, i-е из этих чисел задает расстояние от начала дороги до i-го бомбоубежища. Все расстояния положительны и не
# превышают 10⁹. Селение и убежище могут располагаться в одной точке.
# Формат вывода - Выведите n чисел - для каждого селения выведите номер ближайшего к нему бомбоубежища. Бомбоубежища
# пронумерованы от 1 до m в том порядке, в котором они заданы во входных данных.
# Указание - Создайте список кортежей из пар(позиция селения, его номер в исходном списке), а также аналогичный список
# для бомбоубежищ. Отсортируйте эти списки.
# Перебирайте селения в порядке возрастания.
# Для селения ближайшими могут быть два соседних бомбоубежища, среди них надо выбрать ближайшее. При переходе к
# следующему селению не обязательно искать ближайшее бомбоубежище с самого начала. Его можно искать начиная с позиции,
# найденной для предыдущего города.
# Для хранения ответа используйте список, где индекс будет номером селения, а по этому индексу будет запоминаться номер
# бомбоубежища.
villages_count = int(input())
villages = list(map(int, input().split()))
for v in range(villages_count):
    villages[v] = (villages[v], v + 1)
villages.sort()
shelters_count = int(input())
shelters = list(map(int, input().split()))
for s in range(shelters_count):
    shelters[s] = (shelters[s], s + 1)
shelters.sort()
pl = 0
temp_list = []
for i in range(villages_count):
    if villages[i][0] <= shelters[0][0]:
        temp_list.append((villages[i][1], shelters[0][1]))
    elif villages[i][0] > shelters[-1][0]:
        temp_list.append((villages[i][1], shelters[-1][1]))
    else:
        while villages[i][0] > shelters[pl][0]:
            pl += 1
        previous_shelter = villages[i][0] - shelters[pl - 1][0]
        next_shelter = shelters[pl][0] - villages[i][0]
        if previous_shelter <= next_shelter:
            temp_list.append((villages[i][1], shelters[pl - 1][1]))
            pl -= 1
        else:
            temp_list.append((villages[i][1], shelters[pl][1]))
temp_list.sort(key=lambda vil: vil[0])
for j in range(villages_count):
    temp_list[j] = (temp_list[j][1])
print(*temp_list)


# Или
villages_count = int(input())
villages_list = list(map(int, input().split()))
villages = [(villages_list[v], v + 1) for v in range(villages_count)]
villages.sort()
shelters_count = int(input())
shelters_list = list(map(int, input().split()))
shelters = [(shelters_list[s], s + 1) for s in range(shelters_count)]
shelters.sort()
pl = 0
temp_list = []
for i in range(villages_count):
    if villages[i][0] <= shelters[0][0]:
        temp_list.append((villages[i][1], shelters[0][1]))
    elif villages[i][0] > shelters[-1][0]:
        temp_list.append((villages[i][1], shelters[-1][1]))
    else:
        while villages[i][0] > shelters[pl][0]:
            pl += 1
        previous_shelter = villages[i][0] - shelters[pl - 1][0]
        next_shelter = shelters[pl][0] - villages[i][0]
        if previous_shelter <= next_shelter:
            temp_list.append((villages[i][1], shelters[pl - 1][1]))
            pl -= 1
        else:
            temp_list.append((villages[i][1], shelters[pl][1]))
temp_list.sort()
result_list = [(temp_list[j][1]) for j in range(villages_count)]
print(*result_list)


# Или
def list_of_tuples(elements_count, elements_list):
    temp_elem = [(elements_list[el], el + 1) for el in range(elements_count)]
    temp_elem.sort()
    return temp_elem


def find_shelter(village, shelt_li, ind_sh):
    if village <= shelt_li[0][0]:
        return [shelt_li[0][1], 0]
    if village >= shelt_li[-1][0]:
        return [shelt_li[-1][1], 1]
    while village > shelt_li[ind_sh][0]:
        ind_sh += 1
    if (village - shelt_li[ind_sh - 1][0]) <= (shelt_li[ind_sh][0] - village):
        return [shelt_li[ind_sh - 1][1], ind_sh - 1]
    return [shelt_li[ind_sh][1], ind_sh]


villages_count = int(input())
villages_list = list(map(int, input().split()))
villages = list_of_tuples(villages_count, villages_list)
places_count = int(input())
places_list = list(map(int, input().split()))
places = list_of_tuples(places_count, places_list)
pl = 0
temp_list = []
for i in range(villages_count):
    place = find_shelter(villages[i][0], places, pl)
    temp_list.append((villages[i][1], place[0]))
    pl = place[1]
temp_list.sort()
result_list = [(temp_list[j][1]) for j in range(villages_count)]
print(*result_list)


# Средний балл по классам
# В олимпиаде по информатике принимало участие несколько человек.
# Определите и выведите средние баллы участников олимпиады в 9 классе, в 10 классе, в 11 классе.
# Входные данные - Информация о результатах олимпиады записана в файле, каждая строка которого имеет вид:
# фамилия имя класс балл.
# Фамилия и имя - текстовые строки, не содержащие пробелов. Класс - одно из трех чисел 9, 10, 11. Балл - целое число от
# 0 до 100. В этой задаче файл необходимо считывать построчно, не сохраняя содержимое файла в памяти целиком.
# Выходные данные - Выведите три числа: средние баллы по 9 классу, по 10 классу, по 11 классу. Входной файл в кодировке
# utf-8 (используйте open('input.txt', 'r', encoding='utf8')).
open_file = open('input.txt', 'r', encoding='utf8')
rows = open_file.readlines()
nine, ten, eleven = 0, 0, 0
count_nine, count_ten, count_eleven = 0, 0, 0
for row in rows:
    line = row.split()
    level, score = int(line[2]), int(line[3])
    if level == 9:
        nine += score
        count_nine += 1
    elif level == 10:
        ten += score
        count_ten += 1
    elif level == 11:
        eleven += score
        count_eleven += 1
score_nine = nine / count_nine
score_ten = ten / count_ten
score_eleven = eleven / count_eleven
print(score_nine, score_ten, score_eleven)


# Отсортировать список участников по алфавиту
# Известно, что фамилии всех участников - различны. Сохраните в массивах список всех участников и выведите его,
# отсортировав по фамилии в лексикографическом порядке. При выводе указываете фамилию, имя участника и его балл.
# Используйте для ввода и вывода файлы input.txt и output.txt с указанием кодировки utf8. Например, для чтения откройте
# файл с помощью open('input.txt', 'r', encoding='utf8')
read_file = open('input.txt', 'r', encoding='utf8')
write_file = open('output.txt', 'w', encoding='utf8')
persons = read_file.readlines()
list_participants = []
for person in persons:
    line_person = person.split()
    list_participants.append(line_person)
list_participants.sort(key=lambda firstname: firstname[0])
for participant in list_participants:
    print(participant[0], participant[1], participant[3], file=write_file)
read_file.close()
write_file.close()


# Сортировка подсчетом
# Дан список из N (N≤2*10⁵) элементов, которые принимают целые значения от 0 до 100.
# Отсортируйте этот список в порядке неубывания элементов. Выведите полученный список.
# Решение оформите в виде функции CountSort(A), которая модифицирует передаваемый ей список. Использовать встроенные
# функции сортировки нельзя.
def count_sort(count_list):
    ind_el = 0
    list_elements = [0] * 101
    for element in list_sort:
        list_elements[element] += 1
    for value in range(101):
        while list_elements[value] != 0:
            count_list[ind_el] = value
            ind_el += 1
            list_elements[value] -= 1
    return count_list


list_sort = list(map(int, input().split()))
print(*count_sort(list_sort))


# Клавиатура
# На региональном этапе Всероссийской олимпиады школьников по информатике в 2009 году предлагалась следующая задача.
# Всем известно, что со временем клавиатура изнашивается, и клавиши на ней начинают залипать. Конечно, некоторое время
# такую клавиатуру еще можно использовать, но для нажатий клавиш приходиться использовать большую силу.
# При изготовлении клавиатуры изначально для каждой клавиши задается количество нажатий, которое она должна выдерживать.
# Если знать эти величины для используемой клавиатуры, то для определенной последовательности нажатых клавиш
# можно определить, какие клавиши в процессе их использования сломаются, а какие - нет.
# Требуется написать программу, определяющую, какие клавиши сломаются в процессе заданного варианта эксплуатации
# клавиатуры.
# Формат ввода - Первая строка входных данных содержит целое число n (1≤n≤1000) - количество клавиш на клавиатуре.
# Вторая строка содержит n целых чисел -с₁, с₂, … , сn, где сᵢ (1≤cᵢ≤100000) - количество нажатий,выдерживаемых i-ой
# клавишей. Третья строка содержит целое число k (1≤k≤100000) - общее количество нажатий клавиш, и последняя строка
# содержит k целых чисел pj (1≤pj≤n) - последовательность нажатых клавиш.
# Формат вывода - Программа должна вывести n строк, содержащих информацию об исправности клавиш. Если i-я клавиша
# сломалась, то i-ая строка должна содержать слово YES, если же клавиша работоспособна - слово NO.
keys_count = int(input())
keys = list(map(int, input().split()))
presses_count = int(input())
presses_list = list(map(int, input().split()))
sum_presses = [0] * keys_count
for p in presses_list:
    sum_presses[p - 1] += 1
for i in range(keys_count):
    keys[i] -= sum_presses[i]
for k in keys:
    if k < 0:
        print('YES')
    else:
        print('NO')


# Максимальный балл по классам
# В олимпиаде по информатике принимало участие несколько человек. Победителем олимпиады становится человек, набравший
# больше всех баллов. Победители определяются независимо по каждому классу. Определите количество баллов, которое набрал
# победитель в каждом классе. Гарантируется, что в каждом классе был хотя бы один участник.
# Формат ввода - Информация о результатах олимпиады записана в файле, каждая строка которого имеет вид:фамилия имя класс
# балл.
# Фамилия и имя - текстовые строки, не содержащие пробелов. Класс - одно из трех чисел 9, 10, 11. Балл - целое число от
# 0 до 100.
# В этой задаче файл необходимо считывать построчно, не сохраняя содержимое файла в памяти целиком.
# Формат вывода - Выведите три числа: баллы победителя олимпиады по 9 классу, по 10 классу, по 11 классу. Входной файл в
# кодировке utf-8 (В Python используйте open('input.txt', 'r', encoding='utf8')).
open_results_file = open('input.txt', 'r', encoding='utf8')
lines = open_results_file.readlines()
nine_level, ten_level, eleven_level = [], [], []
for line in lines:
    row = line.split()
    level, score = int(row[2]), int(row[3])
    if level == 9:
        nine_level.append(score)
    elif level == 10:
        ten_level.append(score)
    elif level == 11:
        eleven_level.append(score)
print(max(nine_level), max(ten_level), max(eleven_level))


# Результаты олимпиады
# В олимпиаде участвовало N человек. Каждый получил определенное количество баллов, при этом оказалось, что у всех
# участников разное число баллов. Упорядочите список участников олимпиады в порядке убывания набранных баллов.
# Формат ввода - Программа получает на вход число участников олимпиады N. Далее идет N строк, в каждой строке записана
# фамилия участника, затем, через пробел, набранное им количество баллов.
# Формат вывода - Выведите список участников(только фамилии) в порядке убывания набранных баллов.
count_students = int(input())
list_students = []
while count_students != 0:
    list_students.append(input().split())
    count_students -= 1
list_students.sort(key=lambda rating: int(rating[1]), reverse=True)
for student in list_students:
    print(student[0])


# Количество победителей по классам
# В условиях предыдущей задачи определите количество школьников, ставших победителями в каждом классе. Победителями
# объявляются все, кто набрал наибольшее число баллов по данному классу. Гарантируется, что в каждом классе был хотя бы
# один участник.
# Формат вывода - Выведите три числа: количество победителей олимпиады по 9 классу, по 10 классу, по 11 классу.
pupils_rating_file = open('input.txt', 'r', encoding='utf8')
pupils = pupils_rating_file.readlines()
nine_stage, ten_stage, eleven_stage = [], [], []
for pupil in pupils:
    pupil_line = pupil.split()
    pupil_stage, pupil_score = int(pupil_line[2]), int(pupil_line[3])
    if pupil_stage == 9:
        nine_stage.append(pupil_score)
    elif pupil_stage == 10:
        ten_stage.append(pupil_score)
    elif pupil_stage == 11:
        eleven_stage.append(pupil_score)
count_nine = nine_stage.count(max(nine_stage))
couunt_ten = ten_stage.count(max(ten_stage))
count_eleven = eleven_stage.count(max(eleven_stage))
print(count_nine, couunt_ten, count_eleven)


# Проходной балл
# Для поступления в вуз абитуриент должен предъявить результаты трех экзаменов в виде ЕГЭ, каждый из них оценивается
# целым числом от 0 до 100 баллов. При этом абитуриенты, набравшие менее 40 баллов (неудовлетворительную оценку) по
# любому экзамену из конкурса выбывают. Остальные абитуриенты участвуют в конкурсе по сумме баллов за три экзамена.
# В конкурсе участвует N человек, при этом количество мест равно K. Определите проходной балл, то есть такое количество
# баллов, что количество участников, набравших столько или больше баллов не превосходит K, а при добавлении к ним
# абитуриентов, набравших наибольшее количество баллов среди непринятых абитуриентов, общее число принятых абитуриентов
# станет больше K.
# Формат ввода - Программа получает на вход количество мест K. Далее идут строки с информацией об абитуриентах, каждая
# из которых состоит из имени(текстовая строка содержащая произвольное число пробелов) и трех чисел от 0 до 100,
# разделенных пробелами.
# Используйте для ввода файл input.txt с указанием кодировки utf8.
# Формат вывода - Программа должна вывести проходной балл в конкурсе. Выведенное значение должно быть минимальным
# баллом, который набрал абитуриент, прошедший по конкурсу.
# Также возможны две ситуации, когда проходной балл не определен.
# Если будут зачислены все абитуриенты, не имеющие неудовлетворительных оценок, программа должна вывести число 0.
# Если количество абитуриентов, имеющих равный максимальный балл больше чем K, программа должна вывести число 1.
# Используйте для вывода файл output.txt с указанием кодировки utf8.
def rating_app(kk, nn, rating_list):
    if nn <= kk:
        return 0
    elif rating_list[0] == rating_list[kk]:
        return 1
    ind_app = 1
    direct_sort = sorted(rating_list)
    while nn != 0:
        rating = direct_sort.index(rating_list[kk - ind_app])
        if (nn - rating) <= kk:
            return rating_list[kk - ind_app]
        ind_app += 1


read_app_file = open('input.txt', 'r', encoding='utf8')
write_app_file = open('output.txt', 'w', encoding='utf8')
count_app = int(read_app_file.readline())
applicants = read_app_file.readlines()
l_app = []
for applicant in applicants:
    line_a = applicant.split()
    f_score = int(line_a[-3])
    s_score = int(line_a[-2])
    t_score = int(line_a[-1])
    if (f_score >= 40) and (s_score >= 40) and (t_score >= 40):
        l_app.append(f_score + s_score + t_score)
read_app_file.close()
l_app.sort(reverse=True)
l_app_len = len(l_app)
print(rating_app(count_app, l_app_len, l_app), file=write_app_file)
write_app_file.close()


# Школы с наибольшим числом участников олимпиады
# В олимпиаде по информатике принимало участие N человек. Определите школы, из которых в олимпиаде принимало участие
# больше всего участников. В этой задаче необходимо считывать данные построчно, не сохраняя в памяти данные обо всех
# участниках, а только подсчитывая число участников для каждой школы.
# Формат ввода - Информация о результатах олимпиады записана в файле, каждая из строк которого имеет вид:
# фамилия имя школа балл
# Фамилия и имя - текстовые строки, не содержащие пробелов. Школа - целое число от 1 до 99.
# Балл - целое число от 0 до 100.
# Формат вывода - Выведите номера этих школ в порядке возрастания.
applicants_file = open('input.txt', 'r', encoding='utf8')
applicants = applicants_file.readlines()
member_count = [0] * 100
member_count_list = []
for applicant in applicants:
    applicant_line = applicant.split()
    member_count_list.append(int(applicant_line[2]))
for school in member_count_list:
    member_count[school] += 1
max_members = max(member_count)
schools_list = []
for i in range(100):
    if member_count[i] == max_members:
        schools_list.append(i)
print(*schools_list)


# Максимальный балл не-победителя
# Зачет проводится отдельно в каждом классе. Победителями олимпиады становятся школьники, которые набрали наибольший
# балл среди всех участников в данном классе.
# Для каждого класса определите максимальный балл, который набрал школьник, не ставший победителем в данном классе.
# Формат вывода - Выведите три целых числа.
results_open_file = open('input.txt', 'r', encoding='utf8')
lines_lev = results_open_file.readlines()
lev_nine, lev_ten, lev_eleven = [], [], []
for line_lev in lines_lev:
    row_lev = line_lev.split()
    classroom, second_rating = int(row_lev[2]), int(row_lev[3])
    if classroom == 9:
        lev_nine.append(second_rating)
    elif classroom == 10:
        lev_ten.append(second_rating)
    elif classroom == 11:
        lev_eleven.append(second_rating)
lev_nine.sort()
ind_n = lev_nine.index(max(lev_nine))
lev_ten.sort()
ind_t = lev_ten.index(max(lev_ten))
lev_eleven.sort()
ind_e = lev_eleven.index(max(lev_eleven))
print(max(lev_nine[:ind_n]), max(lev_ten[:ind_t]), max(lev_eleven[:ind_e]))


# Такси
# После затянувшегося совещания директор фирмы решил заказать такси, чтобы развезти сотрудников по домам. Он заказал N
# машин - ровно столько, сколько у него сотрудников. Однако когда они подъехали, оказалось, что у каждого водителя
# такси свой тариф за 1 километр.
# Директор знает, какому сотруднику сколько километров от работы до дома (к сожалению, все сотрудники живут в разных
# направлениях, поэтому нельзя отправить двух сотрудников на одной машине). Теперь директор хочет определить, сколько
# придется заплатить за перевозку всех сотрудников. Естественно, директор хочет заплатить как можно меньшую сумму.
# Формат ввода - В первой строке записаны N чисел через пробел, задающих расстояния в километрах от работы до домов
# сотрудников компании. Во второй строке записаны N чисел - тарифы за проезд одного километра в такси.
# Формат вывода - Выведите одно целое число - наименьшую сумму, которую придется заплатить за доставку всех сотрудников.
data_open_file = open('input.txt', 'r', encoding='utf8')
distance_list = list(map(int, str(*data_open_file.readlines(1)).split()))
tariff_list = list(map(int, str(*data_open_file.readlines(2)).split()))
distance_list.sort()
tariff_list.sort(reverse=True)
for i in range(len(distance_list)):
    distance_list[i] *= tariff_list[i]
distance_tariff = sum(distance_list)
print(distance_tariff)


# Семи-процентный барьер
# В Государственную Думу Федерального Собрания Российской Федерации выборы производятся по партийным спискам. Каждый
# избиратель указывает одну партию, за которую он отдает свой голос. В Государственную Думу попадают партии, которые
# набрали не менее 7% от числа голосов избирателей.
# Дан список партий и список голосов избирателей. Выведите список партий, которые попадут в Государственную Думу.
# Формат ввода - В первой строке входного файла написано слово PARTIES:.
# Далее идет список партий, участвующих в выборах.
# Затем идет строка, содержащая слово VOTES:. За ним идут названия партий, за которые проголосовали избиратели, по
# одному названию в строке. Названия могут быть только строками из первого списка.
# Формат вывода - Программа должна вывести названия партий, получивших не менее 7% от числа голосов в том порядке, в
# котором они следуют в первом списке.
open_data_file = open('input.txt', 'r', encoding='utf8')
read_data = open_data_file.readlines()
full_list, parties_list, votes_list = [], [], []
start = 1
while read_data[start].rstrip() != 'VOTES:':
    parties_list.append(read_data[start].rstrip())
    start += 1
start += 1
read_data_len = len(read_data)
while start < read_data_len:
    votes_list.append(read_data[start].rstrip())
    start += 1
parties_list_len = len(parties_list)
list_parties = [0] * parties_list_len
for par in votes_list:
    if par in parties_list:
        list_parties[parties_list.index(par)] += 1
full_count = sum(list_parties)
for vot in list_parties:
    if vot / full_count >= 0.07:
        print(parties_list[list_parties.index(vot)])


# Упорядочить список партий по числу голосов
# Формат входных данных аналогичен предыдущей задаче. Выведите список всех партий, участвовавших в выборах, отсортировав
# его в порядке убывания количества голосов избирателей, а при равном количестве голосов - в лексикографическом порядке.
def parties_sort(partie_tuple):
    return [-(partie_tuple[0]), partie_tuple[1]]


open_data_file = open('input.txt', 'r', encoding='utf8')
read_data = open_data_file.readlines()
parties_list, votes_list = [], []
start = 1
while read_data[start].rstrip() != 'VOTES:':
    parties_list.append(read_data[start].rstrip())
    start += 1
start += 1
read_data_len = len(read_data)
while start < read_data_len:
    votes_list.append(read_data[start].rstrip())
    start += 1
parties_list_len = len(parties_list)
list_parties = [0] * parties_list_len
for par in votes_list:
    if par in parties_list:
        list_parties[parties_list.index(par)] += 1
result_parties_list = []
for vot in range(len(list_parties)):
    result_parties_list.append([list_parties[vot], parties_list[vot]])
result_parties_list.sort(key=parties_sort)
for i in range(len(parties_list)):
    print(result_parties_list[i][1])


# Неделя 7
# Множества и словари
# Количество различных чисел
# Дан список чисел, который может содержать до 100000 чисел. Определите, сколько в нем встречается различных чисел.
# Формат ввода - Вводится список целых чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
list_check_elements = list(map(int, input().split()))
set_check_elements = set(list_check_elements)
print(len(set_check_elements))
# Или
list_check_elements = map(int, input().split())
set_elements = set(list_check_elements)
print(len(set_check_elements))


# Количество совпадающих
# Даны два списка чисел, которые могут содержать до 100000 чисел каждый. Посчитайте, сколько чисел содержится
# одновременно как в первом списке, так и во втором.
# Примечание. Эту задачу на Питоне можно решить в одну строчку.
# Формат ввода - Вводятся два списка чисел. Все числа каждого списка находятся на отдельной строке.
# Формат вывода - Выведите ответ на задачу.
print(len(set(map(int, input().split())) & set(map(int, input().split()))))


# Пересечение множеств
# Даны два списка чисел, которые могут содержать до 10000 чисел каждый. Выведите все числа, которые входят как в первый,
# так и во второй список в порядке возрастания.
# Примечание. И даже эту задачу на Питоне можно решить в одну строчку.
# Формат ввода - Вводятся два списка целых чисел. Все числа каждого списка находятся на отдельной строке.
# Формат вывода - Выведите ответ на задачу.
# Примечания - Ввод и вывод осуществлять с помощью файлов
lr = open('input.txt', 'r', encoding='utf8')
lw = open('output.txt', 'w', encoding='utf8')
sf = set(map(int, str(*lr.readlines(1)).split()))
ss = set(map(int, str(*lr.readlines(2)).split()))
print(*(sf & ss) | (ss & sf), file=lw)


# Встречалось ли число раньше
# Во входной строке записана последовательность чисел через пробел. Для каждого числа выведите слово YES (в отдельной
# строке), если это число ранее встречалось в последовательности или NO, если не встречалось.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
unit_list = map(int, input().split())
unit_set = set()
for unit in unit_list:
    if unit not in unit_set:
        print('NO')
        unit_set.add(unit)
    else:
        print('YES')


# Кубики
# Аня и Боря любят играть в разноцветные кубики, причем у каждого из них свой набор и в каждом наборе все кубики
# различны по цвету. Однажды дети заинтересовались, сколько существуют цветов таких, что кубики каждого цвета
# присутствуют в обоих наборах. Для этого они занумеровали все цвета случайными числами. На этом их энтузиазм иссяк,
# поэтому вам предлагается помочь им в оставшейся части. Номер любого цвета - это целое число в пределах от 0 до 10⁹.
# Формат ввода - В первой строке входного файла записаны числа N и M - количество кубиков у Ани и Бори соответственно.
# В следующих N строках заданы номера цветов кубиков Ани. В последних M строках номера цветов кубиков Бори.
# Формат вывода - Выведите сначала количество, а затем отсортированные по возрастанию номера цветов таких, что кубики
# каждого цвета есть в обоих наборах, затем количество и отсортированные по возрастанию номера остальных цветов у
# Ани, потом количество и отсортированные по возрастанию номера остальных цветов у Бори.
def data_to_list(person_cubes):
    person_set = set()
    while person_cubes != 0:
        person_set.add(int(read_data.readline()))
        person_cubes -= 1
    return person_set


read_data = open('input.txt', 'r', encoding='utf8')
an_bo = list(map(int, str(*read_data.readlines(1)).split()))
anna, borya = data_to_list(an_bo[0]), data_to_list(an_bo[1])
in_both, in_anna, in_borya = anna & borya, anna - borya, borya - anna
print(len(in_both))
print(*sorted(in_both))
print(len(in_anna))
print(*sorted(in_anna))
print(len(in_borya))
print(*sorted(in_borya))


# Количество слов в тексте
# Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
# последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробелов или
# символами конца строки. Определите, сколько различных слов содержится в этом тексте.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
read_text = open('input.txt', 'r', encoding='utf8')
text_lines = set(read_text.readlines())
text_list = list(map(str, str('\n'.join(text_lines)).split()))
text_set = set(text_list)
print(len(text_set))
# Или
rt = open('input.txt', 'r', encoding='utf8')
print(len(set(map(str, str('\n'.join(rt.readlines())).split()))))
# Или
import sys
print(len(set(map(str, str('\n'.join(sys.stdin.readlines())).split()))))


# Угадай число
# Август и Беатриса играют в игру. Август загадал натуральное число от 1 до n. Беатриса пытается угадать это число, для
# этого она называет некоторые множества натуральных чисел. Август отвечает Беатрисе YES, если среди названных ей
# чисел есть задуманное или NO в противном случае. После нескольких заданных вопросов Беатриса запуталась в том,
# какие вопросы она задавала и какие ответы получила и просит вас помочь ей определить, какие числа мог задумать
# Август.
# Формат ввода - Первая строка входных данных содержит число n - наибольшее число, которое мог загадать Август. Далее
# идут строки, содержащие вопросы Беатрисы. Каждая строка представляет собой набор чисел, разделенных пробелами. После
# каждой строки с вопросом идет ответ Августа: YES или NO. Наконец, последняя строка входных данных содержит одно слово
# HELP.
# Формат вывода - Вы должны вывести(через пробел, в порядке возрастания) все числа, которые мог задумать Август.
avg = int(input())
avg_set = set(range(1, avg + 1))
bea = input()
while bea != 'HELP':
    answer = input()
    if answer == 'YES':
        avg_set &= set(map(int, bea.split()))
    elif answer == 'NO':
        avg_set -= set(map(int, bea.split()))
    bea = input()
print(*sorted(avg_set))


# Угадай число - 2
# Август и Беатриса продолжают играть в игру, но Август начал жульничать. На каждый из вопросов Беатрисы он выбирает
# такой вариант ответа YES или NO, чтобы множество возможных задуманных чисел оставалось как можно больше. Например,
# если Август задумал число от 1 до 5, а Беатриса спросила про числа 1 и 2, то Август ответит NO, а если Беатриса
# спросит про 1, 2, 3, то Август ответит YES. Если же Бетриса в своем вопросе перечисляет ровно половину из задуманных
# чисел, то Август из вредности всегда отвечает NO. Наконец, Август при ответе учитывает все предыдущие вопросы
# Беатрисы и свои ответы на них, то есть множество возможных задуманных чисел уменьшается.
# Формат ввода - Вам дана последовательность вопросов Беатрисы. Приведите ответы Августа на них. Первая строка входных
# данных содержит число n - наибольшее число, которое мог загадать Август. Далее идут строки, содержащие вопросы
# Беатрисы. Каждая строка представляет собой набор чисел, разделенных пробелами. Последняя строка входных данных
# содержит одно слово HELP.
# Формат вывода - Для каждого вопроса Беатрисы выведите ответ Августа на этот вопрос. После этого выведите (через
# пробел, в порядке возрастания) все числа, которые мог загадать Август после ответа на все вопросы Беатрисы.
av = int(input())
av_set = set(range(1, av + 1))
be = input()
temp_be = set()
while be != 'HELP':
    be_set = set(map(int, be.split())) - temp_be
    if (len(be_set) * 2) > len(av_set):
        temp_be |= av_set - be_set
        av_set &= be_set
        print('YES')
    else:
        temp_be |= be_set
        av_set -= be_set
        print('NO')
    be = input()
print(*sorted(av_set))


# Полиглоты
# Каждый из N школьников некоторой школы знает Mᵢ языков. Определите, какие языки знают все школьники и языки, которые
# знает хотя бы один из школьников.
# Формат ввода - Первая строка входных данных содержит количество школьников N. Далее идет N чисел Mᵢ, после каждого из
# чисел идет Mᵢ строк, содержащих названия языков, которые знает i-й школьник. Длина названий языков не превышает 1000
# символов, количество различных языков не более 1000. 1≤N≤1000, 1≤Mᵢ≤500.
# Формат вывода - В первой строке выведите количество языков, которые знают все школьники. Начиная со второй строки -
# список таких языков. Затем - количество языков, которые знает хотя бы один школьник, на следующих строках - список
# таких языков.
pupils_count = int(input())
languages_set = set()
pupil_set = set()
languages_sets_list = []
for pupil in range(pupils_count):
    pupil_languages = int(input())
    for pupil_language in range(pupil_languages):
        language = input()
        pupil_set.add(language)
        languages_set.add(language)
    languages_sets_list.append(pupil_set)
    pupil_set = set()
language_count = 0
languages_list = []
for language in languages_set:
    for pupil_languages in languages_sets_list:
        if language in pupil_languages:
            language_count += 1
    languages_list.append((language, language_count))
    language_count = 0
known_languages = []
for kl in range(len(languages_list)):
    if languages_list[kl][1] == pupils_count:
        known_languages.append(languages_list[kl][0])
print(len(known_languages))
for known in sorted(known_languages):
    print(known)
print(len(languages_set))
for language in sorted(languages_set):
    print(language)


# Пересадки
# На Новом проспекте для разгрузки было решено пустить два новых автобусных маршрута на разных участках проспекта.
# Известны конечные остановки каждого из автобусов. Определите количество остановок, на которых можно пересесть с
# одного автобуса на другой.
# Формат ввода - Вводятся четыре числа, не превосходящие 100, задающие номера конечных остановок. Сначала для первого,
# потом второго автобуса (см. примеры и рисунок).
# Формат вывода - Ваша программа должна выводить одно число – искомое количество остановок.
# Примечания - Пояснения Первый пример (см. рисунок): первый автобус ходит с 3-й остановки по 6-ю и обратно, а второй
# с 2-й по 4-ю и обратно. Пересесть с одного автобуса на другой можно на 3-й и 4-й остановках. Их две. Второй пример:
# автобусы не имеют общих остановок.
stops = list(map(int, input().split()))
one = sorted([stops[0], stops[1]])
two = sorted([stops[2], stops[3]])
common_stops = set(range(one[0], one[1] + 1)) & set(range(two[0], two[1] + 1))
print(len(common_stops))


# Забастовки
# Политическая жизнь одной страны очень оживленная. В стране действует K политических партий, каждая из которых
# регулярно объявляет национальную забастовку. Дни, когда хотя бы одна из партий объявляет забастовку, при условии,
# что это не суббота или воскресенье (когда и так никто не работает), наносят большой ущерб экономике страны. i-я
# партия объявляет забастовки строго каждые bᵢ дней, начиная с дня с номером aᵢ. То есть i-я партия объявляет
# забастовки в дни aᵢ, aᵢ+bᵢ, aᵢ+2bᵢ и т.д. Если в какой-то день несколько партий объявляет забастовку, то это
# считается одной общенациональной забастовкой. В календаре страны N дней, пронумерованных от 1 до N. Первый день года
# является понедельником, шестой и седьмой дни года - выходные, неделя состоит из семи дней.
# Формат ввода - Программа получает на вход число дней в году N (1≤N≤10⁶) и число политических партий K (1≤K≤100).
# Далее идет K строк, описывающие графики проведения забастовок.i-я строка содержит числа aᵢ и bᵢ (1≤aᵢ,bᵢ≤N).
# Формат вывода - Выведите единственное число: количество забастовок, произошедших в течение года.
# Примечания - Первая партия объявляет забастовки в дни 2, 5, 8, 11, 14, 17. Вторая партия объявляет забастовки в дни
# 3, 8, 13, 18. Третья партия - в дни 9 и 17. Дни номер 6, 7, 13, 14 являются выходными. Таким образом,общенациональные
# забастовки пройдут в дни 2, 3, 5, 8, 9, 11, 17, 18.
n, k = map(int, input().split())
weekends = set(range(6, n + 1, 7)) | set(range(7, n + 1, 7))
strikes_count = set()
for i in range(k):
    a, b = map(int, input().split())
    strikes_count |= set(range(a, n + 1, b)) - weekends
print(len(strikes_count))


# Телефонные номера
# Телефонные номера в адресной книге мобильного телефона имеют один из следующих форматов:
# +7<код><номер>8<код><номер><номер>, где <номер> - это семь цифр, а <код> - это три цифры или три цифры в круглых
# скобках. Если код не указан, то считается, что он равен 495. Кроме того, в записи телефонного номера может стоять знак
# “-” между любыми двумя цифрами (см. пример). На данный момент в адресной книге телефона Васи записано всего три
# телефонных номера, и он хочет записать туда еще один. Но он не может понять, не записан ли уже такой номер в
# телефонной книге. Помогите ему! Два телефонных номера совпадают, если у них равны коды и равны номера. Например,
# +7(916)0123456 и 89160123456 - это один и тот же номер.
# Формат ввода - В первой строке входных данных записан номер телефона, который Вася хочет добавить в адресную книгу
# своего телефона. В следующих трех строках записаны три номера телефонов, которые уже находятся в адресной книге
# телефона Васи. Гарантируется, что каждая из записей соответствует одному из трех приведенных в условии форматов.
# Формат вывода - Для каждого телефонного номера в адресной книге выведите YES (заглавными буквами), если он совпадает с
# тем телефонным номером,который Вася хочет добавить в адресную книгу или NO (заглавными буквами) в противном случае.
s_read = open('input.txt')
tel_list = s_read.readlines()
tel_num, tel_dict = '', []
for tel in range(len(tel_list)):
    for j in range(len(tel_list[tel])):
        if tel_list[tel][j].isdigit():
            tel_num += tel_list[tel][j]
    if len(tel_num) == 7:
        tel_num = '495' + tel_num
    else:
        tel_num = tel_num[-10:]
    tel_dict.append(int(tel_num))
    tel_num = ''
for i in tel_dict[1:]:
    print('YES') if tel_dict[0] == i else print('NO')
# Или
phone_list = open('input.txt')
phone_numbers = phone_list.readlines()
for i in range(4):
    for j in '+-()\n':
        phone_numbers[i] = phone_numbers[i].replace(j, '')
    if len(phone_numbers[i]) == 7:
        phone_numbers[i] = '495' + phone_numbers[i]
    else:
        phone_numbers[i] = phone_numbers[i][-10:]
for i in phone_numbers[1:]:
    print('YES') if phone_numbers[0] == i else print('NO')


# Страны и города
# Дан список стран и городов каждой страны. Затем даны названия городов. Для каждого города укажите, в какой стране он
# находится.
# Формат ввода - Программа получает на вход количество стран N. Далее идет N строк, каждая строка начинается с названия
# страны, затем идут названия городов этой страны. Название каждого город состоит из одного слова. В следующей строке
# записано число M, далее идут M запросов - названия каких-то M городов, перечисленных выше.
# Формат вывода - Для каждого из запроса выведите название страны, в котором находится данный город.
n = int(input())
countries = dict()
while n != 0:
    country = list(map(str, input().split()))
    for city in country[1:]:
        countries[city] = country[0]
    n -= 1
m = int(input())
cities = []
while m != 0:
    city = input()
    cities.append(city)
    m -= 1
for city in cities:
    if city in countries:
        print(countries[city])
# Или
n = int(input())
countries_cities, cities = dict(), []
for i in range(n):
    country_cities = list(map(str, input().split()))
    for j in country_cities[1:]:
        countries_cities[j] = country_cities[0]
m = int(input())
for c in range(m):
    cities.append(input())
for city in cities:
    if city in countries_cities:
        print(countries_cities[city])


# Номер появления слова
# Во входном файле (вы можете читать данные из файла input.txt) записан текст. Словом считается последовательность
# непробельных подряд идущих символов. Слова разделены одним или большим числом пробелов или символами конца строки.
# Для каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
input_text = open('input.txt')
loaded = input_text.readlines()
words_list, words_dictionary = [], dict()
for i in loaded:
    words_list.extend(i.split())
    for j in words_list:
        words_dictionary[j] = 0
for w in words_list:
    print(words_dictionary[w], end=' ')
    words_dictionary[w] += 1
# Или
input_text = open('input.txt')
words_list, words_dictionary = [], dict()
words = [words_list.extend(i.split()) for i in input_text.readlines()]
for i in words_list:
    words_dictionary[i] = 0
for j in words_list:
    print(words_dictionary[j], end=' ')
    words_dictionary[j] += 1


# Словарь синонимов
# Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре
# различны. Для одного данного слова определите его синоним.
# Формат ввода - Программа получает на вход количество пар синонимов N. Далее следует N строк, каждая строка содержит
# ровно два слова-синонима. После этого следует одно слово.
# Формат вывода - Программа должна вывести синоним к данному слову.
# Примечания - Эту задачу можно решить и без словарей (сохранив все входные данные в списке), но решение со словарем
# будет более простым.
n = int(input())
synonyms = dict()
for i in range(n):
    a, b = input().split()
    synonyms[a] = b
    synonyms[b] = a
print(synonyms[input()])


# Выборы в США
# Как известно, в США президент выбирается не прямым голосованием, а путем двухуровневого голосования. Сначала
# проводятся выборы в каждом штате и определяется победитель выборов в данном штате. Затем проводятся государственные
# выборы: на этих выборах каждый штат имеет определенное число голосов - число выборщиков от этого штата. На практике,
# все выборщики от штата голосуют в соответствии с результатами голосования внутри штата, то есть на заключительной
# стадии выборов в голосовании участвуют штаты, имеющие различное число голосов. Вам известно за кого проголосовал
# каждый штат и сколько голосов было отдано данным штатом. Подведите итоги выборов: для каждого из участника голосования
# определите число отданных за него голосов.
# Формат ввода - Каждая строка входного файла содержит фамилию кандидата, за которого отдают голоса выборщики этого
# штата, затем через пробел идет количество выборщиков,отдавших голоса за этого кандидата.
# Формат вывода - Выведите фамилии всех кандидатов в лексикографическом порядке,затем, через пробел, количество отданных
# за них голосов.
votes = open('input.txt')
votes_list = [i.split() for i in votes.readlines()]
votes_dict = dict()
for j in votes_list:
    if j[0] not in votes_dict:
        votes_dict[j[0]] = int(j[1])
    else:
        votes_dict[j[0]] += int(j[1])
for vote in sorted(votes_dict):
    print(vote, votes_dict[vote])
# Или
votes = open('input.txt')
votes_list = [i.split() for i in votes.readlines()]
votes_dict = dict()
for j in votes_list:
    votes_dict[j[0]] = votes_dict.get(j[0], 0) + int(j[1])
for vote in sorted(votes_dict):
    print(vote, votes_dict[vote])


# Самое частое слово
# Дан текст. Выведите слово, которое в этом тексте встречается чаще всего. Если таких слов несколько, выведите то,
# которое меньше в лексикографическом порядке.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
def w_dict_sort(w_elem):
    return w_elem[1], w_elem[0]


text_open = open('input.txt')
w_list, w_dict = [], dict()
w = [w_list.extend(i.split()) for i in text_open.readlines()]
for i in w_list:
    w_dict[i] = w_dict.get(i, 0) - 1
print(sorted(w_dict.items(), key=w_dict_sort)[0][0])


# Частотный анализ
# Дан текст. Выведите все слова, встречающиеся в тексте, по одному на каждую строку. Слова должны быть отсортированы по
# убыванию их количества появления в тексте, а при одинаковой частоте появления - в лексикографическом порядке.
# Указание.
# После того, как вы создадите словарь всех слов, вам захочется отсортироватьего по частоте встречаемости слова.
# Желаемого можно добиться, если создать список, элементами которого будут кортежи из двух элементов:
# частота встречаемости словаи само слово. Например, [(2, 'hi'), (1, 'what'), (3, 'is')]. Тогда стандартная сортировка
# будет сортировать список кортежей, при этом кортежи сравниваются по первому элементу, а если они равны -то по второму.
# Это почти то, что требуется в задаче.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
def dict_words_sort(element_word):
    return element_word[1], element_word[0]


open_text = open('input.txt')
list_words, dict_words = [], dict()
extend_words = [list_words.extend(i.split()) for i in open_text.readlines()]
for i in list_words:
    dict_words[i] = dict_words.get(i, 0) - 1
for word in sorted(dict_words.items(), key=dict_words_sort):
    print(word[0])


# Выборы Президента
# В выборах Президента Российской Федерации побеждает кандидат, набравший свыше половины числа голосов избирателей. Если
# такого кандидата нет, то во второй тур выборов выходят два кандидата, набравших наибольшее число голосов.
# Формат ввода - Каждая строка входного файла содержит имя кандидата, за которого отдал голос один избиратель. Известно,
# что общее число кандидатов не превосходит 20, но в отличии от предыдущих задач список кандидатов явно не задан.
# Читайте данные из файла input.txt с указанием кодировки utf8.
# Формат вывода - Если есть кандидат, набравший более 50% голосов, программа должна вывести его имя. Если такого
# кандидата нет, программа должна вывести имя кандидата, занявшего первое место, затем имя кандидата, занявшего второе
# место. Выводите данные в файл output.txt с указанием кодировки utf8.
def dict_words_sort(element_word):
    return element_word[1], element_word[0]


cand_r = open('input.txt', 'r', encoding='utf8')
cand_w = open('output.txt', 'w', encoding='utf8')
list_cand, dict_cand = [], dict()
c = [list_cand.extend(i.strip().split('\n')) for i in cand_r.readlines()]
count_c = 0
for i in list_cand:
    dict_cand[i] = dict_cand.get(i, 0) - 1
    count_c -= 1
dict_cand = sorted(dict_cand.items(), key=dict_words_sort)
if ((dict_cand[0][1] * 100) / count_c) > 50:
    print(dict_cand[0][0], file=cand_w)
else:
    print(dict_cand[0][0], dict_cand[1][0], sep='\n', file=cand_w)


# Выборы Государственной Думы
# Статья 83 закона “О выборах депутатов Государственной Думы Федерального Собрания Российской Федерации” определяет
# следующий алгоритм пропорционального распределения мест в парламенте.
# Необходимо распределить 450 мест между партиями, участвовавших в выборах. Сначала подсчитывается сумма голосов
# избирателей, поданных за каждую партию и подсчитывается сумма голосов, поданных за все партии. Эта сумма делится на
# 450, получается величина, называемая “первое избирательное частное” (смысл первого избирательного частного - это
# количество голосов избирателей, которое необходимо набрать для получения одного места в парламенте). Далее каждая
# партия получает столько мест в парламенте, чему равна целая часть от деления числа голосов за данную партию на первое
# избирательное частное.Если после первого раунда распределения мест сумма количества мест, отданных партиям, меньше
# 450, то оставшиеся места передаются по одному партиям, в порядке убывания дробной части частного от деления числа
# голосов за данную партию на первое избирательное частное. Если же для двух партий эти дробные части равны, то
# преимущество отдается той партии, которая получила большее число голосов.
# Формат ввода - На вход программе подается список партий, участвовавших в выборах. Каждая строка входного файла
# содержит название партии (строка, возможно, содержащая пробелы), затем, через пробел, количество голосов, полученных
# данной партией – число, не превосходящее 10⁸.
# Формат вывода - Программа должна вывести названия всех партий и количество голосов в парламенте, полученных данной
# партией. Названия необходимо выводить в том же порядке, в котором они шли во входных данных.
def sd(pe):
    return ((pe[1] - int(pe[1])) * 100), pe[0]


par_r = open('input.txt', 'r', encoding='utf8')
par_w = open('output.txt', 'w', encoding='utf8')
list_par, dict_par, count_p, new_count_p = [], dict(), 0, 0
temp = [list_par.append(i.split()) for i in par_r.readlines()]
for i in list_par:
    i = [' '.join(i[:-1]), int(i[-1])]
    dict_par[i[0]] = dict_par.get(i[0], 0)
    count_p += int(i[-1])
for i in list_par:
    i = [' '.join(i[:-1]), int(i[-1])]
    dict_par[i[0]] = int(i[1]) / (count_p / 450)
    new_count_p += int(dict_par[i[0]])
if new_count_p == 450:
    for i in dict_par:
        print(i, round(dict_par[i]), file=par_w)
else:
    count_par = 450 - new_count_p
    for i in range(count_par):
        dict_par[sorted(dict_par.items(), key=sd, reverse=True)[i][0]] += 1
    for i in dict_par:
        print(i, int(dict_par[i]), file=par_w)


# Продажи
# Дана база данных о продажах некоторого интернет-магазина. Каждая строка входного файла представляет собой запись вида
# Покупатель товар количество, где Покупатель - имя покупателя (строка без пробелов), товар - название товара (строка
# без пробелов), количество - количество приобретенных единиц товара. Создайте список всех покупателей, а для каждого
# покупателя подсчитайте количество приобретенных им единиц каждого вида товаров.
# Формат ввода - Вводятся сведения о покупках в указанном формате.
# Формат вывода - Выведите список всех покупателей в лексикографическом порядке, после имени каждого покупателя выведите
# двоеточие, затем выведите список названий всех приобретенных данным покупателем товаров в лексикографическом порядке,
# после названия каждого товара выведите количество единиц товара, приобретенных данным покупателем. Информация о каждом
# товаре выводится в отдельной строке.
read_sale = open('input.txt')
dict_sale = dict()
list_sale = [(i.split()[0], i.split()[1], int(i.split()[2]))
             for i in read_sale.readlines()]
for i in list_sale:
    if i[0] not in dict_sale:
        dict_sale[i[0]] = dict_sale.get(i[0], {i[1]: i[2]})
    else:
        dict_sale[i[0]][i[1]] = dict_sale[i[0]].get(i[1], 0) + i[2]
for i in sorted(dict_sale):
    print(i, ':', sep='')
    for j in sorted(dict_sale[i]):
        print(j, dict_sale[i][j])


# Банковские счета
# Некоторый банк хочет внедрить систему управления счетами клиентов, поддерживающую следующие операции:
# Пополнение счета клиента.
# Снятие денег со счета.
# Запрос остатка средств на счете.
# Перевод денег между счетами клиентов.
# Начисление процентов всем клиентам.
# Вам необходимо реализовать такую систему. Клиенты банка идентифицируются именами(уникальная строка, не содержащая
# пробелов). Первоначально у банка нет ни одного клиента. Как только для клиента проводится операция пололнения, снятия
# или перевода денег, ему заводится счет с нулевым балансом. Все дальнейшие операции проводятся только с этим счетом.
# Сумма на счету может быть как положительной, так и отрицательной, при этом всегда является целым числом.
# Формат ввода - Входной файл содержит последовательность операций. Возможны следующие операции:
# DEPOSIT name sum - зачислить сумму sum на счет клиента name. Если у клиента нет счета, то счет создается.
# WITHDRAW name sum - снять сумму sum со счета клиента name. Если у клиента нет счета, то счет создается.
# BALANCE name - узнать остаток средств на счету клиента name.
# TRANSFER name1 name2 sum - перевести сумму sum со счета клиента name1 на счет клиента name2. Если у какого-либо
# клиента нет счета, то ему создается счет.
# INCOME p - начислить всем клиентам, у которых открыты счета, p% от суммы счета. Проценты начисляются только клиентам с
# положительным остатком на счету, если у клиента остаток отрицательный, то его счет не меняется. После начисления
# процентов сумма на счету остается целой, то есть начисляется только целое число денежных единиц. Дробная часть
# начисленных процентов отбрасывается.
# Формат вывода - Для каждого запроса BALANCE программа должна вывести остаток на счету данного клиента. Если же у
# клиента с запрашиваемым именем не открыт счет в банке, выведите ERROR.
clients_data = open('input.txt')
dict_data = dict()
list_data = [i.split() for i in clients_data.readlines()]
for i in list_data:
    if i[0] == 'DEPOSIT':
        dict_data[i[1]] = dict_data.get(i[1], 0) + int(i[2])
    elif i[0] == 'WITHDRAW':
        dict_data[i[1]] = dict_data.get(i[1], 0) - int(i[2])
    elif i[0] == 'TRANSFER':
        dict_data[i[1]] = dict_data.get(i[1], 0) - int(i[3])
        dict_data[i[2]] = dict_data.get(i[2], 0) + int(i[3])
    elif i[0] == 'INCOME':
        for j in dict_data:
            if dict_data[j] > 0:
                dict_data[j] += (int(i[1]) * dict_data[j]) // 100
    elif i[0] == 'BALANCE':
        if i[1] in dict_data:
            print(dict_data[i[1]])
        else:
            print('ERROR')


# Контрольная по ударениям
# Учительница задала Пете домашнее задание - в заданном тексте расставить ударения в словах, после чего поручила Васе
# проверить это домашнее задание. Вася очень плохо знаком с данной темой,поэтому он нашел словарь, в котором указано,
# как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах,
# которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено
# ровно одно ударение.
# Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Вася решил, что в этом
# случае если то, как Петя поставил ударение, соответствует одному из приведенных в словаре вариантов, он будет
# засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку. Вам дан словарь, которым
# пользовался Вася и домашнее задание, сданное Петей. Ваша задача - определить количество ошибок,которое в этом задании
# насчитает Вася.
# Формат ввода - Вводится сначала число N - количество слов в словаре (0≤N≤20000). Далее идет N строк со словами из
# словаря. Каждое слово состоит не более чем из 30 символов. Все слова состоят из маленьких и заглавных латинских букв.
# В каждом слове заглавная ровно одна буква - та, на которую попадает ударение. Слова в словаре расположены в алфавитном
# порядке. Если есть несколько возможностей расстановки ударения в одном и том же слове, то эти варианты в словаре идут
# в произвольном порядке.
# Далее идет упражнение, выполненное Петей. Упражнение представляет собой строку текста, суммарным объемом не более
# 300000 символов. Строка состоит из слов, которые разделяются между собой ровно одним пробелом. Длина каждого слова не
# превышает 30 символов. Все слова состоят из маленьких и заглавных латинских букв (заглавными обозначены те буквы, над
# которыми Петя поставил ударение). Петя мог по ошибке в каком-то слове поставить более одного ударения или не поставить
# ударения вовсе.
# Формат вывода - Выведите количество ошибок в Петином тексте, которые найдет Вася.
# Примечания
# Примечания к примерам тестов
# 1. В слове cannot, согласно словарю возможно два варианта расстановки ударения. Эти варианты в словаре могут быть
# перечислены в любом порядке (т.е. как сначала cAnnot, а потом cannOt, так и наоборот). Две ошибки, совершенные Петей -
# это слова be (ударение вообще не поставлено) и fouNd (ударение поставлено неверно). Слово thE отсутствует в словаре,
# но поскольку в нем Петя поставил ровно одно ударение, признается верным.
# 2. Неверно расставлены ударения во всех словах, кроме The (оно отсутствует в словаре, в нем поставлено ровно одно
# ударение). В остальных словах либо ударные все буквы (в слове PAGE), либо не поставлено ни одного ударения.
n = int(input())
dictionary = dict()
while n != 0:
    word = input()
    dictionary[word.lower()] = dictionary.get(word.lower(), []) + [word]
    n -= 1
exercise = input().split()
mistakes = 0
for i in exercise:
    if i.lower() not in dictionary:
        if sum(map(str.isupper, i)) != 1:
            mistakes += 1
    elif i.lower() in dictionary:
        if i not in dictionary[i.lower()]:
            mistakes += 1
print(mistakes)


# Родословная: подсчет уровней
# В генеалогическом древе у каждого человека, кроме родоначальника, есть ровно один родитель. Каждом элементу дерева
# сопоставляется целое неотрицательное число, называемое высотой. У родоначальника высота равна 0, у любого другого
# элемента высота на 1 больше, чем у его родителя.Вам дано генеалогическое древо, определите высоту всех его элементов.
# Формат ввода - Программа получает на вход число элементов в генеалогическом древе N. Далее следует N-1 строка,
# задающие родителя для каждого элемента древа, кроме родоначальника.Каждая строка имеет вид имя_потомка имя_родителя.
# Формат вывода - Программа должна вывести список всех элементов древа в лексикографическом порядке.После вывода имени
# каждого элемента необходимо вывести его высоту.
# Примечания - Эта задача имеет решение сложности O(n), но вам достаточнонаписать решение сложности O(n²) (не считая
# сложности обращенияк элементам словаря).Пример ниже соответствует приведенному древу рода Романовых.
n = int(input()) - 1
tree = dict()
for i in range(n):
    name = input().split()
    if name[0] not in tree:
        tree[name[0]] = tree.get(name[0], {name[1]})
        if name[1] not in tree:
            tree[name[1]] = tree.get(name[1], set())
        else:
            tree[name[0]] |= tree[name[1]]
    else:
        tree[name[0]] |= {name[1]}
        if name[1] not in tree:
            tree[name[1]] = tree.get(name[1], set())
        else:
            tree[name[0]] |= tree[name[1]]
    for j in tree:
        if name[0] in tree[j]:
            tree[j] |= tree[name[0]]
        elif name[1] in tree:
            tree[name[0]] |= tree[name[1]]
for i in sorted(tree):
    print(i, len(tree[i]))
# Или
tree_read = open('input.txt')
n = int(tree_read.readline()) - 1
tree = dict()
while n != 0:
    name = tree_read.readline().split()
    if name[0] not in tree:
        tree[name[0]] = tree.get(name[0], {name[1]})
        if name[1] not in tree:
            tree[name[1]] = tree.get(name[1], set())
        else:
            tree[name[0]] |= tree[name[1]]
    else:
        tree[name[0]] |= {name[1]}
        if name[1] not in tree:
            tree[name[1]] = tree.get(name[1], set())
        else:
            tree[name[0]] |= tree[name[1]]
    for j in tree:
        if name[0] in tree[j]:
            tree[j] |= tree[name[0]]
        elif name[1] in tree:
            tree[name[0]] |= tree[name[1]]
    n -= 1
for i in sorted(tree):
    print(i, len(tree[i]))


# Неделя 8
# Количество различных чисел
# Дан список чисел, который может содержать до 100000 чисел. Определите, сколько в нем встречается различных чисел.
# Формат ввода - Вводится список целых чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
print(len(set(map(int, input().split()))))
# Или
print(
    len(
        set(
            map(
                int,
                input().split()
            )
        )
    )
)


# Количество слов в тексте
# Во входном файле (вы можете читать данные из sys.stdin, подключив библиотеку sys) записан текст. Словом считается
# последовательность непробельных символов идущих подряд, слова разделены одним или большим числом пробеловили
# символами конца строки. Определите, сколько различных слов содержится в этом тексте.
# Формат ввода - Вводится текст.
# Формат вывода - Выведите ответ на задачу.
import sys
print(len(set(map(str, str('\n'.join(sys.stdin.readlines())).split()))))
# Или
import sys
print(
    len(
        set(
            map(
                str,
                str(
                    '\n'.join(
                        sys.stdin.readlines()
                    )
                ).split()
            )
        )
    )
)


# Наименьший нечетный
# Выведите значение наименьшего нечетного элемента списка, гарантируется, что хотя бы один нечётный элемент в списке
# есть.
# Формат ввода - Вводится список чисел. Все числа списка находятся на одной строке.
# Формат вывода - Выведите ответ на задачу.
print(min(filter(lambda odd: (odd % 2) != 0, map(int, input().split()))))
# Или
print(
    min(
        filter(
            lambda odd: (odd % 2) != 0,
            map(
                int,
                input().split()
            )
        )
    )
)


# Ноль или не ноль
# Проверьте, есть ли среди данных N чисел нули.
# Формат ввода - Вводится число N, а затем N чисел.
# Формат вывода - Выведите True, если среди введенных чисел есть хотя бы один нуль, или False в противном случае.
print(
    any(
        map(
            lambda number: int(number) == 0,
            str(
                '\n'.join(
                    open(
                        'input.txt'
                    ).readlines()
                )
            ).split()
        )
    )
)


# Произведение пятых степеней
# На вход подаётся последовательность натуральных чисел длины n≤1000. Посчитайте произведение пятых степеней чисел в
# последовательности.
# Формат ввода - Вводится последовательность чисел
# Формат вывода - Выведите ответ на задачу
# Примечания - Для решения задачи используйте функцию reduce из модуля functools
from functools import reduce

print(
    reduce(
        lambda x, y: x * y,
        map(
            int,
            input().split()
        )
    ) ** 5
)


# XOR
# Булева функция XOR (сложение по модулю два) задаётся следующей таблицей истинности:
# xor(0,0)=0
# xor(0,1)=1
# xor(1,0)=1
# xor(1,1)=0
# На вход подаются две последовательности (a₁,…,an) и (b₁,…,bn) из 0 и 1.
# Вычислите последовательность из (c₁,…,cn), где каждая cᵢ=xor(aᵢ,bᵢ).
# Формат ввода - На вход подаются две строки из 0 и 1, разделённых пробелами.
# Первая строка — это последовательность (a₁,…,an).
# Вторая строка — это последовательность (b₁,…,bn).
# Формат вывода - Выведите последовательность (c₁,…,cn), разделяя каждый элемент пробелом
# Примечания - Для решения задачи можете использовать функцию zip.
print(
    *map(
        lambda x: int(bool(x[0]) ^ bool(x[1])),
        zip(
            map(
                int,
                input().split()
            ),
            map(
                int,
                input().split()
            )
        )
    )
)


# Частичные суммы
# По заданной последовательности:
# (a₁,…,an)
# посчитайте последовательность частичных сумм:
# (S₁,…,Sn),
# где Sk=a₁+a₂+…+ak.
# Формат ввода - Вводится последовательность чисел (a₁,…,an), разделённая пробелами.
# Формат вывода - Выведите последовательность (S₁,…,Sn), разделяя числа пробелами.
# Примечания - Для решения задачи можно воспользоваться функцией accumulate из модуля itertools.
from itertools import accumulate

print(
    *accumulate(
        map(
            int,
            input().split()
        ),
        lambda firs_x, second_x: firs_x + second_x
    )
)


# Факториалы
# По заданному на входе числу 0≤n≤2000 выведите последовательность факториалов:
# 0!,1!,2!,…,n!
# Формат ввода - Вводится число n.
# Формат вывода - Выведите последовательность факториалов, разделяя числа пробелами
from itertools import accumulate

print(
    1,
    *accumulate(
        range(
            1,
            int(input()) + 1
        ),
        lambda one_x, one_y: one_x * one_y
    )
)

