#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys  # Импорт модуля sys

# Глава 2
# Переменные
print('Переменные:')
# Все данные в языке Python представлены объектами. Каждый объект имеет тип данных и значение. Для доступа к объекту
# предназначены переменные. При инициализации в переменной сохраняется ссылка на объект (адрес объекта в памяти
# компьютера). Благодаря этой ссылке можно в дальнейшем изменять объект из программы.


# 2.1 Именование переменных
print('Именование переменных:')
# Каждая переменная должна иметь уникальное имя, состоящее из латинских букв, цифр и знаков подчеркивания, причем имя
# переменной не может начинаться с цифры. Кроме того, следует избегать указания символа подчеркивания в начале имени,
# поскольку идентификаторам с таким символом определено специальное назначение. Например, имена, начинающиеся с символа
# подчеркивания, не импортируются из модуля с помощью инструкции from module import *, а имена, включающие по два
# символа подчеркивания - в начале и в конце, для интерпретатора имеют особый смысл.
# В качестве имени переменной нельзя использовать ключевые слова. Получить список всех ключевых слов позволяет код,
# приведенный в файле (test_00012.py).
# Помимо ключевых слов, следует избегать совпадений со встроенными идентификаторами. Дело в том, что, в отличие от
# ключевых слов, встроенные идентификаторы можно переопределять, но дальнейший результат может стать для вас
# неожиданным (test_00013.py). В этом примере мы с помощью встроенной функции help о получаем справку по функции abs().
# Далее переменной help присваиваем число 10. После переопределения идентификатора мы больше не можем пользоваться
# функцией help(), т. к. это приведет к выводу сообщения об ошибке. По этой причине лучше избегать имен, совпадающих со
# встроенными идентификаторами. Очень часто подобная ошибка возникает при попытке назвать переменную, в которой
# предполагается хранение строки, именем str. Вроде бы логично, но str является часто используемым встроенным
# идентификатором и после такого переопределения поведение программы становится непредсказуемым. В редакторе IDLE
# встроенные идентификаторы подсвечиваются фиолетовым цветом. Обращайте внимание на цвет переменной - он должен быть
# черным. Если вы заметили, что переменная подсвечена, то название переменной следует обязательно изменить. Получить
# полный список встроенных идентификаторов позволяет код, приведенный в файле (test_00014.py).
# Правильные имена переменных:
# х, yl, strName, str name.
# Неправильные имена переменных:
# 1у, имяПеременной.
# Последнее имя неправильное, т. к. в нем используются русские буквы. Хотя на самом деле такой вариант также будет
# работать, но лучше русские буквы все же не применять:
# ИмяПеременной = 10  # Лучше так не делать!!!
# print(ИмяПеременной)
# При указании имени переменной важно учитывать регистр букв: X и х - разные переменные:
x = 10
X = 20
print(x, X)


# 2.2 Типы данных
print('Типы данных:')
# В Python 3 объекты могут иметь следующие типы данных:
# bool - логический тип данных. Может содержать значение True и False, которые ведут себя как числа 1 и 0:
print(type(True), type(False))
print(int(True), int(False))
# NoneType - объект со значением None(обозначает отсутствие значения):
print(type(None))
# В логическом контексте значение None интерпретируется как False:
print(bool(None))
# int - целые числа. Размер числа ограничен лишь объемом оперативной памяти:
print(type(2147483647))
print(type(99999999999999999999999999999999))
# float - вещественные числа, числа с плавающей точкой:
print(type(5.1))
print(type(8.5e-3))
# complex - комплексные числа:
print(type(2 + 2j))
# str - Unicode-строки:
print(type('Строка'))
# bytes - неизменяемая последовательность байтов:
print(type(bytes('Строка', 'utf-8')))
# bytearray - изменяемая последовательность байтов:
print(type(bytearray('Строка', 'utf-8')))
# list - списки. Тип данных list аналогичен массивам в других языках программирования:
print(type([1, 2, 3]))
# tuple - кортежи:
print(type((1, 2, 3)))
# range - диапазоны:
print(type(range(1, 10)))
# dict - словари. Тип данных dict аналогичен ассоциативным массивам в других языках программирования:
print(type({'x': 5, 'y': 20}))
# set - множества (коллекции уникальных объектов):
print(type({'a', 'b', 'c'}))
# frozenset - неизменяемые множества:
print(type(frozenset(['a', 'b', 'c'])))
# ellipsis - обозначается в виде трех точек или слова Ellipsis. Тип ellipsis используется в расширенном синтаксисе
# получения среза:
print(type(...))
print(...)
print(... is Ellipsis)


class C:
    def __getitem__(self, obj): return obj


c = C()
print(c[..., 1:5, 0:9:1, 0])


# function - функции:
def func():
    pass


print(type(func))
# module - модули:
print(type(sys))


# type - классы и типы данных. Все данные в языке Python являются объектами, даже сами типы данных!
class C:
    pass


print(type(C))
print(type(type('')))
# Основные типы данных делятся на изменяемые и неизменяемые. К изменяемым относятся списки, словари и тип bytearray.
# Пример изменения элемента списка:
arr = [1, 2, 3]
print(arr)
arr[0] = 0  # Изменение первого элемента списка
print(arr)
# К неизменяемым типам относятся числа, строки, кортежи, диапазоны и тип bytes. Например, чтобы получить строку из двух
# других строк, необходимо использовать операцию конкатенации, а ссылку на новый объект присвоить переменной:
str1 = 'авто'
print(str1)
str2 = 'транспорт'
print(str2)
str3 = str1 + str2  # Конкатенация
print(str3)
# Кроме того, типы данных делятся на последовательности и отображения. К последовательностям относятся строки, списки,
# кортежи, диапазоны, типы bytes и bytearray, а к отображениям — словари.
# Последовательности и отображения поддерживают механизм итераторов, позволяющий произвести обход всех элементов с
# помощью метода __next__() или функции next().
# Вывод элементов списка:
arr = [1, 2, 3, 4]
i = iter(arr)
print(i.__next__())  # Метод __next__()
print(i.__next__())
print(next(i))       # Функция next()
print(next(i))
# Если используется словарь, то на каждой итерации возвращается ключ:
d = {'x': 1, 'y': 2, 'z': 3}
i = iter(d)
print(i.__next__())      # Возвращается ключ
print(d[i.__next__()])   # Получаем значение по ключу
# На практике подобным способом не пользуются. Вместо него применяется цикл for, который использует механизм итераторов
# незаметно для нас.
# Вывод элементов списка:
for i in [1, 2, 3, 4, 5]:
    print(i)
# Перебор слова по буквам:
for i in 'Строка':
    print(i + ' -', end=' ')
print()
# Пример перебора словаря:
d = {'x': 1, 'y': 2, 'z': 3}
for key in d:
    print(d[key])
# Последовательности поддерживают также обращение к элементу по индексу, получение среза, конкатенацию (оператор +),
# повторение (оператор *) и проверку на вхождение (оператор in).


# 2.3 Присваивание значения переменным
print('Присваивание значения переменным:')
# В языке Python используется динамическая типизация. Это означает, что при присваивании переменной значения
# интерпретатор автоматически относит переменную к одному из типов данных. Значение переменной присваивается с помощью
# оператора = таким образом:
x = 7              # Тип int
print(x)
y = 7.8            # Тип float
print(y)
s1 = "Строка"      # Переменной s1 присвоено значение Строка
print(s1)
s2 = 'Строка'      # Переменной s2 также присвоено значение Строка
print(s2)
b = True           # Переменной b присвоено логическое значение True
print(b)
# В одной строке можно присваивать значение сразу нескольким переменным:
x = y = 10         # Переменной x как и переменной y присвоено значение 10
print(x, y)
# После присваивания значения в переменной сохраняется ссылка на объект, а не сам объект. Это следует учитывать при
# групповом присваивании. Групповое присваивание можно использовать для чисел, строк и кортежей, но для изменяемых
# объектов этого делать нельзя.
x = y = [1, 2]  # Якобы создано два объекта
print(x, y)
y[1] = 100  # Изменяем второй элемент
print(x, y)
# Изменение значения в переменной 'у' привело также к изменению значения в переменной 'х'. Таким образом, обе переменные
# ссылаются на один и тот же объект, а не на два разных объекта. Чтобы получить два объекта, необходимо производить
# раздельное присваивание:
x = [1, 2]
y = [1, 2]
y[1] = 100  # Изменяем второй элемент
print(x, y)
# Проверить ссылаются ли две переменные на один и тот же объект, позволяет оператор is. Если переменные ссылаются на
# один и тот же объект, то оператор is возвращает значение True:
x = y = [1, 2]  # Один объект
print(x is y)   # True
x = [1, 2]      # Разные объекты
y = [1, 2]      # Разные объекты
print(x is y)   # False
# В целях повышения эффективности кода интерпретатор производит кэширование малых целых чисел и небольших строк. Это
# означает, что если ста переменным присвоено число 2, то в этих переменных будет сохранена ссылка на один и тот же
# объект.
x = 2
y = 2
z = 2
print(x is y, y is z)
# Посмотреть количество ссылок на объект позволяет метод getrefcount() из модуля sys.
# Импорт модуля sys
# import sys
print(sys.getrefcount(2))
# Когда число ссылок на объект становится равно нулю, объект автоматически удаляется из оперативной памяти. Исключением
# являются объекты, которые подлежат кэшированию.
# Позиционное присваивание. Переменные указываются через запятую слева от оператора =, а значения через запятую справа.
x, y, z = 1, 2, 3
print(x, y, z)
# При помощи позиционного присваивания можно поменять значения переменных местами.
x, y = 1, 2
print(x, y)
x, y = y, x  # Значения поменяны местами
print(x, y)
# По обе стороны оператора = могут быть указаны последовательности. К последовательностям относятся строки, списки,
# кортежи, типы bytes и bytearray. Количество элементов справа и слева должно совпадать:
x, y, z = '123'          # Строка
print(x, y, z)
x, y, z = [1, 2, 3]      # Список
print(x, y, z)
x, y, z = (1, 2, 3)      # Кортеж
print(x, y, z)
[x, y, z] = (1, 2, 3)    # Список слева, кортеж справа
print([x, y, z])
# Для сохранения списка в переменной, состоящего из лишних элементов, при несоответствии количества элементов справа и
# слева от оператора = перед именем переменной указывается звездочка (*). Переменная, перед которой указана звездочка,
# всегда содержит список. Если для этой переменной не хватает значений, тогда ей присваиваться пустой список. Звездочку
# можно указать только перед одной переменной.
x, y, *z = (1, 2, 3, 4)    # (1, 2, [3, 4])
print(x, y, z)
x, *y, z = (1, 2, 3, 4)    # (1, [2, 3], 4)
print(x, y, z)
*x, y, z = (1, 2, 3, 4)    # ([1, 2], 3, 4)
print(x, y, z)
x, y, *z = (1, 2, 3)       # (1, 2, [3])
print(x, y, z)
x, y, *z = (1, 2)          # (1, 2, [])
print(x, y, z)
# Переменная, перед которой указана звездочка, всегда содержит список. Если для этой переменной не хватило значений, то
# ей присваивается пустой список. Следует помнить, что звездочку можно указать только перед одной переменной.
# В противном случае возникнет, неоднозначность и интерпретатор выведет сообщение об ошибке:
# *х, у, *z = (1, 2, 3, 4)


# 2.4 Проверка типа данных
print('Проверка типа данных:')
# Python в любой момент времени изменяет тип переменной в соответствии с данными, хранящимися в ней.
a = 'Строка'    # Тип str
print(type(a))
a = 7           # Теперь переменная имеет тип int
# Определить на какой тип данных ссылается переменная, позволяет функция type(<Имя переменной>):
print(type(a))  # int
# Проверить тип данных, хранящихся в переменной, можно следующими способами:
# Сравнить значение, возвращаемое функцией type(), с названием типа данных:
x = 10
if type(x) == int:
    print('Это тип int')
# Проверить тип с помощью функции isinstance():
s = 'Строка'
if isinstance(s, str):
    print('Это тип str')


# 2.5 Преобразование типов данных
print('Преобразование типов данных:')
# В языке Python используется динамическая типизация. После присваивания значения в переменной сохраняется ссылка на
# объект определенного типа, а не сам объект. Если затем переменной присвоить значение другого типа, то переменная будет
# ссылаться на другой объект, и тип данных соответственно изменится. Таким образом, тип данных в языке Python — это
# характеристика объекта, а не переменной. Переменная всегда содержит только ссылку на объект. После присваивания
# переменной значения над последним можно производить операции, предназначенные лишь для этого типа данных. Например,
# строку нельзя сложить с числом, т. к. это приведет к выводу сообщения об ошибке:
# print(2 + '25')
# Для преобразования типов данных предназначены следующие функции:
# bool([<Объект>]) - преобразует объект в логический тип данных:
print(bool(0), bool(1), bool(''), bool('Строка'))
# int([<Объект>]) - преобразует объект в число. Во втором параметре можно указать систему счисления:
print(int(7.5), int('71'))
print(int('71',  10), int('71', 8), int('0o71', 8), int('A', 16))
# float([<Число или строка>]) - преобразует целое число или строку в вещественное число:
print(float(7), float('7.1'))
print(float('Infinity'), float('-inf'))
print(float('Infinity') + float('-inf'))
# str([<Объект>]) - преобразует объект в строку.
print(str(125), str([1, 2, 3]))
print(str((1, 2, 3)), str({'x': 5, 'y': 10}))
print(str(bytes('Строка', 'utf-8')))
print(str(bytearray('Строка', 'utf-8')))
# str(<Объект>[, <Кодировка>[, <Обработка ошибок>]]) - преобразует объект типа bytes или bytearray в строку. В третьем
# параметре могут быть указаны значения 'strict'(значение по умолчанию, в случае ошибки возникает исключение
# UnicodeDecodeError), 'replace'(неизвестный символ заменяется символом, имеющий код \uFFFD) или 'ignore'(неизвестные
# символы игнорируются).
obj1 = bytes('Строка 1', 'utf-8')
obj2 = bytes('Строка 2', 'utf-8')
print(str(obj1, 'utf-8'), str(obj2, 'utf-8'))
print(str(obj1, 'ascii', 'ignore'))
# bytes(<Строка>, <Кодировка>[, <Обработка ошибок>]) - преобразует строку в объект типа bytes. В третьем параметре могут
# быть указаны значения 'strict'(значение по умолчанию), 'replace' или 'ignore'.
print(bytes('Строка', 'cp1251'))
print(bytes('Строка 123', 'ascii', 'ignore'))
# bytes(<Последовательность>) - преобразует последовательность целых чисел от 0 до 255 в объект типа bytes. Если число
# не попадает в диапазон, то возникает исключение ValueError.
b = bytes([225, 226, 224, 174, 170, 160])
print(b)
print(str(b, 'cp866'))
# bytearray(<Строка>, <Кодировка>[, <Обработка ошибок>]) - преобразует строку в объект типа bytearray. В третьем
# параметре могут быть указаны значения 'strict'(значение по умолчанию), 'replace' или 'ignore'.
print(bytearray('Строка', 'cp1251'))
# bytearray(<Последовательность>) - преобразует последовательность целых чисел от 0 до 255 в объект типа bytearray. Если
# число не попадает в диапазон, то возникает исключение ValueError.
b = bytearray([225, 226, 224, 174, 170, 160])
print(b)
print(str(b, 'cp866'))
# list(<Последовательность>) - преобразует элементы последовательности в список.
print(list('12345'))             # преобразование строки
print(list((1, 2, 3, 4, 5, 6)))  # преобразование кортежа
# tuple(<Последовательность>) - преобразует элементы последовательности в кортеж.
print(tuple('123456'))            # преобразование строки
print(tuple([1, 2, 3, 4, 5, 6]))  # преобразование списка
# В качестве примера рассмотрим возможность сложения двух чисел, введенных пользователем. Как вы уже знаете, вводить
# данные позволяет функция input(). Воспользуемся этой функцией для получения чисел от пользователя (test_00015.py).
# Результатом выполнения этого скрипта будет не число, а строка 512. Таким образом, следует запомнить, что функция
# input() возвращает результат в виде строки. Чтобы просуммировать два числа, необходимо преобразовать строку в число
# (test_00016.py). В этом случае мы получим число 17, как и должно быть. Однако если пользователь вместо числа введет
# строку, то программа завершится с фатальной ошибкой.


# 2.6 Удаление переменной
print('Удаление переменной:')
# Удалить переменную можно с помощью инструкции del:
# del <Переменная 1>[, ..., <Переменная N>]
# Удаление переменной:
x = 10
print(x)
del x
# print(x)
# Пример удаления нескольких переменных:
x, y = 10, 20
print(x, y)
del x, y
# print(x, y)
