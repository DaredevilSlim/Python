#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from copy import deepcopy   # Подключение функции deepcopy() из модуля сору
from random import shuffle  # Подключение функции shuffle() из модуля random
from random import choice   # Подключение функции choice() из модуля random
from random import sample   # Подключение функции sample() из модуля random
import itertools            # Подключение модуля itertools


# Глава 8
# Списки, кортежи, множества и диапазоны
print('Списки, кортежи, множества и диапазоны:')
# Списки, кортежи, множества и диапазоны - это нумерованные наборы объектов. Каждый элемент набора содержит лишь ссылку
# на объект - по этой причине они могут содержать объекты произвольного типа данных и иметь неограниченную степень
# вложенности. Позиция элемента в наборе задается индексом. Обратите внимание на то, что нумерация элементов начинается
# с 0, а не с 1.
# Списки и кортежи являются просто упорядоченными последовательностями элементов. Как и все последовательности, они
# поддерживают обращение к элементу по индексу, получение среза, конкатенацию (оператор +), повторение (оператор *),
# проверку на вхождение (оператор in) и не вхождение (оператор not in).
# Списки относятся к изменяемым типам данных. Это означает, что мы можем не только получить элемент по индексу, но и
# изменить его:
arr = [1, 2, 3]  # Создание списка
print(arr[0])    # Получение элемента по индексу
arr[0] = 50      # Изменение элемента по индексу
print(arr)
# Кортежи относятся к неизменяемым типам данных. Иными словами, можно получить элемент по индексу, но изменить его
# нельзя:
t = (1, 2, 3)  # Создание кортежа
print(t[0])    # Получение элемента по индексу
# t[0] = 50      # Изменение элемента по индексу нельзя!
# Множества могут быть как изменяемыми, так и неизменяемыми. Их основное отличие от только что рассмотренных типов
# данных - хранение лишь уникальных значений (неуникальные значения автоматически отбрасываются).
arr = [0, 1, 1, 2, 3, 3, 4]
print(set(arr))
# Что касается диапазонов, то они представляют собой наборы чисел, сформированные на основе заданных начального,
# конечного значений и величины шага между числами. Их важнейшее преимущество перед всеми остальными наборами объектов
# - небольшой объем занимаемой оперативной памяти.
r = range(0, 101, 10)
for i in r:
    print(i, end=' ')
print()


# 8.1 Создание списка
print('Создание списка:')
# Создать список можно следующими способами:
# С помощью функции list([<Последовательность>]). Функция позволяет преобразовать любую последовательность в список.
# Если параметр не указан, то создается пустой список.
print(list())                 # Создание пустого списка
print(list('String'))         # Преобразование строку в список
print(list((1, 2, 3, 4, 5)))  # Преобразование кортеж в список
# Перечислив все элементы списка внутри квадратных скобок:
arr = [1, 'str', 3, '4']
print(arr)
# Заполнив список поэлементно с помошью метода append():
arr = list()       # Создание пустого списка
arr.append(1)      # Добавление элемента 1 (индекс 0)
arr.append('str')  # Добавление элемента 2 (индекс 1)
print(arr)
# При создании списка в переменной сохраняется ссылка на объект, а не сам объект. Это обязательно следует учитывать при
# групповом присваивании. Групповое присваивание можно использовать для чисел и строк, но для списков этого делать
# нельзя.
x = y = [1, 2]  # Якобы создали два объекта
print(x, y)
# В этом примере мы создали список из двух элементов и присвоили значение переменным х и у. Теперь попробуем изменить
# значение в переменной у:
y[1] = 100   # Изменение второго элемента
print(x, y)  # Изменилось значение сразу в двух переменных
# Как видно из примера, изменение значения в переменной у привело также к изменению значения в переменной х. Таким
# образом, обе переменные ссылаются на один и тот же объект, а не на два разных объекта. Чтобы получить два объекта,
# необходимо производить раздельное присваивание:
x, y = [1, 2], [1, 2]
y[1] = 100   # Изменение второго элемента
print(x, y)
# Точно такая же ситуация возникает при использовании оператора повторения *. Например, в следующей инструкции
# производится попытка создания двух вложенных списков с помощью оператора *:
arr = [[]] * 2    # Якобы были созданы два вложенных списка
print(arr)
arr[0].append(5)  # Добавление элемента
print(arr)        # Изменились оба элемента
# Создавать вложенные списки следует с помощью метода append() внутри цикла:
arr = []
for i in range(2):
    arr.append([])
print(arr)
arr[0].append(5)
print(arr)
# Можно также воспользоваться генераторами списков:
arr = [[] for i in range(2)]
print(arr)
arr[0].append(5)
print(arr)
# Проверить, ссылаются ли две переменные на один и тот же объект, позволяет оператор is. Если переменные ссылаются на
# один и тот же объект, то оператор is возвращает значение True:
x = y = [1, 2]         # Неправильно
print(x is y)          # Переменные содержат ссылку на один и тот же список
x, y = [1, 2], [1, 2]  # Правильно
print(x is y)          # Это разные объекты
# Создать копию списка можно двумя способами. Первый способ заключается в применении операции извлечения среза, второй
# - в использовании функции list(), а третий - в вызове метода сору().
x = [1, 2, 3, 4, 5]  # Создание списка
# Создание копии списка
y = list(x)          # или с помощью среза y = x[:] или вызовом метода copy(): y = x.copy()
print(y)
print(x is y)        # Оператор показывает, что это разные объекты
y[1] = 100           # Изменяем второй элемент
print(x, y)          # Изменяем только список в переменной y
# На первый взгляд может показаться, что мы получили копию - оператор is показывает, что это разные объекты, а изменение
# элемента затронуло лишь значение переменной у. В данном случае вроде все нормально. Но проблема заключается в том,
# что списки в языке Python могут иметь неограниченную степень вложенности.
x = [1, [2, 3, 4, 5]]  # Создание вложенного списка
y = list(x)            # Якобы создание копии списка
print(x is y)          # Разные объекты
y[1][1] = 100          # Изменение элемента
print(x, y)            # Изменение затронуло и переменную x
# То есть функция list() и операция извлечения среза создают лишь поверхностную копию списка.
# Чтобы получить полную копию списка, следует воспользоваться функцией deepcopy() из модуля сору:
x = [1, [2, 3, 4, 5]]  # Создание списка
y = deepcopy(x)        # Создание полной копии списка
y[1][1] = 100          # Изменение второго элемента
print(x, y)
# Функция deepcopy() создает копию каждого объекта, при этом сохраняя внутреннюю структуру списка. Иными словами, если
# в списке существуют два элемента, ссылающиеся на один объект, то будет создана копия объекта, и элементы будут
# ссылаться на этот новый объект, а не на разные объекты.
x = [1, 2]
y = [x, x]       # Два элемента ссылаются на один объект
print(y)
z = deepcopy(y)  # Создание копии списка y
print(z[0] is x, z[1] is x, z[0] is z[1])
z[0][0] = 300    # Изменение одного объекта
print(z)         # Значение изменилось сразу в двух элементах!
print(x)         # Начальный список не изменился


# 8.2 Операции над списками
print('Операции над списками:')
# Обращение к элементам списка осуществляется с помощью квадратных скобок, в которых указывается индекс элемента.
# Нумерация элементов списка начинается с нуля. Выведем все элементы списка:
arr = [1, 'str', 3.2, '4']
print(arr[0], arr[1], arr[2], arr[3])
# С помощью позиционного присваивания можно присвоить значения элементов списка каким-либо переменным. Количество
# элементов справа и слева от оператора = должно совпадать, иначе будет выведено сообщение об ошибке:
x, y, z = [1, 2, 3]  # Позиционное присваивание
print(x, y, z)
# x, y = [1, 2, 3]  # Количество элементов должно совпадать
# В Python 3 при позиционном присваивании перед одной из переменных слева от оператора = можно указать звездочку. В
# этой переменной будет сохраняться список, состоящий из "лишних" элементов. Если таких элементов нет, то список будет
# пустым:
x, y, *z = [1, 2, 3]
print(x, y, z)
x, y, *z = [1, 2, 3, 4, 5]
print(x, y, z)
x, y, *z = [1, 2]
print(x, y, z)
*x, y, z = [1, 2]
print(x, y, z)
x, *y, z = [1, 2, 3, 4, 5]
print(x, y, z)
z = [1, 2, 3, 4, 5]
print(z)
# Так как нумерация элементов списка начинается с 0, индекс последнего элемента будет на единицу меньше количества
# элементов. Получить количество элементов списка позволяет функция len():
arr = [1, 2, 3, 4, 5]
print(arr[4])
# print(arr[5])  # Обращение к несуществующему элементу
# В качестве индекса можно указать отрицательное значение. В этом случае смещение будет отсчитываться от конца списка,
# а точнее - чтобы получить положительный индекс, значение вычитается из общего количества элементов списка:
arr = [1, 2, 3, 4, 5]
print(arr[-1], arr[len(arr) - 1])  # Обращение к последнему элементу
# Так как списки относятся к изменяемым типам данных, то мы можем изменить элемент по индексу:
arr = [1, 2, 3, 4, 5]
arr[0] = 600  # Изменение элемента по индексу
print(arr)
# Кроме того, списки поддерживают операцию извлечения среза, которая возвращает указанный фрагмент списка. Формат
# операции:
# [<Начало>:<Конец>:<Шаг>]
# Все параметры не являются обязательными. Если параметр <Начало> не указан, то используется значение 0. Если параметр
# <Конец> не указан, то возвращается фрагмент до конца списка. Следует также заметить, что элемент с индексом, указанном
# в этом параметре, не входит в возвращаемый фрагмент. Если параметр <Шаг> не указан, то используется значение 1. В
# качестве значения параметров можно указать отрицательные значения.
# Получение поверхностной копии списка:
arr = [1, 2, 3, 4, 5]
m = arr[:]       # Создание поверхностной копии
print(m)         # Вывод значений поверхностной копии
print(m is arr)  # Оператор is показывает, что это разные объекты
# Вывод символов в обратном порядке:
arr = [1, 2, 3, 4, 5]
print(arr[::-1])  # Шаг -1
# Вывод списка без первого и последнего элементов:
print(arr[1:])   # Без первого элемента
print(arr[:-1])  # Без последнего элемента
# Вывод первых двух символов списка:
print(arr[0:2])  # Символ с индексом 2 не входит в диапазон
# Вывод последнего элемента списка:
print(arr[-1:])  # Последний элемент списка
# Вывод фрагмента от второго элемента до четвертого включительно:
print(arr[1:4])  # Возвращаются элементы с индекса.ми 1, 2 и 3
# С помощью среза можно изменить фрагмент списка. Если срезу присвоить пустой список, то элементы, попавшие в срез,
# будут удалены:
arr = [1, 2, 3, 4, 5]
arr[1:3] = [6, 7]  # Изменяем значения элементов с индексами 1 и 2
print(arr)
arr[1:3] = []      # Удаляем элементы с индексами 1 и 2
print(arr)
# Соединить два списка в один список позволяет оператор +. Результатом объединения будет новый список:
arr1 = [1, 2, 3, 4, 5]
arr2 = [6, 7, 8, 9]
arr3 = arr1 + arr2
print(arr3)
# Вместо оператора + можно использовать оператор +=. Следует учитывать, что в этом случае элементы добавляются в текущий
# список:
arr = [1, 2, 3, 4, 5]
arr += [6, 7, 8, 9]
print(arr)
# Кроме рассмотренных операций, списки поддерживают операцию повторения и проверку на вхождение. Повторить список
# указанное количество раз можно с помощью оператора*, а выполнить проверку на вхождение элемента в список позволяет
# оператор in:
print([1, 2, 3] * 3)                               # Операция повторения
print(2 in [1, 2, 3, 4, 5], 6 in [1, 2, 3, 4, 5])  # Проверка на вхождение


# 8.3 Многомерные списки
print('Многомерные списки:')
# Любой элемент списка может содержать объект произвольного типа. Например, элемент списка может быть числом, строкой,
# списком, кортежем, словарем и т.д. Создать вложенный список можно, например, так:
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(arr)
# Как вы уже знаете, выражение внутри скобок может располагаться на нескольких строках.
arr = [
         [1, 2, 3],
         [4, 5, 6],
         [7, 8, 9]
      ]
print(arr)
# Чтобы получить значение элемента во вложенном списке, следует указать два индекса:
print(arr[1][1])
# Элементы вложенного списка также могут иметь элементы произвольного типа. Количество вложений не ограничено. То есть,
# мы можем создать объект любой степени сложности. В этом случае для доступа к элементам указывается несколько индексов
# подряд.
arr = [[1, ['a', 'b'], 3], [4, 5, 6], [7, 8, 9]]
print(arr[0][1][0])
arr = [[1, {'a': 10, 'b': ['s', 5]}]]
print(arr[0][1]['b'][0])


# 8.4 Перебор элементов списка
print('Перебор элементов списка:')
# Перебрать все элементы списка можно с помощью цикла for:
arr = [1, 2, 3, 4, 5]
for i in arr:
    print(i, end=' ')
print()
# Следует заметить, что переменную i внутри цикла можно изменить, но если она ссылается на неизменяемый тип данных
# (например, число или строку), то это не отразится на исходном списке:
arr = [1, 2, 3, 4]      # Элементы имеют неизменяемый тип (число)
for i in arr:
    i += 10
print(arr)              # Список не изменился
arr = [[1, 2], [3, 4]]  # Элементы имеют изменяемый тип (список)
for i in arr:
    i[0] += 10
print(arr)              # Список изменился
# Чтобы получить доступ к каждому элементу, можно, например, для генерации индексов воспользоваться функцией range().
# Функция возвращает объект-диапазон, поддерживающий итерации, а с помощью диапазона внутри цикла for можно получить
# текущий индекс.
# Функция range() имеет следующий формат:
# range([<Начало>, ] <Конец> [, <Шаг>])
# Первый параметр задает начальное значение. Если параметр <Начало> не указан, то по умолчанию используется значение 0.
# Во втором параметре указывается конечное значение. Следует заметить, что это значение не входит в возвращаемый
# диапазон значений. Если параметр <Шаг> не указан, то используется значение 1. Для примера умножим каждый элемент
# списка на 2:
arr = [1, 2, 3, 4]
for i in range(len(arr)):
    arr[i] *= 2
print(arr)  # Результат выполнения: [2, 4, 6, 8]
# Можно также воспользоваться функцией enumerate(<Объект> [, start=O]), которая на каждой итерации цикла for возвращает
# кортеж из индекса и значения текущего элемента списка. Умножим каждый элемент списка на 2:
arr = [1, 2, 3, 4]
for i, elem in enumerate(arr):
    arr[i] *= 2
print(arr)
# Кроме того, перебрать элементы можно с помощью цикла while. Но в этом случае следует помнить, что цикл while работает
# медленнее цикла for. Для примера умножим каждый элемент списка на 2, используя цикл while:
arr = [1, 2, 3, 4]
i, c = 0, len(arr)
while i < c:
    arr[i] *= 2
    i += 1
print(arr)  # Результат выполнения: [2, 4, 6, 8]


# 8.5 Генераторы списков и выражения-генераторы
print('Генераторы списков и выражения-генераторы:')
# В предыдущем разделе мы изменяли элементы списка следующим образом:
arr = [1, 2, 3, 4]
for i in range(len(arr)):
    arr[i] *= 2
print(arr)  # Результат выполнения: [2, 4, 6, 8]
# С помощью генераторов списков тот же самый код можно записать более компактно. Помимо компактного отображения, польза
# здесь также и в том, что генераторы списков работают быстрее цикла for. Однако вместо изменения исходного списка
# возвращается новый список:
arr = [1, 2, 3, 4]
arr = [i * 2 for i in arr]
print(arr)  # Результат выполнения: [2, 4, 6, 8]
# Как видно из примера, мы поместили цикл for внутри квадратных скобок, а также изменили порядок следования параметров,
# - инструкция, выполняемая внутри цикла, находится перед циклом. Обратите внимание и на то, что выражение внутри цикла
# не содержит оператора присваивания, - на каждой итерации цикла будет генерироваться новый элемент, которому неявным
# образом присваивается результат выполнения выражения внутри цикла. В итоге будет создан новый список, содержащий
# измененные значения элементов исходного списка.
# Генераторы списков могут иметь сложную структуру. Например, состоять из нескольких вложенных циклов for и (или)
# содержать оператор ветвления if после цикла. Для примера получим четные элементы списка и умножим их на 10:
arr = [1, 2, 3, 4]
arr = [i * 10 for i in arr if i % 2 == 0]
print(arr)  # Результат выполнения: [20, 40]
# Последовательность выполнения этого кода эквивалентна последовательности выполнения следующего кода:
arr = []
for i in [1, 2, 3, 4]:
    if i % 2 == 0:          # Если число четное
        arr.append(i * 10)  # Добавляем элемент
print(arr)                  # Результат выполнения: [20, 40]
# Усложним наш пример. Получим четные элементы вложенного списка и умножим их на 10:
arr = [[1, 2], [3, 4], [5, 6]]
arr = [j * 10 for i in arr for j in i if j % 2 == 0]
print(arr)  # Результат выполнения: [20, 40, 60]
# Последовательность выполнения этого кода эквивалентна последовательности выполнения следующего кода:
arr = []
for i in [[1, 2], [3, 4], [5, 6]]:
    for j in i:
        if j % 2 == 0:          # Если число четное
            arr.append(j * 10)  # Добавляем элемент
print(arr)                      # Результат выполнения: [20, 40, 60]
# Если выражение разместить внутри не квадратных, а круглых скобок, то будет возвращаться не список, а итератор. Такие
# конструкции называются выражениями-генераторами. В качестве примера просуммируем четные числа в списке:
arr = [1, 4, 12, 45, 10]
print(sum((i for i in arr if i % 2 == 0)))


# 8.6 Функции map(), zip(), filter() и reduce()
print('Функции map(), zip(), filter() и reduce():')
# Встроенная функция map() позволяет применить функцию к каждому элементу последовательности. Функция имеет следующий
# формат:
# map(<Функция>, <Последовательность1>[, ... , <ПоследовательностьN>))
# Функция map() возвращает объект, поддерживающий итерации (а не список, как это было ранее в Python 2). Чтобы получить
# список в версии Python 3, необходимо результат передать в функцию list(). В качестве параметра <Функция> указывается
# ссылка на функцию (название функции без круглых скобок), которой будет передаваться текущий элемент
# последовательности. Внутри функции обратного вызова необходимо вернуть новое значение. Для примера прибавим к каждому
# элементу списка число 10 (test_00040.py).
# Функции map() можно передать несколько последовательностей. В этом случае в функцию обратного вызова будут
# передаваться сразу несколько элементов, расположенных в последовательностях на одинаковом смещении. Просуммируем
# элементы трех списков (test_00041.py).
# Если количество элементов в последовательностях будет разным, то в качестве ограничения выбирается последовательность
# с минимальным количеством элементов:
# Встроенная функция zip() на каждой итерации возвращает кортеж, содержащий элементы последовательностей, которые
# расположены на одинаковом смещении. Функция возвращает объект, поддерживающий итерации (а не список, как это было
# ранее в Python 2). Чтобы получить список в версии Python 3, необходимо результат передать в функцию list().
# Формат функции:
# ziр(<Последовательность1>[, ... , <ПоследовательностьN>])
print(zip([1, 2, 3], [4, 5, 6], [7, 8, 9]))
print(list(zip([1, 2, 3], [4, 5, 6], [7, 8, 9])))
# Если количество элементов в последовательностях будет разным, то в результат попадут только элементы, которые
# существуют во всех последовательностях на одинаковом смещении:
print(list(zip([1, 2, 3], [4, 5], [7, 8, 9, 10])))
# В качестве еше одного примера переделаем нашу программу (см. test_00041.py) суммирования элементов трех списков и
# используем функцию zip() вместо функции map() (test_00043.py).
# Функция filter() позволяет выполнить проверку элементов последовательности. Формат функции:
# filter(<Функция>, <Последовательность>)
# Если в первом параметре вместо названия функции указать значение None, то каждый элемент последовательности будет
# проверен на соответствие значению True. Если элемент в логическом контексте возвращает значение False, то он не будет
# добавлен в возвращаемый результат. Функция возвращает объект, поддерживающий итерации (а не список или кортеж, как
# это было ранее в Python 2). Чтобы получить список в версии Python 3, необходимо результат передать в функцию list().
print(filter(None, [1, 0, None, [], 2]))
print(list(filter(None, [1, 0, None, [], 2])))
# Аналогичная операция с использованием генераторов списков выглядит так:
print([i for i in [1, 0, None, [], 2] if i])
# В первом параметре можно указать ссылку на функцию. В эту функцию в качестве параметра будет передаваться текущий
# элемент последовательности. Если элемент нужно добавить в возвращаемое функцией filter() значение, то внутри функции
# обратного вызова следует вернуть значение True, в противном случае - значение False. Удалим все отрицательные
# значения из списка (test_00044.py).
# Функция reduce() из модуля functools применяет указанную функцию к парам элементов и накапливает результат. Функция
# имеет следующий формат:
# reduce(<Функция>, <Последовательность>[, <Начальное значение>])
# В параметр <Функция> в качестве параметров передаются два элемента: первый элемент будет содержать результат
# предыдущих вычислений, а второй - значение текущего элемента. Получим сумму всех элементов списка (test_00045.py).


# 8.7 Добавление и удаление элементов списка
print('Добавление и удаление элементов списка:')
# Для добавления и удаления элементов списка используются следующие методы:
# append(<Объект>) - добавляет один объект в конец списка. Метод изменяет текущий список и ничего не возвращает.
arr = [1, 2, 3]
arr.append(4)        # Добавляем число
print(arr)
arr.append([5, 6])   # Добавляем список
print(arr)
arr.append((7, 8))   # Добавляем кортеж
print(arr)
# extend(<Последовательность>) - добавляет элементы последовательности в конецец списка. Метод изменяет текущий список
# и ничего не возвращает.
arr = [1, 2, 3]
arr.extend((4, 5, 6))  # Добавляем список
arr.extend((7, 8, 9))  # Добавляем кортеж
arr.extend('abc')      # Добавляем буквы из строки
print(arr)
# Добавить несколько элементов можно с помощью операции конкатенации или оператора +=:
arr = [1, 2, 3]
print(arr + [4, 5, 6])  # Возвращает новый список
arr += [4, 5, 6]        # Возвращает новый список
print(arr)
# Кроме того, можно воспользоваться операцией присваивания значения срезу:
arr = [1, 2, 3]
arr[len(arr):] = [4, 5, 6]  # Изменяет текущий список
print(arr)
# insert(<Индекс>, <Объект>) - добавляет один объект в указанную позицию. остальные элементы смещаются. Метод изменяет
# текущий список и ничего не возвращает.
arr = [1, 2, 3]
arr.insert(0, 0)        # Добавление 0 в начало списка
print(arr)
arr.insert(-1, 20)      # Можно указывать отрицательные числа
print(arr)
arr.insert(2, 100)      # Добавление 100 в позицию 2
print(arr)
arr.insert(10, [4, 5])  # Добавление списка
print(arr)
# Метод insert() позволяет добавить только один объект. Чтобы добавить несколько объектов, можно воспользоваться
# операцией присваивания значения срезу. Добавим несколько элементов в начало списка:
arr = [1, 2, 3]
arr[:0] = [-2, -1, 0]
print(arr)
# рор([<Индекс>]) - удаляет элемент, расположенный по указанному индексу, и возвращает его. Если индекс не указан, то
# удаляет и возвращает последний элемент списка. Если элемента с указанным индексом нет, или список пустой,
# возбуждается исключение IndexError.
arr = [1, 2, 3, 4, 5]
arr.pop()   # Удаляем последний элемент списка
print(arr)  # Список изменился
arr.pop(0)  # Удаляем первый элемент списка
print(arr)  # Список изменился
# Удалить элемент списка позволяет также оператор del:
arr = [1, 2, 3, 4, 5]
del arr[4]   # Удаляем последний элемент списка
print(arr)
del arr[:2]  # Удаляем первый и второй элементы
print(arr)
# remove(<Значение>) - удаляет первый элемент, содержащий указанное значение. Если элемент не найден, возбуждается
# исключение ValueError. Метод изменяет текущий список и ничего не возвращает.
arr = [1, 2, 3, 1, 1]
arr.remove(1)  # Удаляет только первый элемент
print(arr)
# arr.remove(5)  # Такого элемента нет
# clear() - удаляет все элементы списка, очищая его. Никакого результата при этом не возвращается. Поддержка этого
# метода появилась в Python 3.3.
arr = [1, 2, 3, 1, 1]
arr.clear()
print(arr)
# Если необходимо удалить все повторяющиеся элементы списка, то можно преобразовать список во множество, а затем
# множество обратно преобразовать в список. Обратите внимание на то, что список должен содержать только неизменяемые
# объекты (например, числа, строки или кортежи). В противном случае возбуждается исключение TypeError.
arr = [1, 2, 3, 1, 1, 2, 2, 3, 3]
s = set(arr)   # Преобразуем список во множество
print(s)
arr = list(s)  # Преобразуем множество в список
print(arr)     # Все повторы были удалены


# 8.8. Поиск элемента в списке и получение сведений о значениях, входящих в список
print('Поиск элемента в списке и получение сведений о значениях, входящих в список:')
# Как вы уже знаете, выполнить проверку на вхождение элемента в список позволяет оператор in: если элемент входит в
# список, то возвращается значение True, в противном случае - False. Аналогичный оператор not in выполняет проверку на
# не вхождение элемента в список: если элемент отсутствует в списке, возвращается True, в противном случае - False.
print(2 in [1, 2, 3, 4, 5], 6 in [1, 2, 3, 4, 5])          # Проверка на вхождение
print(2 not in [1, 2, 3, 4, 5], 6 not in [1, 2, 3, 4, 5])  # Проверка на не вхождение
# Тем не менее, оба этих оператора не дают никакой информации о местонахождении элемента внутри списка. Чтобы узнать
# индекс элемента внутри списка, следует воспользоваться методом index(). Формат метода:
# index(<Значение>[, <Начало>[, <Конец>]])
# Метод index() возвращает индекс элемента, имеющего указанное значение. Если значение не входит в список, то
# возбуждается исключение ValueError. Если второй и третий параметры не указаны, то поиск будет производиться с начала
# и до конца списка.
arr = [1, 2, 1, 2, 1]
print(arr.index(1), arr.index(2))
print(arr.index(1, 1), arr.index(1, 3, 5))
# print(arr.index(3))
# Узнать количество элементов с указанным значением позволяет метод count(<Значение>). Если элемент не входит в список,
# то возвращается значение 0.
arr = [1, 2, 1, 2, 1]
print(arr.count(1), arr.count(2))
print(arr.count(3))  # Элемент не входит в список
# С помощью функций max() и min() можно узнать максимальное и минимальное значение списка соответственно.
arr = [1, 2, 3, 4, 5]
print(max(arr), min(arr))
# Функция any(<Последовательность>) возвращает значение True, если в последовательности существует хоть один элемент,
# который в логическом контексте возвращает значение True. Если последовательность не содержит элементов, возвращается
# значение False. Пример:
print(any([0, None]), any([0, None, 1]), any([]))
# (-False, True, False)
# Функция all(<Последовательность>) возвращает значение True, если все элементы последовательности в логическом
# контексте возвращают значение True или последовательность не содержит элементов.
print(all([0, None]), all([0, None, 1]), all([]), all(['str', 10]))


# 8.9 Переворачивание и перемешивание списка
print('Переворачивание и перемешивание списка:')
# Метод reverse() изменяет порядок следования элементов списка на противоположный. Метод изменяет текущий список и
# ничего не возвращает.
arr = [1, 2, 3, 4, 5]
arr.reverse()  # Изменяется текущий список
print(arr)
# Если необходимо изменить порядок следования и получить новый список, то следует воспользоваться функцией
# reversed(<Последовательность>). Функция возвращает итератор, который можно преобразовать в список с помощью функции
# list() или генератора списков:
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(reversed(arr))
print(list(reversed(arr)))         # Использование функции list()
for i in reversed(arr):
    print(i, end=' ')              # Вывод с помощью цикла
print()
print([i for i in reversed(arr)])  # Использование генератора списков
# Функция shuffle(<Список>[, <Число от О.О до 1.О>]) из модуля random "перемешивает" список случайным образом. Функция
# перемешивает сам список и ничего не возвращает. Если второй параметр не указан, то используется значение,
# возвращаемое функцией random().
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
shuffle(arr)  # Перемешивает список случайным образом
print(arr)


# 8.10 Выбор элементов случайным образом
print('Выбор элементов случайным образом')
# Получить элементы из списка случайным образом позволяют следующие функции из модуля random:
# choice(<Последовательность>) - возвращает случайный: элемент из любой последовательности (строки, списка, кортежа):
print(choice(['s', 't', 'r']))  # Список
# sample (<Последовательность>, <Количество элементов>) - возвращает список из указанного количества элементов. В этот
# список попадут элементы из последовательности, выбранные случайным образом. В качестве последовательности можно
# указать любые объекты, поддерживающие итерации.
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(sample(arr, 2))
print(arr)  # Сам список не изменяется


# 8.11 Сортировка списка
print('Сортировка списка:')
# Отсортировать список позволяет метод sort(). Он имеет следующий формат:
# sort([key=None][, reverse = False))
# Все параметры не являются обязательными. Метод изменяет текущий список и ничего не возвращает. Отсортируем список по
# возрастанию с параметрами по умолчанию:
arr = [2, 7, 10, 4, 6, 8, 9, 3, 1, 5]
print(arr)
arr.sort()  # Изменяет текущий список
print(arr)
# Чтобы отсортировать список по убыванию, следует в параметре reverse указать значение True:
arr = [2, 7, 10, 4, 6, 8, 9, 3, 1, 5]
print(arr)
arr.sort(reverse=True)  # Сортировка по убыванию
print(arr)
# Стандартная сортировка зависит от регистра символов (test_00046.py).
# В параметре key можно указать функцию, выполняющую какое-либо действие над каждым элементом списка. В качестве
# единственного параметра она должна принимать значение очередного элемента списка, а в качестве результата -
# возвращать результат действий над ним. Этот результат будет участвовать в процессе сортировки, но значения самих
# элементов списка не изменятся.
# Выполнив пример из (test_00046.py), мы получили неправильный результат сортировки, ведь Единый и Единица2 больше, чем
# единица 1. Чтобы регистр символов не учитывался, в параметре key мы укажем функцию для изменения регистра символов
# (test_00047.py).
# Метод sort() сортирует сам список и не возвращает никакого значения. В некоторых
# случаях необходимо получить отсортированный список, а текущий список оставить без изменений. Для этого следует
# воспользоваться функцией sorted(). Функция имеет следующий формат:
# sorted(<Последовательность>[, key=None][, reverse=False])
# В первом параметре указывается список, который необходимо отсортировать. Остальные параметры эквивалентны параметрам
# метода sort(). Пример использования функции sorted():
arr = [2, 7, 10, 4, 6, 8, 9, 3, 1, 5]
print(sorted(arr))                  # Возвращает новый список!
print(sorted(arr, reverse = True))  # Возвращает новый список!
arr = ['единица1', 'Единый', 'Единица2']
print(sorted(arr, key=str.lower))


# 8.12 Заполнение списка числами
print('Заполнение списка числами:')
# Создать список, содержащий диапазон чисел, можно с помощью функции range(). Эта функция возвращает диапазон, который
# преобразуется в список вызовом функции list(). Функция range() имеет следующий формат:
# range([<Начало>, ]<Конец>[, <Шаг>])
# Первый параметр задает начальное значение - если он не указан, используется значение 0. Во втором параметре
# указывается конечное значение. Следует заметить, что это значение не входит в возвращаемый диапазон. Если параметр
# <Шаг> не указан, то используется значение 1. Заполнение списка числами от о до 10:
print(list(range(11)))
# Создание списка, состоящего из диапазона чисел от 1 до 15:
print(list(range(1, 16)))
# Изменение порядка следования чисел на противоположный:
print(list(range(15, 0, -1)))
# Если необходимо получить список со случайными числами (или случайными элементами из другого списка), то следует
# воспользоваться функцией sample(<Последовательность>, <Количество элементов>) из модуля random.
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(sample(arr, 3))
print(sample(range(300), 5))


# 8.13 Преобразование списка в строку
print('Преобразование списка в строку:')
# Преобразовать список в строку позволяет метод join(). Элементы добавляются через указанный разделитель. Формат
# метода:
# <Строка> = <Разделитель>.join(<Последовательность>)
arr = ['word1', 'word2', 'word3']
print(' - '.join(arr))
# Элементы списка должны быть строками, иначе возвращается исключение TypeError:
# arr = ['word1', 'word2', 'word3', 2]
# print(' - '.join(arr))
# Избежать этого исключения можно с помощью выражения-генератора, внутри которого текущий элемент списка преобразуется
# в строку с помощью функции str():
arr = ['word1', 'word2', 'word3', 2]
print(' - '.join(str(i) for i in arr))
# Кроме того, с помощью функции str() можно сразу получить строковое представление списка:
arr = ['word1', 'word2', 'word3', 2]
print(str(arr))


# 8.14 Кортежи
print('Кортежи:')
# Кортежи, как и списки, являются упорядоченными последовательностями элементов. Они во многом аналогичны спискам, но
# имеют одно очень важное отличие - изменить кортеж нельзя. Можно сказать, что кортеж - это список, доступный только
# для чтения.
# Создать кортеж можно следующими способами:
# С помощью функции tuple([ <Последовательность>]). Функция позволяет преобразовать любую последовательность в кортеж.
# Если параметр не указан, то создается пустой кортеж.
print(tuple())                 # Создаем пустой кортеж
print(tuple("String"))         # Преобразуем строку в кортеж
print(tuple([1, 2, 3, 4, 5]))  # Преобразуем сm1сок в кортеж
# Указав все элементы через запятую внутри круглых скобок (или без скобок):
t1 = ()                  # Создаем пустой кортеж
t2 = (5, )               # Создаем кортеж из одного элемента
t3 = (1, 'str', (3, 4))  # Кортеж из трех элементов
t4 = 1, "str", (3, 4)    # Кортеж из трех элементов
print(t1, t2, t3, t4)
# Чтобы создать кортеж из одного элемента, необходимо в конце указать запятую. Именно запятые формируют кортеж, а не
# круглые скобки. Если внутри круглых скобок нет запятых, то будет создан объект другого типа.
t = (5)
print(type(t))  # Получили число, а не кортеж!
t = ('str')
print(type(t))  # Получили строку, а не кортеж!
# Четвертая строка в исходном примере также доказывает, что не скобки формируют кортеж, а запятые. Помните, что любое
# выражение в языке Python можно заключить в круглые скобки, а чтобы получить кортеж, необходимо указать запятые.
# Позиция элемента в кортеже задается индексом. Обратите внимание на то, что нумерация элементов кортежа (как и списка)
# начинается с 0, а не с 1. Как и все последовательности, кортежи поддерживают обращение к элементу по индексу,
# получение среза, конкатенацию (оператор +), повторение (оператор *), проверку на вхождение (оператор in) и не
# вхождение (оператор not in).
t = (1, 2, 3, 4, 5, 6, 7, 8, 9)
print(t[0])                   # Получение значения первого элемента кортежа
print(t[::-1])                # Изменение порядка следования элементов
print(t[2:5])                 # Получение среза
print(8 in t, 0 in t)         # Проверка на вхождение
print((1, 2, 3) + (4, 5, 6))  # Конкатенация
# Кортежи, как уже неоднократно отмечалось, относятся к неизменяемым типам данных. Иными словами, можно получить
# элемент по индексу, но изменить ero нельзя:
t = (1, 2, 3)  # Создаем кортеж
print(t[0])    # Получаем элемент по индексу
# print(t[O] = 50)  # Изменить элемент по индексу нельзя!
# Кортежи поддерживают уже знакомые нам по спискам функции len(), min(), max(), методы index() и count().
t = (1, 2, 3)                  # Создаем кортеж
print(len(t))                  # Получаем количество элементов
t = (1, 2, 1, 2, 1)
print(t.index(1), t.index(2))  # Ищем элементы в кортеже


# 8.15 Множества
print('Множества:')
# Множество - это неупорядоченная последовательность уникальных элементов, с которой можно сравнивать другие элементы,
# чтобы определить, принадлежат ли они этому множеству. Объявить множество можно с помощью функции set():
s = set()
print(s)
s = {}
print(s)
# Функция set() позволяет также преобразовать элементы последовательности во множество:
print(set('string'))           # Преобразуем строку
print(set([1, 2, 3, 4, 5]))    # Преобразуем список
print(set((1, 2, 3, 4, 5)))    # Преобразуем кортеж
print({1, 2, 3, 1, 2, 3})  # Остаются только уникальные элементы
# Перебрать элементы множества позволяет цикл for:
for i in {1, 2, 3}:
    print(i)
# Получить количество элементов множества позволяет функция len():
print(len({1, 2, 3}))
# Для работы с множествами предназначены следующие операторы и соответствующие им методы:
# | и union() - объединяет два множества:
s = {1, 2, 3}
print(s.union({4, 5, 6}), s | {4, 5, 6})
# Если элемент уже содержится во множестве, то он повторно добавлен не будет:
print({1, 2, 3} | {1, 2, 3})
# a |= b и a.update(b) - добавляет элементы множества b во множество a:
s = {1, 2, 3}
s.update({4, 5, 6})
s |= {7, 8, 9}
print(s)
# - и difference() - вычисляет разницу множеств:
print({1, 2, 3} - {1, 2, 4})
s = {1, 2, 3}
s = s.difference({1, 2, 4})
print(s)
# а -= b  и а.difference_update(Ь) -удаляют элементы из множества а, которые существуют и во множестве а, и во
# множестве b:
s = {1, 2, 3}
s.difference_update({1, 2, 4})
print(s)
s -= {3, 4, 5}
print(s)
# & и intersection() - пересечение множеств. Позволяет получить элементы, которые существуют в обоих множествах:
print({1, 2, 3} & {1, 2, 4})
s = {1, 2, 3}
s = s.intersection({1, 2, 4})
print(s)
# a &= b и a.intersection_update(b) - во множестве а останутся элементы, которые существуют и во множестве а и во
# множестве b:
s = {1, 2, 3}
s.intersection_update({1, 2, 4})
print(s)
s &= {1, 6, 7}
print(s)
# ^ и symmetric_difference() - возвращают все элементы обоих множеств, исключая элементы, которые присутствуют в обоих
# этих множествах:
s = {1, 2, 3}
print(s ^ {1, 2, 4}, s.symmetric_difference({1, 2, 4}))
print(s ^ {1, 2, 3}, s.symmetric_difference({1, 2, 3}))
print(s ^ {4, 5, 6}, s.symmetric_difference({4, 5, 6}))
# a ^= и symmetric_difference_update(b) - во множестве a будут все элементы обоих множеств, исюпочая те, что
# присутствуют в обоих этих множествах:
s = {1, 2, 3}
s.symmetric_difference_update({1, 2, 4})
print(s)
s ^= {3, 5, 6}
print(s)
# Операторы сравнения множеств:
# in - проверка наличия элемента во множестве:
s = {1, 2, 3, 4, 5}
print(1 in s, 12 in s)
# not in - проверка отсутствия элемента во множестве:
s = {1, 2, 3, 4, 5}
print(1 not in s, 12 not in s)
# == - проверка на равенство:
print({1, 2, 3} == {1, 2, 3})
print({1, 2, 3} == {3, 2, 1})
print({1, 2, 3} == {1, 2, 3, 4})
# а <= b и a.issubset(Ь) - проверяют, входят ли все элементы множества а во множество b:
s = {1, 2, 3}
print(s <= {1, 2}, s <= {1, 2, 3, 4})
print(s.issubset({1, 2}), s.issubset({1, 2, 3, 4}))
# а < b - проверяет, входят ли все элементы множества a во множество b, причем множество а не должно быть равно
# множеству b:
s = {1, 2, 3}
print(s < {1, 2}, s < {1, 2, 3, 4})
# >>> s < set([l, 2, З]), s < set([l, 2, 3, 4))
# (False, True)
# а >= b и а.issuperset(b) - проверяют, входят ли все элементы множества ь во множество a:
s = {1, 2, 3}
print(s >= {1, 2}, s >= {1, 2, 3, 4})
print(s.issuperset({1, 2}), s.issuperset({1, 2, 3, 4}))
# а > b - проверяет, входят ли все элементы множества b во множество a, причем множество а не должно быть равно
# множеству b:
s = {1, 2, 3}
print(s > {1, 2}, s > {1, 2, 3})
# а.isdisjoint (Ь) - проверяет, являются ли множества а и b полностью разными, т. е. не содержащими ни одного
# совпадающего элемента:
s = {1, 2, 3}
print(s.isdisjoint({4, 5, 6}))
print(s.isdisjoint({1, 3, 5}))
# Для работы с множествами предназначены следующие методы:
# сору() - создает копию множества. Обратите внимание на то, что оператор = присваивает лишь ссылку на тот же объект,
# а не копирует его.
s = {1, 2, 3}
c = s          # С помощью = копию создать нельзя!
print(s is c)
c = s.copy()   # Создаем копию объекта
print(s is c)  # Теперь это разные объекты
# add (<Элемент>) - добавляет <Элемент> во множество:
s = {1, 2, 3}
s.add(4)
print(s)
# remove (<Элемент>) - удаляет <Элемент> из множества. Если элемент не найден, то возбуждается исключение KeyError:
s = {1, 2, 3}
s.remove(3)
print(s)  # Элемент существует
# s.remove(5)
# print(s)  # Элемент не существует
# discard (<Элемент>) - удаляет <Элемент> из множества, если он присутствует. Если указанный элемент не существует,
# никакого исключения не возбуждается:
s = {1, 2, 3}
s.discard(3)  # Элемент существует
print(s)
s.discard(5)  # Элемент НЕ существует
print(s)
# рор() - удаляет произвольный элемент из множества и возвращает его. Если элементов нет, то возбуждается исключение
# KeyError:
s = {1, 2}
s.pop()
print(s)
s.pop()
print(s)
# s.pop()  # Если нет элементов, то будет ошибка
# print(s)
# clear() - удаляет все элементы из множества:
s = {1, 2, 3}
s.clear()
print(s)
# Помимо генераторов списков и генераторов словарей, язык Python 3 поддерживает генераторы множеств. Синтаксис
# генераторов множеств похож на синтаксис генераторов списков, но выражение заключается в фигурные скобки, а не в
# квадратные. Так как результатом является множество, все повторяющиеся элементы будут удалены.
s = {x for x in [1, 2, 1, 2, 1, 2, 3]}
print(s)
# Генераторы множеств могут иметь сложную структуру. Например, состоять из нескольких вложенных циклов for и (или)
# содержать оператор ветвления if после цикла. Создание из элементов исходного списка множество, содержащее только
# уникальные элементы с четными значениями:
s = {x for x in [1, 2, 1, 2, 1, 2, 3] if x % 2 == 0}
print(s)
# Язык Python поддерживает еще один тип множеств - frozenset. В отличие от типа set, множество типа frozenset нельзя
# изменить. Объявить множество можно с помощью функции frozenset():
f = frozenset()
print(f)
# Функция frozenset() позволяет также преобразовать элементы последовательности во множество:
print(frozenset('string'))         # Преобразуем строку
print(frozenset([1, 2, 3, 4, 4]))  # Преобразуем список
print(frozenset((1, 2, 3, 4, 4)))  # Преобразуем кортеж
# Множества frozenset поддерживают операторы, которые не изменяют само множество, а также следующие методы: сору (),
# difference(), intersection(), issubset(), issuperset(), symmetric_difference() и union().


# 8.16 Диапазоны
print('Диапазоны:')
# Диапазоны, как следует из самого их названия, - это диапазоны целых чисел с заданными начальным и конечным значением
# и шагом (промежутком между соседними числами). Как и списки, кортежи и множества, диапазоны представляют собой
# последовательности и, подобно кортежам, являются неизменяемыми.
# Важнейшим преимуществом диапазонов перед другими видами последовательностей является их компактность - вне
# зависимости от количества входящих в него элементов-чисел, диапазон всегда отнимает один и тот же объем оперативной
# памяти. Однако в диапазон могут входить лишь последовательно стоящие друг за другом числа - сформировать диапазон на
# основе произвольного набора чисел или данных другого типа, даже чисел с плавающей точкой, невозможно.
# Диапазоны чаще всего используются для проверки вхождения значения в какой-либо интервал и для организации циклов.
# Для создания диапазона применяется функция range():
# range([<Начало>, ]<Конец>[, <Шаг>])
# Первый параметр задает начальное значение - если он не указан, используется значение 0. Во втором параметре
# указывается конечное значение. Следует заметить, что это значение не входит в возвращаемый диапазон. Если параметр
# <Шаг> не указан, то используется значение 1.
r = range(1, 10)
print(*(i for i in r), end='')
print()
r = range(10, 110, 10)
print(*(i for i in r), end='')
print()
r = range(10, 1, -1)
print(*(i for i in r), end='')
print()
# Преобразовать диапазон в список, кортеж, обычное или неизменяемое множество можно с помощью функций list(), tuple(),
# set() или frozenset() соответственно:
print(list(range(1, 10)))   # Преобразуем в список
print(tuple(range(1, 10)))  # Преобразуем в кортеж
print(set(range(1, 10)))    # Преобразуем в множество
# Множества поддерживают доступ к элементу по индексу, получение среза (в результате возвращается также диапазон),
# проверку на вхождение и не вхождение, функции len(), min(), max(), методы index() и count().
r = range(1, 10)
print(r[2], r[-1])
print(r[2:4])
print(2 in r, 12 in r)
print(2 not in r, 12 not in r)
print(len(r), min(r), max(r))
print(r.index(4), r.count(4))
# В Python 3.3 появилась поддержка операторов, позволяющих сравнить два диапазона:
# == - возвращает True, если диапазоны равны, и False в противном случае. Диапазоны считаются равными, еcли они
# содержат одинаковые последовательности чисел.
print(range(1, 10) == range(1, 10, 1))
print(range(1, 10, 2) == range(1, 11, 2))
print(range(1, 10, 2) == range(1, 12, 2))
# ! = - возвращает True, если диапазоны не равны, и False в противном случае:
print(range(1, 10, 2) != range(1, 12, 2))
print(range(1, 10) != range(1, 10, 1))
# А в Python 3.4 диапазоны стали поддерживать свойства start, stop и step, возвращающие, соответственно, начальную,
# конечную границы диапазона и его шаг:
r = range(1, 10)
print(r.start, r.stop, r.step)


# 8.17 Модуль itertools
print('Модуль itertools:')
# Модуль itertools содержит функции, позволяющие генерировать различные последовательности на основе других
# последовательностей, производить фильтрацию элементов и др. Все функции возвращают объекты, поддерживающие итерации.
# Прежде чем использовать функции, необходимо ПОДКЛЮЧИТЬ модуль с ПОМОЩЬЮ инструкции:


# 8.17.1 Генерация неопределенного количества значений
print('Генерация неопределенного количества значений:')
# Для генерации неопределенного количества значений предназначены следующие функции:
# count([start=0][, step=1]) - создает бесконечно нарастающую последовательность значений. Начальное значение задается
# параметром start, а шаг - параметром step.
for i in itertools.count():
    if i > 10:
        break
    print(i, end=' ')
print()
print(list(zip(itertools.count(), 'абвгд')))
print(list(zip(itertools.count(start=2, step=2), 'абвгд')))
# cycle(<Последовательность>) - на каждой итерации возвращается очередной элемент последовательности. Когда будет
# достигнут конец последовательности, перебор начнется сначала, и так бесконечно.
n = 1
for i in itertools.cycle('абв'):
    if n > 10:
        break
    print(i, end=' ')
    n += 1
print()
# repeat(<Объект>[, <Количество повторов>]) - возвращает объект указанное количество раз. Если количество повторов не
# указано, то объект возвращается бесконечно.
print(list(itertools.repeat(1, 10)))
print(list(zip(itertools.repeat(5), 'абвгд')))


# 8.17.2 Генерация комбинаций значений
print('Генерация комбинаций значений:')
# Получить различные комбинации значений позволяют следующие функции:
# combinations() - на каждой итерации возвращает кортеж, содержащий комбинацию из указанного количества элементов. При
# этом элементы в кортеже гарантированно будут разными. Формат функции:
# combinations(<Последовательность>, <Количество элементов>)
print(list(itertools.combinations('абвгд', 2)))
print([''.join(i) for i in itertools.combinations('абвгд', 2)])
print(list(itertools.combinations('вгаб', 2)))
print(list(itertools.combinations('абвг', 3)))
# combinations_with_replacement () - на каждой итерации возвращает кортеж, содержащий комбинацию из указанного
# количества элементов. При этом кортеж может содержать одинаковые элементы. Формат функции:
# combinations_with_replacement(<Последовательность>, <Количество элементов>)
print(list(itertools.combinations_with_replacement('абвг', 2)))
print(list(itertools.combinations_with_replacement('вгаб', 2)))
# permutations() - на каждой итерации возвращает кортеж, содержащий комбинацию из указанного количества элементов.
# Если количество элементов не указано, то используется длина последовательности. Формат функции:
# permutations(<Последовательность>[, <Количество элементов>])
print(list(itertools.permutations('абвг', 2)))
print([''.join(i) for i in itertools.permutations('абвг')])
# product() - на каждой итерации возвращает кортеж, содержащий комбинацюо из элементов одной или нескольких
# последовательностей. Формат функции:
# product(<Последовательность1>[, ... , <ПоследовательностьN>] [, repeat=1])
print(list(itertools.product('абвг', repeat=2)))
print([''.join(i) for i in itertools.product('аб', 'вг', repeat=1)])
print([''.join(i) for i in itertools.product('аб', 'вг', repeat=2)])


# 8.17.3 Фильтрация элементов последовательности
print('Фильтрация элементов последовательности:')
# Для фильтрации элементов последовательности предназначены следующие функции:
# filterfalse(<Функция>, <Последовательность>) - возвращает элементы последовательности (по одному на каждой итерации),
# для которых функция, указанная в первом параметре, вернет значение False.
def func(x):
    return x > 3


print(list(itertools.filterfalse(func, [4, 5, 6, 0, 7, 2, 3])))
print(list(filter(func, [4, 5, 6, 0, 7, 2, 3])))
# Если в первом параметре вместо названия функции указать значение None, то каждый элемент последовательности будет
# проверен на соответствие значению False. Если элемент в логическом контексте возвращает значение True, то он не
# войдет в возвращаемый результат.
print(list(itertools.filterfalse(None, [0, 5, 6, 0, 7, 0, 3])))
print(list(filter(None, [0, 5, 6, 0, 7, 0, 3])))
# dropwhile(<Функция>, <Последовательность>) - возвращает элементы последовательности (по одному на каждой итерации),
# начиная с элемента, для которого функция, указанная в первом параметре, вернет значение False.
print(list(itertools.dropwhile(func, [4, 5, 6, 0, 7, 2, 3])))
print(list(itertools.dropwhile(func, [4, 5, 6, 7, 8])))
print(list(itertools.dropwhile(func, [1, 2, 4, 5, 6, 7, 8])))
# takewhile(<Функция>, <Последовательность>) - возвращает элементы последовательности (по одному на каждой итерации),
# пока не встретится элемент, для которого функция, указанная в первом параметре, вернет значение False.
print(list(itertools.takewhile(func, [4, 5, 6, 0, 7, 2, 3])))
print(list(itertools.takewhile(func, [4, 5, 6, 7, 8])))
print(list(itertools.takewhile(func, [1, 2, 4, 5, 6, 7, 8])))
# compress() - производит фильтрацию последовательности, указанной в первом параметре. Элемент возвращается, только
# если соответствующий элемент (с таким же индексом) из второй последовательности трактуется как истина. Сравнение
# заканчивается, когда достигнут конец одной из последовательностей. Формат функции:
# compress(<Фильтруемая последовательность>, <Последовательность логических значений>)
print(list(itertools.compress('абвгде', [1, 0, 0, 0, 1, 1])))
print(list(itertools.compress('абвгде', [True, False, True])))


# 8.17.4 Прочие функции
print('Прочие функции:')
# Помимо функций, которые мы рассмотрели в предыдущих подразделах, модуль itertools содержит несколько дополнительных
# функций:
# islice() - на каждой итерации возвращает очередной элемент последовательности. Поддерживаются форматы:
# isliсе(<Последовательность>, <Конечная граница>)
# isliсе(<Последовательность>, <Начальная граница>, <Конечная граница>[, <Шаг>])
# Если <Шаг> не указан, будет использовано значение 1.
print(list(itertools.islice('абвгдезж', 3)))
print(list(itertools.islice('абвгдезж', 3, 6)))
print(list(itertools.islice('абвгдезж', 3, 6, 2)))
# starmap (<Функция>, <Последовательность>) - формирует последовательность на основании значений, возвращенных
# указанной функцией. Исходная последовательность должна содержать в качестве элементов кортежи - именно над элементами
# этих кортежей функция и станет вычислять значения, которые войдут в генерируемую последовательность.
# Примеры суммирования значений:


def func1(x, y):
    return x + y


def func2(x, y, z):
    return x + y + z


print(list(itertools.starmap(func1, [(1, 2), (4, 5), (6, 7)])))
print(list(itertools.starmap(func2, [(1, 2, 3), (4, 5, 6)])))
# zip_longest() - на каждой итерации возвращает кортеж, содержащий элементы последовательностей, которые расположены
# на одинаковом смещении. Если последовательности имеют разное количество элементов, то вместо отсутствующего элемента
# вставляется объект, указанный в параметре fill value. Формат функции:
# zip_longest(<Последовательность1>[, ... , <ПоследовательностьN>][, fillvalue = None])
print(list(itertools.zip_longest([1, 2, 3], [4, 5, 6])))
print(list(itertools.zip_longest([1, 2, 3], [4])))
print(list(itertools.zip_longest([1, 2, 3], [4], fillvalue=0)))
print(list(zip([1, 2, 3], [4])))
# accumulate(<Последовательность>[, <функция:>)) - на каждой итерации возвращает результат, полученный выполнением
# определенного действия над текущим элементом и результатом, полученным на предыдущей итерации. Выполняемая операция
# задается параметром <Функция>, а если он не указан, выполняется операция сложения. Функция, выполняющая операцию,
# должна принимать два параметра и возвращать результат. На первой итерации всегда возвращается первый элемент
# переданной последовательности.
# Сложение:
print(list(itertools.accumulate([1, 2, 3, 4, 5, 6])))


# Умножение:
def func3(x, y):
    return x * y


print(list(itertools.accumulate([1, 2, 3, 4, 5, 6], func3)))
# chain() - на каждой итерации возвращает элементы сначала из первой последовательности, затем из второй и т.д. Формат
# функции:
# сhаin(<Последовательность1>[, ... , <ПоследовательностьN>])
arr1, arr2, arr3 = [1, 2, 3], [4, 5], [6, 7, 8, 9]
print(list(itertools.chain(arr1, arr2, arr3)))
print(list(itertools.chain('abc', 'defg', 'hij')))
print(list(itertools.chain('abc', ['defg', 'hij'])))
# chain.from_iterable(<Последовательность>) - аналогична функции chain(), но принимает одну последовательность, каждый
# элемент которой считается отдельной последовательностью.
print(list(itertools.chain.from_iterable(['abc', 'defg', 'hij'])))
# tee(<Последовательность>[, <Количество>]) - возвращает кортеж, содержащий несколько одинаковых итераторов для
# последовательности. Если второй параметр не указан, то возвращается кортеж из двух итераторов.
arr = [1, 2, 3]
print(itertools.tee(arr))
print(itertools.tee(arr, 3))
print(list(itertools.tee(arr)[0]))
print(list(itertools.tee(arr)[1]))
