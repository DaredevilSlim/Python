#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Глава 9
# Словари
print('Словари:')
# Словари - это наборы объектов, доступ к которым осуществляется не по индексу, а по ключу. В качестве ключа можно
# указать неизменяемый объект, например: число, строку или кортеж. Элементы словаря могут содержать объекты
# произвольного типа данных и иметь неограниченную степень вложенности. Следует также заметить, что элементы в словарях
# располагаются в произвольном порядке. Чтобы получить элемент, необходимо указать ключ, который использовался при
# сохранении значения.
# Словари относятся к отображениям, а не к последовательностям. По этой причине функции, предназначенные для работы с
# последовательностями, а также операции извлечения среза, конкатенации, повторения и др., к словарям не применимы.
# Равно как и списки, словари относятся к изменяемым типам данных. Иными словами, мы можем не только получить значение
# по ключу, но и изменить его.

# 9.1 Создание словаря
print('Создание словаря:')
# Создать словарь можно следующими способами:
# с помощью функции dict(). Форматы функции:
# dict(<Ключ1>=<Значение1>[, ... , <КлючN>=<ЗначениеN>])
# dict(<Словарь>)
# dict(<Список кортежей с двумя элементами (Ключ, Значение)>)
# dict(<Список списков с двумя элементами [Ключ, Значение]>)
# Если параметры не указаны, то создается пустой словарь.
d = dict()                      # Создаем пустой словарь
print(d)
d = dict(a=1, b=2)
print(d)
d = dict({'a': 1, 'b': 2})      # Словарь
print(d)
d = dict([('a', 1), ('b', 2)])  # Список кортежей
print(d)
d = dict([['a', 1], ['b', 2]])  # Список списков
print(d)
# Объединить два списка в список кортежей позволяет функция zip ():
k = ['a', 'b']          # Список с ключами
v = [1, 2]              # Список со значениями
print(list(zip(k, v)))  # Создание списка кортежей
d = dict(zip(k, v))     # Создание словаря
print(d)
# Указав все элементы словаря внутри фигурных скобок. Это наиболее часто используемый способ создания словаря. Между
# ключом и значением указывается двоеточие, а пары «ключ/значение» записываются через запятую.
d = {}  # Создание пустого словаря
print(d)
d = {'a': 1, 'b': 2}
print(d)
# Заполнив словарь поэлементно. В этом случае ключ указывается внутри квадратных скобок:
d = {}      # Создаем пустой словарь
print(d)
d['a'] = 1  # Добавляем элемент! (ключ "а")
d['b'] = 2  # Добавляем элемент2 (ключ "Ь")
print(d)
# С помощью метода dict. fromkeys(<Последовательность> [, <Значение>]) . Метод создает новый словарь, ключами которого
# будут элементы последовательности, переданной первым параметром, а их значениями - величина, переданная вторым
# параметром. Если второй параметр не указан, то значением элементов словаря будет значение None.
d = dict.fromkeys(['a', 'b', 'c'])
print(d)
d = dict.fromkeys(['a', 'b', 'c'], 0)  # Указан список
print(d)
d = dict.fromkeys(('a', 'b', 'c'), 0)  # Указан кортеж
print(d)
# При создании словаря в переменной сохраняется ссылка на объект, а не сам объект. Это обязательно следует учитывать
# при групповом присваивании. Групповое присваивание можно использовать для чисел и строк, но для списков и словарей
# этого делать нельзя.
d1 = d2 = {'a': 1, 'b': 2}  # Якобы создали два объекта
d2['b'] = 10
print(d1, d2)  # Изменилось значение в двух переменных
# Как видно из примера, изменение значения в переменной d2 привело также к изменению значения в переменной d1. То есть,
# обе переменные ссылаются на один и тот же объект, а не на два разных объекта. Чтобы получить два объекта, необходимо
# производить раздельное присваивание:
d1, d2 = {'a': 1, 'b': 2}, {'a': 1, 'b': 2}
d2['b'] = 10
print(d1, d2)
# Создать поверхностную копию словаря позволяет функция dict() (test_00048.py).
# Кроме того, для создания поверхностной копии можно воспользоваться методом сору() (test_00049.py).
# Чтобы создать полную копию словаря, следует воспользоваться функцией deepcopy() из модуля сору (test_00050.py).


# 9.2. Операции над словарями
print('Операции над словарями:')
# Обращение к элементам словаря осуществляется с помощью квадратных скобок, в которых указывается ключ. В качестве
# ключа можно указать неизменяемый объект - например: число, строку или кортеж.
# Выведем все элементы словаря:
d = {1: 'int', 'a': 'str', (1, 2): 'tuple'}
print(d[1], d['a'], d[(1, 2)])
# Если элемент, соответствующий указанному ключу, отсутствует в словаре, то возбуждается исключение KeyError:
d = {'a': 1, 'b': 2}
print(d)
# print(d['c'])  # Обращение к несуществующему элементу
# Проверить, существование ключа можно с помощью оператора in. Если ключ найден, то возвращается значение True, в
# противном случае - False.
d = {'a': 1, 'b': 2}
print('c' not in d)  # Ключ не существует
print('a' not in d)  # Ключ существует
# Метод get(<Ключ>[, <Значение по умолчанию>]) позволяет избежать возбуждения исключения KeyError при отсутствии в
# словаре указанного ключа. Если ключ присутствует в словаре, то метод возвращает значение, соответствующее этому
# ключу. Если ключ отсутствует, то возвращается None или значение, указанное во втором параметре.
d = {'a': 1, 'b': 2}
print(d.get('a'), d.get('c'), d.get('c', 800))
# Кроме того, можно воспользоваться методом setdefault(<Ключ>[, <Значение по умолчанию>]). Если ключ присутствует в
# словаре, то метод возвращает значение, соответствующее этому ключу. Если ключ отсутствует, то в словаре создается
# новый элемент со значением, указанным во втором параметре. Если второй параметр не указан, значением нового элемента
# будет None.
d = {'a': 1, 'b': 2}
print(d.setdefault('a'), d.setdefault('c'), d.setdefault('d', 0))
print(d)
# Так как словари относятся к изменяемым типам данных, мы можем изменить элемент по ключу. Если элемент с указанным
# ключом отсутствует в словаре, то он будет добавлен в словарь:
d = {'a': 1, 'b': 2}
d['a'] = 800       # Изменение элемента по ключу
d['c'] = 'string'  # Добавление нового элемента
print(d)
# Получить количество ключей в словаре позволяет функция len():
d = {'a': 1, 'b': 2}
print(len(d))  # Получение количества ключей в словаре
# Удалить элемент из словаря можно с помощью оператора del:
d = {'a': 1, 'b': 2}
del d['b']  # Удаление элемента с ключом 'b'
print(d)


# 9.3 Перебор элементов словаря
print('Перебор элементов словаря:')
# Перебрать все элементы словаря можно с помощью цикла for, хотя словари и не являются последовательностями. Вывод
# элементов словаря двумя способами. Первый способ использует метод keys(), возвращающий объект с ключами словаря. Во
# втором случае мы просто указываем словарь в качестве параметра. На каждой итерации цикла будет возвращаться ключ, с
# помощью которого внутри цикла можно получить значение, соответствующее этому ключу (test_00051.py).
# Поскольку словари являются неупорядоченными структурами, элементы словаря выводятся в произвольном порядке. Чтобы
# вывести элементы с сортировкой по ключам, следует получить список ключей, а затем воспользоваться методом sort().
d = {'x': 1, 'y': 2, 'z': 3}
k = list(d.keys())  # Получение списка ключей
k.sort()            # Сортировка списка ключей
for key in k:
    print('({0} => {1})'.format(key, d[key]), end=' ')
print()
# Для сортировки ключей вместо метода sort() можно воспользоваться функцией sorted().
d = {'x': 1, 'y': 2, 'z': 3}
for key in sorted(d.keys()):
    print('({0} => {1})'.format(key, d[key]), end=' ')
print()
# Так как на каждой итерации возвращается ключ словаря, функции sorted() можно сразу передать объект словаря, а не
# результат выполнения метода keys():
d = {'x': 1, 'y': 2, 'z': 3}
for key in sorted(d):
    print('({0} => {1})'.format(key, d[key]), end=' ')
print()


# 9.4. Методы для работы со словарями
print('Методы для работы со словарями:')
# Для работы со словарями предназначены следующие методы:
# keys() - возвращает объект dict_keys, содержащий все ключи словаря. Этот объект поддерживает итерации, а также
# операции над множествами.
d1, d2 = {'a': 1, 'b': 2}, {'a': 3, 'c': 4, 'd': 5}
print(d1.keys(), d2.keys())              # Получение объекта dict_keys
print(list(d1.keys()), list(d2.keys()))  # Получение списка ключей
for k in d1.keys():
    print(k, end=' ')
print()
print(d1.keys() | d2.keys())  # Объединение
print(d1.keys() - d2.keys())  # Разница
print(d2.keys() - d1.keys())  # Разница
print(d1.keys() & d2.keys())  # Одинаковые ключи
print(d1.keys() ^ d2.keys())  # Уникальные ключи
# values() - возвращает объект dict_values, содержащий все значения словаря. Этот объект поддерживает итерации.
d = {'a': 1, 'b': 2}
print(d.values())        # Получение объекта dict_values
print(list(d.values()))  # Получение списка значений
print([v for v in d.values()])
# items() - возвращает объект dict_items, содержащий все ключи и значения в виде кортежей. Этот объект поддерживает
# итерации.
d = {'a': 1, 'b': 2}
print(d.items())        # Получение объекта dict_items
print(list(d.items()))  # Получение списка кортежей
# <Ключ> in <Словарь> - проверяет существование указанного ключа в словаре. Если ключ найден, то возвращает значение
# True, в противном случае - False.
d = {'a': 1, 'b': 2}
print('a' in d)  # Ключ существует
print('c' in d)  # Ключ не существует
# <Ключ> not in <Словарь> - проверяет отсутствие указанного ключа в словаре. Если такого ключа нет, то возвращает
# значение True, в противном случае - False.
print('c' not in d)  # Ключ не существует
print('a' not in d)  # Ключ существует
# get(<Ключ>[, <Значение по умолчанию>]) - если ключ присутствует в словаре, то метод возвращает значение,
# соответствующее этому ключу. Если ключ отсутствует, то возвращается None или значение, указанное во втором параметре.
d = {'a': 1, 'b': 2}
print(d.get('a'), d.get('c'), d.get('c', 800))
# setdefault(<Ключ>[, <Значение по умолчанию>]) - если ключ присутствует в словаре, то метод возвращает значение,
# соответствующее этому ключу. Если ключ отсутствует, то создает в словаре новый элемент со значением, указанным во
# втором параметре. Если второй параметр не указан, значением нового элемента будет None.
d = {'a': 1, 'b': 2}
print(d.setdefault('a'), d.setdefault('c'), d.setdefault('d', 0))
print(d)
# рор(<Ключ>[, <Значение по умолчанию>]) - удаляет элемент с указанным ключом и возвращает его значение. Если ключ
# отсутствует, то возвращается значение из второго параметра. Если ключ отсутствует, и второй параметр не указан,
# возбуждается исключение KeyError.
d = {'a': 1, 'b': 2, 'c': 3}
print(d.pop('a'), d.pop('n', 0))
# d.pop("n")  # Ключ отсутствует и нет второго параметра
print(d)
# popitem() - удаляет произвольный элемент и возвращает кортеж из ключа и значения. Если словарь пустой, возбуждается
# исключение KeyError.
d = {'a': 1, 'b': 2}
print(d.popitem())  # Удаление произвольного элемента
print(d.popitem())  # Удаление произвольного элемента
# print(d.popitem())  # Словарь пустой. Возбуждается исключение
# clear() - удаляет все элементы словаря. Метод ничего не возвращает в качестве значения.
d = {'a': 1, 'b': 2}
d.clear()  # Удаление всех элементов
print(d)   # Словарь теперь пустой
# update() - добавляет элементы в словарь. Метод изменяет текущий словарь и ничего не возвращает. Форматы метода:
# update(<Ключ1>=<Значение1>[, ... , <КлючN>=<ЗначениеN>])
# update(<Словарь>)
# update(<Список кортежей с двумя элементами>)
# update(<Список списков с двумя элементами>)
# Если элемент с указанным ключом уже присутствует в словаре, то его значение будет перезаписано.
d = {'a': 1, 'b': 2}
d.update(c=3, d=4)
print(d)
d.update({'c': 10, 'd': 20})          # Словарь
print(d)                              # Значения элементов перезаписаны
d.update([('d', 80), ('е', 6)])       # Список кортежей
print(d)
d.update([['a', 'str'], ['i', 't']])  # Список списков
print(d)
# сору() - создает поверхностную копию словаря:
d1 = {'а': 1, 'b': [10, 20]}
d2 = d1.copy()      # Создание поверхностной копии
print(d1 is d2)     # Это разные объекты
d2['a'] = 800       # Изменение значения
print(d1, d2)       # Изменилось значение только в d2
d2['b'][0] = 'new'  # Изменяем значение вложенного списка
print(d1, d2)       # Изменились значения и в d1, и в d2
# Чтобы создать полную копию словаря, следует воспользоваться функцией deepcopy() из модуля сору.


# 9.5 Генераторы словарей
print('Генераторы словарей:')
# Помимо генераторов списков, язык Python 3 поддерживает генераторы словарей. Синтаксис генераторов словарей похож на
# синтаксис генераторов списков, но имеет два отличия:
# - выражение заключается в фигурные скобки, а не в квадратные;
# - внутри выражения перед циклом for указываются два значения через двоеточие, а не одно. Значение, расположенное
# слева от двоеточия, становится ключом, а значение, расположенное справа от двоеточия, - значением элемента.
keys = ['а', 'b']  # Список с ключами
values = [1, 2]    # Список со значениями
print({k: v for (k, v) in zip(keys, values)})
print({k: 0 for k in keys})
# Генераторы словарей могут иметь сложную структуру. Например, состоять из нескольких вложенных циклов for и (или)
# содержать оператор ветвления if после цикла. Создание нового словаря, содержащего только элементы с четными
# значениями, из исходного словаря:
d = {'а': 1, 'b': 2, 'с': 3, 'd': 4}
print({k: v for (k, v) in d.items() if v % 2 == 0})
