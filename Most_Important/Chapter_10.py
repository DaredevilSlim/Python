#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from time import time         # Подключение функции time() из модуля time
from time import gmtime       # Подключение функции gmtime() из модуля time
from time import localtime    # Подключение функции localtime() из модуля time
from time import mktime       # Подключение функции mktime() из модуля time
from time import strftime     # Подключение функции strftime() из модуля time
from time import strptime     # Подключение функции strptime() из модуля time
from time import asctime      # Подключение функции asctime() из модуля time
from time import ctime        # Подключение функции ctime() из модуля time
from time import sleep        # Подключение функции sleep() из модуля time
from locale import setlocale  # Подключение функции setlocale() из модуля locale
from locale import LC_ALL     # Подключение функции LC_ALL() из модуля locale
import datetime               # Подключение модуля datetime


# Глава 10
# Работа с датой и временем
print('Работа с датой и временем:')
# Для работы с датой и временем в языке Python предназначены следующие модули:
# time - позволяет получить текущие дату и время, а также произвести их форматированный вывод;
# datetime - позволяет манипулировать датой и временем. Например, производить арифметические операции, сравнивать даты,
# выводить дату и время в различных форматах и др.;
# calendar - позволяет вывести календарь в виде простого текста или в HTML-формате;
# timeit - позволяет измерить время выполнения небольших фрагментов кода с целью оптимизации программы.

# 10.1 Получение текущих даты и времени
print('Получение текущих даты и времени:')
# time() - возвращает вещественное число, представляющее количество секунд, прошедшее с начала эпохи (обычно с 1 января
# 1970 г.):
print(time())  # Получение количества секунд
# gmtime([<Количество секунд>]) - возвращает объект struct_time, представляющий универсальное время (UTC). Если параметр
# не указан, то возвращается текущее время. Если параметр указан, то время будет не текущим, а соответствующим
# количеству секунд, прошедших с начала эпохи.
print(gmtime(0))             # Начало эпохи
print(gmtime())              # Текущая дата и время
print(gmtime(1551886771.0))  # Дата 06.03.2019
# Получить значение конкретного атрибута можно, указав его название или индекс внутри объекта:
d = gmtime()
print(d.tm_year, d[0])
print(tuple(d))  # Преобразование в кортеж
# localtime([<Количество секунд>]) - возвращает объект struct_time, представляющий локальное время. Если параметр не
# указан, то возвращается текущее время. Если параметр указан, то время будет не текущим, а соответствующим количеству
# секунд, прошедших с начала эпохи.
print(localtime())              # Текущая дата и время
print(localtime(1551886771.0))  # Дата 06.03.2019
# mktime(<Объект struct_time>) - возвращает вещественное число, представляющее количество секунд, прошедших с начала
# эпохи. В качестве параметра указывается объект struct_tirne или кортеж из девяти элементов. Если указанная дата
# некорректна, возбуждается исключение OverflowError.
d = localtime(1551886771.0)
print(mktime(d))
print(tuple(localtime(1551886771.0)))
print(mktime((2019, 3, 6, 17, 39, 31, 2, 65, 0)))
# print(mktime((1940, 0, 31, 5, 23, 43, 5, 31, 0)))
# Объект struct_time, возвращаемый функциями gmtime() и localtime(), содержит следую­щие атрибуты (указаны пары вида
# «имя атрибута - индекс - описание»):
# tm_year  - О - год;
# tm_mon   - 1 - месяц (число от 1 до 12);
# tm_mday  - 2 - день месяца (число от 1 до 31);
# tm_hour  - 3 - час (число от 0 до 23);
# tm_min   - 4 - минуты (число от 0 до 59);
# tm_sec   - 5 - секунды (число от 0 до 59);
# tm_wday  - б - день недели (число от 0 для понедельника до 6 для воскресенья);
# tm_yday  - 7 - количество дней, прошедшее с начала года (число от 1 до 366);
# tm_isdst - 8 - флаг коррекции летнего времени (значения 0, 1 или -1).
# Вывод текущей даты и время таким образом, чтобы день недели и месяц были написаны по-русски (test_00052.py).


# 10.2 Форматирование даты и времени
print('Форматирование даты и времени:')
# Форматирование даты и времени выполняют следующие функции из модуля time:
# strftime(<Строка формата>[, <Объект struct_time>]) - возвращает строковое представление даты в соответствии со
# строкой формата. Если второй параметр не указан, бу­дут выведены текущие дата и время. Если во втором параметре указан
# объект struct_time или кортеж из девяти элементов, то дата будет соответствовать указанному значению. Функция зависит
# от настройки локали.
print(strftime('%d.%m.%Y'))  # Форматирование даты
print(strftime('%H:%M:%S'))  # Форматирование времени
print(strftime('%d.%m.%Y', localtime(1321954972.0)))
# strptime(<Строка с датой>[, <Строка формата>]) - разбирает строку, указанную в первом параметре, в соответствии со
# строкой формата. Возвращает объект struct_time. Если строка не соответствует формату, возбуждается исключение
# ValueError. Если строка формата не указана, используется строка '%а %Ь %d %Н: %М: %S %Y'.
print(strptime('Fri Apr 03 14:01:34 2015'))
print(strptime('03.04.2015', '%d.%m.%Y'))
# print(strptime('03-04-2015', '%d.%m.%Y'))
# asctime([<Объект struct_time>]) - возвращает строку формата '%а %Ь %d %H:%M:%S %Y'. Если параметр не указан, будут
# выведены текущие дата и время. Если в параметре указан объект struct_time или кортеж из девяти элементов, то дата
# будет соответствовать указанному значению.
print(asctime())                         # Текущая дата
print(asctime(localtime(1321954972.0)))  # Дата в прошлом
# ctime([<Количество секунд>]) - функция аналогична asctime(), но в качестве параметра принимает не объект struct_tirne,
# а количество секунд, прошедших с начала эпо­хи.
print(ctime())              # Текущая дата
print(ctime(1321954972.0))  # Дата в прошлом
# В параметре <Строка формата> в функциях strftime() и strptime() могут быть использова­ны следующие комбинации
# специальных символов:
# %y - год из двух цифр (от '00' до '99');
# %Y - год из четырех цифр (например, '2011 ');
# %m - номер месяца с предваряющим нулем (от '01' до '12');
# %b - аббревиатура месяца в зависимости от настроек локали (например, 'янв' для января);
# %В - название месяца в зависимости от настроек локали (например, 'Январь');
# %d - номер дня в месяце с предваряющим нулем (от '01' до '31');
# %j - день с начала года (от '001' до '366');
# %U - номер недели в году (от '00' до '53'). Неделя начинается с воскресенья. Все дни с начала года до первого
# воскресенья относятся к неделе с номером 0;
# %W - номер недели в году (от '00' до '53'). Неделя начинается с понедельника. Все дни с начала года до первого
# понедельника относятся к неделе с номером 0;
# %w - номер дня недели ('0' - для воскресенья, '6' - для субботы);
# %a - аббревиатура дня недели в зависимости от настроек локали (например, 'Пн' для понедельника);
# %A - название дня недели в зависимости от настроек локали (например, 'понедельник');
# %Н - часы в 24-часовом формате (от '00' до '23');
# %I - часы в 12-часовом формате (от '01' до '12');
# %M - минуты (от '00' до '59');
# %S - секунды (от '00' до '59', изредка до '61 ');
# %p - эквивалент значениям АМ и РМ в текущей локали;
# %c - представление даты и времени в текущей локали;
# %x - представление даты в текущей локали;
# %X - представление времени в текущей локали.
# setlocale(LC_ALL, 'Russian_Russia.1251')
print(strftime('%x'))  # Представление даты
print(strftime('%X'))  # Представление времени
print(strftime('%c'))  # Дата и время
# %Z - название часового пояса или пустая строка (например, 'Московское время', 'UTC');
# %% - символ'%'.
# Вывод текущей даты и времени с помощью функции strftime() (test_00053.py)


# 10.3 "Засыпание" скрипта
print('"Засыпание" скрипта:')
# Функция sleep(<Время в секундах>) из модуля time прерывает выполнение скрипта на указанное время, по истечении
# которого скрипт продолжит работу. В качестве параметра можно указать целое или вещественное число.
# import time    # Подключение модуля time
# time.sleep(5)  # 'Засыпаем' на 5 секунд


# 10.4 Модуль datetime. Манипуляции датой и временем
print('Модуль datetime. Манипуляции датой и временем:')
# Модуль datetime позволяет манипулировать датой и временем. Например, выполнять арифметические операции, сравнивать
# даты, выводить дату и время в различных форматах и др. Прежде чем использовать классы из этого модуля, необходимо
# подключить модуль с ПОМОЩЬЮ инструкции:
# import datetime
# Модуль содержит пять классов:
# timedelta - дата в виде количества дней, секунд и микросекунд. Экземпляр этого клас­са можно складывать с экземплярами
# классов date и datetime. Кроме того, результат вычитания двух дат будет экземпляром класса timedelta;
# date - представление даты в виде объекта;
# time - представление времени в виде объекта;
# datetime - представление комбинации даты и времени в виде объекта;
# tzinfo- абстрактный класс, отвечающий за зону времени. За подробной информацией по этому классу обращайтесь к
# документации по модулю datetime.


# 10.4.1 Класс timedelta
print('Класс timedelta:')
# Класс timedelta из модуля datetime позволяет выполнять операции над датами - например: складывать, вычитать,
# сравнивать и др. Конструктор класса имеет следующий формат:
# timedelta([days][, seconds][, microseconds][, milliseconds][, minutes][, hours][, weeks])
# Все параметры не являются обязательными и по умолчанию имеют значение 0. Первые три параметра считаются основными:
# days - дни (диапазон -999999999 <= days <= 999999999);
# seconds - секунды (диапазон 0 <= seconds < 3600*24);
# microseconds - микросекунды (диапазон О <= microseconds < 1000000).
# Все остальные параметры автоматически преобразуются в следующие значения:
# milliseconds - миллисекунды (одна миллисекунда преобразуется в 1000 микросекунд):
print(datetime.timedelta(milliseconds=1))
# minutes - минуты (одна минута преобразуется в 60 секунд):
print(datetime.timedelta(minutes=1))
# hours - часы (один час преобразуется в 3600 секунд):
print(datetime.timedelta(hours=1))
# weeks - недели (одна неделя преобразуется в 7 дней):
print(datetime.timedelta(weeks=1))
# Значения можно указывать через запятую в порядке следования параметров или присвоить значение названию параметра. В
# качестве примера укажем один час:
print(datetime.timedelta(0, 0, 0, 0, 0, 1))
print(datetime.timedelta(hours=1))
# Получить результат можно с помощью следующих атрибутов:
# days         - дни;
# seconds      - секунды;
# microseconds - микросекунды.
d = datetime.timedelta(hours=1, days=2, milliseconds=1)
print(d)
print(d.days, d.seconds, d.microseconds)
print(repr(d), str(d))
# Получить результат в секундах позволяет метод total_seconds():
d = datetime.timedelta(minutes=1)
print(d.total_seconds())
# Над экземплярами класса timedelta можно производить арифметические операции +, -, /, / /, % и *, использовать унарные
# операторы + и -, а также получать абсолютное значение с помощью функции abs().
d1 = datetime.timedelta(days=2)
d2 = datetime.timedelta(days=7)
print(d1 + d2, d2 - d1)  # Сложение и вычитание
print(d2 / d1)           # Деление
print(d1 / 2, d2 / 2.5)  # Деление
print(d2 // d1)          # Деление
print(d1 // 2, d2 // 2)  # Деление
print(d2 % d1)           # Остаток
print(d1 * 2, d2 * 2)    # Умножение
print(2 * d1, 2 * d2)    # Умножение
d3 = -d1
print(d3, abs(d3))
# Кроме того, можно использовать операторы сравнения =, ! = , <, < = , > и > = .
d1 = datetime.timedelta(days=2)
d2 = datetime.timedelta(days=7)
d3 = datetime.timedelta(weeks=1)
print(d1 == d2, d2 == d3)  # Проверка на равенство
print(d1 != d2, d2 != d3)  # Проверка на неравенство
print(d1 < d2, d2 <= d3)   # Меньше, меньше или равно
print(d1 > d2, d2 >= d3)   # Больше, больше или равно
# Также можно получать строковое представление объекта timedelta с помощью функций str() и repr():
d = datetime.timedelta(hours=25, minutes=5, seconds=27)
print(str(d))
print(repr(d))
# Поддерживаются следующие атрибуты класса:
# min        - минимальное значение, которое может иметь объект timedelta;
# max        - максимальное значение, которое может иметь объект timedelta;
# resolution - минимальное возможное различие между значениями timedelta.
# Вывод значения этих атрибутов:
print(datetime.timedelta.min)
print(datetime.timedelta.max)
print(datetime.timedelta.resolution)


# 10.4.2 Класс date
print('Класс date:')
# Класс date из модуля datetime позволяет выполнять операции над датами. Конструктор класса имеет следующий формат:
# date(<Год>, <Месяц>, <День>:
# Все параметры являются обязательными. В параметрах можно указать следующий диапазон значений:
# <Год>   - в виде числа, расположенного в диапазоне между значениями, хранящимися в константах MINYEAR и МАХУЕАR класса
# datetime (о нем речь пойдет позже). Вывод значений этих констант:
# import datetime
print(datetime.MINYEAR, datetime.MAXYEAR)
# <Месяц> - от 1 до 12 включительно;
# <День>  - от 1 до количества дней в месяце.
# Если значения выходят за диапазон, возбуждается исключение ValueError.
print(datetime.date(2015, 4, 3))
# print(datetime.date(2015, 13, 3))  # Неправильное значение для месяца
d = datetime.date(2015, 4, 3)
print(repr(d), str(d))
# Для создания объекта класса date также можно воспользоваться следующими методами этого класса:
# today() - возвращает текущую дату:
print(datetime.date.today())  # Получение текущей даты
# fromtimestamp(<Количество секунд>) - возвращает дату, соответствующую количеству секунд, прошедших с начала эпохи:
print(datetime.date.fromtimestamp(time()))        # Текущая дата
print(datetime.date.fromtimestamp(1321954972.0))  # Дата 2011-11-22
# fromordinal(<Количество дней с 1-го года>) - возвращает дату, соответствующую количеству дней, прошедших с первого
# года. В качестве параметра указывается число от 1 до datetime.date.max.toordinal().
print(datetime.date.max.toordinal())
print(datetime.date.fromordinal(3652059))
print(datetime.date.fromordinal(1))
# Получить результат можно с помощью следующих атрибутов:
# year  - год (число в диапазоне от MINYEAR до МАХУЕАR);
# month - месяц (число от 1 до 12);
# day   - день (число от 1 до количества дней в месяце).
d = datetime.date.today()  # Текущая дата 2019-03-21
print(d.year, d.month, d.day)
# Над экземплярами класса date можно производить следующие операции:
# date2 = date1 + timedelta - прибавляет к дате указанный период в днях. Значения атрибутов timedelta.seconds и
# timedelta. microseconds игнорируются;
# date2 = date1 - timedelta - вычитает из даты указанный период в днях. Значения атрибутов timedelta.seconds и
# timedelta.microseconds игнорируются;
# timedelta = date1 - date2 - возвращает разницу между датами (период в днях). Атрибуты timedelta.seconds и
# timedelta.microseconds будут иметь значение 0;
# можно также сравнивать две даты с помощью операторов сравнения.
d1 = datetime.date(2015, 4, 3)
d2 = datetime.date(2015, 1, 1)
t = datetime.timedelta(days=10)
print(d1 + t, d1 - t)  # Сложение и вычитание 10 дней
print(d1 - d2)         # Разность между датами
print(d1 < d2, d1 > d2, d1 <= d2, d1 >= d2)
print(d1 == d2, d1 != d2)
# Экземпляры класса date поддерживают следующие методы:
# replace([year][, month][, day]) - возвращает дату с обновленными значениями. Значения можно указывать через запятую в
# порядке следования параметров или присвоить значение названию параметра.
d = datetime.date(2015, 4, 3)
print(d)
print(d.replace(2014, 12))  # Замена года и месяца
print(d.replace(year=2015, month=1, day=31))
print(d.replace(day=30))    # Замена только дня
# strftime(<Строка формата>) - возвращает отформатированную строку. В строке формата можно задавать комбинации
# специальных символов, которые используются в функции strftime() из модуля time.
d = datetime.date(2015, 4, 3)
print(d.strftime('%d.%m.%Y'))
# isoformat() - возвращает дату в формате гггг-мм-дд:
d = datetime.date(2015, 4, 3)
print(d.isoformat())
# ctime() - возвращает строку формата "%а %Ь %d %H:%M:%S %У":
d = datetime.date(2015, 4, 3)
print(d.ctime())
# timetuple() - возвращает объект struct_time с датой и временем:
d = datetime.date(2015, 4, 3)
print(d.timetuple())
# toordinal() - возвращает количество дней, прошедших с 1-ro года:
d = datetime.date(2015, 4, 3)
print(d.toordinal())
print(datetime.date.fromordinal(735691))
# weekday() - возвращает порядковый номер дня в неделе (0 - для понедельника, 6 - для воскресенья):
d = datetime.date(2015, 4, 3)
print(d.weekday())  # 4 - это пятница
# isoweekday() - возвращает порядковый номер дня в неделе (1 - для понедельника, 7 - для воскресенья):
d = datetime.date(2015, 4, 3)
print(d.isoweekday())  # 5 - это пятница
# isocalendar () - возвращает кортеж из трех элементов (год, номер недели в году и порядковый номер дня в неделе):
d = datetime.date(2015, 4, 3)
print(d.isocalendar())
# Наконец, имеется поддержка следующих атрибутов класса:
# min        - минимально возможное значение даты;
# max        - максимально возможное значение даты;
# resolution - минимальное возможное различие между значениями даты.
# Значения этих атрибутов:
print(datetime.date.min)
print(datetime.date.max)
print(datetime.date.resolution)


# 10.4.3 Класс time
print('Класс time:')
# Класс time из модуля datetime позволяет выполнять операции над временем. Конструктор класса имеет следующий формат:
# time((hour][, minute][, second][, microsecond][, tzinfo])
# Все параметры не являются обязательными. Значения можно указывать через запятую в порядке следования параметров или
# присвоить значение названию параметра. В параметрах можно указать следующий диапазон значений:
# hour        - часы (число от 0 до 23);
# minute      - минуты (число от 0 до 59);
# second      - секунды (число от 0 до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo      - зона (экземпляр класса tzinfo или значение None).
# fold        - порядковый номер отметки времени. Значение 0 (используется по умолчанию) обозначает первую отметку,
# значение 1 - вторую. Введено в Python 3.6 для тех случаев, когда в той или иной временной зоне практикуется перевод
# часов с зимнего на летнее время и обратно, в результате чего часы могут дважды в сутки показывать одинаковое время.
# Если значения выходят за диапазон, возбуждается исключение ValueError.
print(datetime.time(23, 12, 38, 375000))
t = datetime.time(hour=23, second=38, minute=12)
print(repr(t), str(t))
# print(datetime.time(25, 12, 38, 375000))
# Получить результат можно с помощью следующих атрибутов:
# hour        - часы (число от 0 до 23);
# minute      - минуты (число от 0 до 59);
# second      - секунды (число от 0 до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo      - зона (экземпляр класса tzinfo или значение None).
# fold        - порядковый номер отметки времени (число 0 или 1). Поддержка этого атрибута появилась в Python 3.6.
t = datetime.time(23, 12, 38, 375000)
print(t.hour, t.minute, t.second, t.microsecond)
# Над экземплярами класса time нельзя выполнять арифметические операции. Можно только производить сравнения.
t1 = datetime.time(23, 12, 38, 375000)
t2 = datetime.time(12, 28, 17)
print(t1 < t2, t1 > t2, t1 <= t2, t1 >= t2)
print(t1 == t2, t1 != t2)
# Экземпляры класса time поддерживают следующие методы:
# replace([hour][, minute][, second][, microsecond][, tzinfo]) - возвращает время с обновленными значениями. Значения
# можно указывать через запятую в порядке следования параметров или присвоить значение названию параметра.
t = datetime.time(23, 12, 38, 375000)
print(t.replace(10, 52))     # Заменяем часы и минуты
print(t.replace(second=21))  # Заменяем только секунды
# isoformat() - возвращает время в формате ISO 8601:
t = datetime.time(23, 12, 38, 375000)
print(t.isoformat())
# strftime(<Строка формата>) - возвращает отформатированную строку. В строке формата можно указывать комбинации
# специальных символов, которые используются в функции strftime() из модуля time.
t = datetime.time(23, 12, 38, 375000)
print(t.strftime('%H:%M:%S'))
# Тип time поддерживает такие атрибуты класса:
# min        - минимально возможное значение времени;
# max        - максимально возможное значение времени;
# resolution - минимальное возможное различие между значениями времени.
# Значения этих атрибутов:
print(datetime.time.min)
print(datetime.time.max)
print(datetime.time.resolution)
# Примечание - Экземпляры класса time поддерживают также методы dst(), utcoffset() и tzname(). За подробной информацией
# по этим методам, а также по абстрактному классу tzinfo(), обращайтесь к документации по модулю datetime.


# 10.4.4 Класс datetime
print('Класс datetime:')
# Класс datetime из модуля datetime позволяет выполнять операции над комбинацией даты и времени. Конструктор класса
# имеет следующий формат:
# datetime(<Гoд>, <Месяц>, <День>[, hour][, minute][, second][, microsecond][, tzinfo])
# Первые три параметра являются обязательными. Остальные значения можно указывать через запятую в порядке следования
# параметров или присвоить значение названию параметра. В параметрах можно указать следующий диапазон значений:
# <Год>       - в виде числа, расположенного в диапазоне между значениями, хранящимися в константах MINYEAR(1) и
# МАХУЕАR(9999);
# <Месяц>     - число от 1 до 12 включительно;
# <День>      - число от 1 до количества дней в месяце;
# hour        - часы (число от 0 до 23);
# minute      - минуты (число от 0 до 59);
# second      - секунды (число от 0 до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo      - зона (экземпляр класса tzinfo или значение None).
# fold        - порядковый номер отметки времени. Значение 0 (используется по умолчанию) обозначает первую отметку,
# значение 1 - вторую. Введено в Python 3.6 для тех случаев, когда в той или иной временной зоне практикуется перевод
# часов с зимнего на летнее время и обратно, в результате чего часы могут дважды в сутки показывать одинаковое время.
# Если значения выходят за диапазон, возбуждается исключение ValueError.
print(datetime.datetime(2017, 11, 21))
print(datetime.datetime(2017, 11, 21, hour=12, minute=55))
# print(datetime.datetime(2015, 32, 20))
d = datetime.datetime(2017, 11, 21, 17, 1, 5)
print(repr(d), str(d))
# Для создания экземпляра класса можно также воспользоваться следующими методами:
# today() - возвращает текущие дату и время:
print(datetime.datetime.today())
# now((<Зона>)) - возвращает текущие дату и время. Если параметр не задан, то метод аналогичен методу today().
print(datetime.datetime.now())
# utcnow() - возвращает текущее универсальное время (UTC):
print(datetime.datetime.utcnow())
# fromtimestamp(<Количество секунд>[, <Зона>]) - возвращает дату, соответствующую количеству секунд, прошедших с
# начала эпохи:
print(datetime.datetime.fromtimestamp(time()))
print(datetime.datetime.fromtimestamp(1421579037.0))
# utcfromtimestamp{<Количество секунд>) - возвращает дату, соответствующую количеству секунд, прошедших с начала эпохи,
# в универсальном времени (UTC).
print(datetime.datetime.utcfromtimestamp(time()))
print(datetime.datetime.utcfromtimestamp(1421579037.0))
# fromordinal(<Количество дней с 1-го года>) - возвращает дату, соответствующую количеству дней, прошедших с 1-го года.
# В качестве параметра указывается число от 1 до datetime.datetime.max.toordinal().
print(datetime.datetime.fromordinal(3652059))
print(datetime.datetime.fromordinal(1))
# combine(<Экземпляр класса date>, <Экземпляр класса time>) - создает экземпляр класса datetirne в соответствии со
# значениями экземпляров классов date и time:
d = datetime.date(2017, 11, 21)  # Экземпляр класса date
t = datetime.time(16, 7, 22)   # Экземпляр класса time
print(datetime.datetime.combine(d, t))
# strptime(<Строка с датой>, <Строка формата>) - разбирает строку, указанную в первом параметре, в соответствии со
# строкой формата. Если строка не соответствует формату, возбуждается исключение ValueError.
print(datetime.datetime.strptime('06.04.2015', '%d.%m.%Y'))
# print(datetime.datetime.strptime('O6.04.2015', '%d-%m-%Y'))
# Получить результат можно с помощью следующих атрибутов:
# year        - год (число в диапазоне от MINYEAR до МАХУЕАR);
# month       - месяц (число от 1 до 12);
# dау         - день (число от 1 до количества дней в месяце );
# hour        - часы (число от 0 до 23);
# minute      - минуты (число от 0 до 59);
# second      - секунды (число от о до 59);
# microsecond - микросекунды (число от 0 до 999999);
# tzinfo      - зона (экземпляр класса tzinfo или значение None).
# fold        - порядковый номер отметки времени (число 0 или 1). Поддержка этого атрибута появилась в Python 3.6.
d = datetime.datetime(2017, 11, 21, 17, 7, 22)
print(d.year, d.month, d.day)
print(d.hour, d.minute, d.second, d.microsecond)
# Над экземплярами класса datetime можно производить следующие операции:
# datetime2 = datetimel + timedelta - прибавляет к дате указанный период;
# datetime2 = datetimel - timedelta - вычитает из даты указанный период;
# timedelta = datetimel - datetime2 - возвращает разницу между датами;
# можно также сравнивать две даты с помощью операторов сравнения.
d1 = datetime.datetime(2017, 11, 21, 17, 7, 22)
d2 = datetime.datetime(2015, 4, 1, 12, 31, 4)
t = datetime.timedelta(days = 10, minutes = 10)
print(d1 + t)   # Прибавляем 10 дней и 10 минут
print(d1 - t)   # Вычитаем 10 дней и 10 минут
print(d1 - d2)  # Разница между датами
print(d1 < d2, d1 > d2, d1 <= d2, d1 >= d2)
print(d1 == d2, d1 != d2)
# Экземпляры класса datetime поддерживают следующие методы:
# date() - возвращает экземпляр класса date, хранящий дату:
d = datetime.datetime(2017, 11, 21, 17, 10, 54)
print(d.date())
# time() - возвращает экземпляр класса time, хранящий время:
d = datetime.datetime(2017, 11, 21, 17, 10, 54)
print(d.date())
# timetz() - возвращает экземпляр класса time, хранящий время. Метод учитывает параметр tzinfo;
# timestamp() - возвращает вещественное число, представляющее количество секунд, прошедшее с начала эпохи (обычно с 1
# января 1970 г.).
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.timestamp())
# replace([year][, month][, day][, hour][, minute][, second][, microsecond][, tzinfo]) - возвращает дату с обновленными
# значениями. Значения можно указывать через запятую в порядке следования параметров или присвоить значение названию
# параметра:
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.replace(2016, 12))
print(d.replace(hour=12, month=10))
# timetuple() - возвращает объект struct_time с датой и временем:
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.timetuple())
# utctimetuple() - возвращает объект struct_time с датой в универсальном времени (UTC):
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.utctimetuple())
# toordinal() - возвращает количество дней, прошедшее с 1-го года:
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.toordinal())
# weekday() - возвращает порядковый номер дня в неделе (0 - для понедельника, 6 - для воскресенья):
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.weekday())  # 1 - это вторник
# isoweekday() - возвращает порядковый номер дня в неделе (1- для понедельника, 7 - для воскресенья):
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.isoweekday())  # 2 - это вторник
# isocalendar() - возвращает кортеж из трех элементов (год, номер недели в году и порядковый номер дня в неделе):
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.isocalendar())
# isoformat([<Разделитель даты и времени>]) - возвращает дату в формате ISO 8601. Если разделитель не указан,
# используется буква т:
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.isoformat())  # Разделитель не указан
print(d.isoformat())  # Пробел в качестве разделителя
# ctime() - возвращает строку формата "%а %b %d %H:%M:%S %y":
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.ctime())
# strftime(<Строка формата>) - возвращает отформатированную строку. В строке формата можно указывать комбинации
# специальных символов, которые используются в функции strftime() из модуля time:
d = datetime.datetime(2017, 11, 21, 17, 56, 41)
print(d.strftime('%d.%m.%Y %H:%M:%S'))
# Поддерживаются также следующие атрибуты класса:
# min        - минимально возможные значения даты и времени;
# max        - максимально возможные значения даты и времени;
# resolution - минимальное возможное различие между значениями даты и времени.
# Значения этих атрибутов:
print(datetime.datetime.min)
print(datetime.datetime.max)
print(datetime.datetime.resolution)
# Примечание - Класс datetime также поддерживает методы astimezone(), dst(), utcoffset() и tzname(). За подробной
# информацией по этим методам, а также по абстрактному классу tzinfo обращайтесь к документации по модулю datetime.


# 10.5. Модуль calendar, вывод календаря
print('Модуль calendar, вывод календаря:')
#
#
#
# 200
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

