#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from sys import stdout  # Подключаем из модуля sys содержащийся в нем объект stdout

# Глава 1
# 1.4. Принципы написания Python-программ
# Программа, написанная на Python, представляет собой обычный текстовый файл с расширением ру (будет исполнен обычным
# интерпретатором python.exe) или pyw (будет исполнен «оконным» интерпретатором pythonw.exe).
# Для написания Python-программ, как уже ранее отмечалось, можно использовать, помимо IDLE, любой подходящий текстовый
# редактор: стандартный Блокнот, Notepad++ (https://notepad-plus-plus.org/), Visual Studio Code
# (https://code.visualstudio.com/) и др.
# Также существует ряд специализированных текстовых редакторов, предназначенных именно для Python-программистов, в
# частности PyCharm' (https://www.jetbrains.com/ru-ru/pycharm/).
# Инструкции, записанные в коде программы, выполняются последовательно, в порядке сверху вниз.
# Каждая инструкция Python должна располагаться на отдельной строке. Признаком конца инструкции является перевод строки.
# Пример программы из двух выражений (test_00003.py).
# Первое выражение складывает числа 15, 20 и 30 и заносит сумму в переменную с именем х (переменная - ячейка памяти,
# имеющая уникальное имя, способная хранить какое-либо значение - например, число, и создаваемая при присваивании ей
# значения). Второе выражение выводит содержимое этой переменной - число 65 - в консоли.
# В первом выражении используются два оператора. Оператором называется языковая конструкция, выполняющая над переданными
# ему значениями какое-либо элементарное действие (например, сложение чисел или присваивание результата указанной
# переменной). Оператор сложения обозначается привычным символом +, а оператор присваивания - символом =.
# В Windows перевод строки формируется комбинацией символов \r (перевод каретки) и \n (перевод строки), в UNIX - одним
# символом \n.
# Если загрузить файл Python-программы по протоколу FTP в бинарном режиме, то символ \r вызовет фатальную ошибку. По
# этой причине файлы по протоколу FTP следует загружать только в текстовом (ASCII) режиме - тогда символ \r будет удален
# автоматически.
# Если строка с инструкцией получилась слишком длинной, инструкцию можно разделить на несколько строк одним из следующих
# способов:
# - поставить в месте разрыва строк символ \, сразу после которого вставить перевод строки(как обычно, нажатием клавиши
# <Enter>):
x = 15 + 20 + \
    30
print(x)
# Как правило, вторая и все последующие строки, содержащие длинное ,выражение, набираются с отступами слева - для
# улучшения читаемости кода. Следует только формировать эти отступы исключительно пробелами и делать одинаковой длины
# (содержащими одинаковое количество пробелов).
# При вводе подобного рода многострочной инструкции в интерпретаторе, работающем в интерактивном режиме, строки с
# продолжением инструкции помечаются расположенным слева приглашением в виде трех точек( ... , а не >>>, как обычно).
# Кроме того, интерпретатор сам выводит последующие строки с отступами. Чтобы завершить ввод многострочной инструкции,
# следует, введя ее последнюю строку, нажать клавишу <Enter> (при этом после многострочной инструкции будет создана
# пустая строка с приглашением из трех точек).
# - заключить выражение в круглые скобки, внутри которых вставить нужное количество переводов строки:
x = (15 +
     20 +
     30)
print(x)
# - определение списка и словаря, при оформлении которых используются квадратные и фигурные скобки соответственно, также
# можно разбить на несколько строк:
#  - пример определения списка:
arr = [15, 20,
       30]
print(arr)
#  - пример определения словаря:
arr = {'x': 15, 'y': 20,
       'z': 30}
print(arr)
# - Короткие инструкции можно записать в одной строке, разделив их символами точки с запятой (;):
x = 15 + 20 + 30; print(x)
# После точки с запятой не возбраняется ставить пробел - для улучшения читаемости кода.
# - Блоки (наборы из произвольного количества инструкций, входящие в состав более сложных инструкций) формируются
# отступами слева. Такие отступы должны формироваться исключительно пробелами и быть одинаковой длины (т. е. содержать
# одинаковое количество пробелов). Символы табуляции в отступах не допускаются и при выполнении программы вызывают
# возникновение ошибки.
# Код программы, выводящей последовательно числа от 1 до 10, которые разделяются тремя дефисами (test_00004.py).
# Первая строка содержит сложную инструкцию - цикл, который выполняется десять раз. При каждом исполнении он заносит в
# переменную i очередное число в диапазоне от 1 до 10 и выполняет блок, входящий в его состав. Этот блок состоит из
# двух инструкций, записанных во второй и третьих строках: первая инструкция выводит в консоли число из переменной i, а
# вторая - строку из трех дефисов. Обе инструкции, входящие в блок, имеют одинаковый отступ слева, содержащий 4 пробела.
# Числа, перебираемые циклом (и, соответственно, количество выполнений, или итераций, цикла), указываются в функции
# range() (первая инструкция в test_00004.py). Первый параметр задает начальное число перебираемого диапазона, второй -
# конечное число плюс 1.
# При вводе инструкции, содержащей блок, в интерпретаторе, который работает в интерактивном режиме, интерпретатор
# предваряет выражения, входящие в блок, приглашением в виде трех точек (...) и сам вставляет отступы. Чтобы завершить
# ввод блока, следует, занеся последнее входящее в него выражение, нажать клавишу <Enter> (при этом в набранном коде
# появится пустая строка с приглашением в виде трех точек).
# - Если блок содержит одну короткую инструкцию, и сам блок, и сложную инструкцию, в состав которой он входит, можно
# записать в одну строку. При этом интерпретатор посчитает, что ввод блока продолжится после нажатия клавиши <Enter>, и
# выведет приглашение в виде трех точек. Чтобы завершить ввод инструкции, следует снова нажать <Enter>. Пример
# программы, выводящей в консоли числа от 1 до 10:


# 1.4.1. Комментарии и строки документирования
# Комментарий - это произвольное пояснение, вставленное в код программы, предназначенное исключительно программисту и
# полностью игнорируемое интерпретатором. Внутри комментария может располагаться любой текст.
# Комментарий в языке Python начинается с символа # и заканчивается концом строки:
# Выводим числа от 1 до 10
for i in range(1, 11):
    print(i)
# Комментарий может располагаться после собственно инструкции:
print('Bce, числа закончились')  # Сообщаем об окончании чисел
# Если символ # разместить перед инструкцией, то она не будет выполнена (закомментированная инструкция):
# print('Привет, мир!') Эта инструкция выполнена не будет
# Если требуется разместить комментарий из нескольких строк, перед каждой из них придется ставить символ #:
# Это наша первая программа!
# Она выводит числа от 1 до 10
# Да, не впечатляет, но для начала неплохо...
for i in range(1, 11):
    print(i)
# Строки документирования Python обычно применяются для написания инструкций к программам и модулям. Однако их можно
# использовать и для комментирования кода.
# Строка документирования заключается в утроенные кавычки или апострофы:
"""
Это наша первая программа!
Она выводит числа от 1 до 10
Да, не впечатляет, но для начала неплохо...
"""
for i in range(1, 11):
    print(i)


# 1.4.2. Кодировки, поддерживаемые Python
# Код Python-программы, написанный в IDLE, по умолчанию сохраняется в кодировке UTF-8 без BOM.
# ВОМ (Byte Order Mark) - метка порядка байтов. Указывает порядок, в котором записываются байты, кодирующие символы
# в UTF-8.
# Если программу следует сохранить в какой-либо другой кодировке (что может пригодиться, например, при переписывании
# старого Python-кода), в первой строке ее кода следует указать кодировку с помощью инструкции формата:
# -*- coding: <Обозначение кодировки>-*-
# Например, кодировка Windows-1251 указывается инструкцией:
# -*- coding: ср1251 -*-
# Встретив такую инструкцию в коде программы, IDLE при сохранении файла самостоятельно переведет программу в кодировку с
# заданным обозначением. При использовании других редакторов следует перевести программу в указанную кодировку вручную.
# Получить полный список поддерживаемых Python кодировок и их обозначения позволяет программа (test_00005.py).


# 1.4.3. Подготовка Python-программ для выполнения в UNIX
# Если программа предназначена для исполнения в операционных системах семейства UNIX, в первой строке кода программы
# необходимо указать путь к интерпретатору Python:
# #!/usr/bin/python
# В некоторых UNIХ-системах путь к интерпретатору выглядит по-другому:
# #!/usr/local/bin/python
# Иногда можно не указывать точный путь к интерпретатору, а передать название языка программе env:
# #!/usr/bin/env python
# В этом случае программа env произведет поиск интерпретатора Python в соответствии с настройками путей поиска.
# Если программа, исполняемая в UNIX, сохранена в кодировке, отличной от UTF-8, обозначение кодировки указывается во
# второй строке ее кода:
# #!/usr/bin/python
# # -*- coding: ср1251 -*-
# Также следует разрешить выполнять Python-программу, указав у ее файла права 755 (-rwxrxr-x).


# 1.6. Вывод данных
# вывести заданные значения можно с помощью функции print():
# print([<Значения через запятую>][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False])
# Указанные значения при необходимости преобразуются в строки и посылаются в стандартный поток вывода stdout. С помощью
# параметра file можно перенаправить вывод в другое место - например, в файл. При этом, если параметр flush имеет
# значение False, выводимые значения будут записаны в файл принудительно.
# Если выполняется вывод одного значения, автоматически добавляется символ перевода строки:
print('Строка 1')
print('Строка 2')
# Результат:
# Строка 1
# Строка 2
# Можно вывести несколько значений в одну строку, указав их в вызове функции print() отдельными параметрами,
# разделенными запятыми:
print('Строка 1', 'Строка 2')
# Результат:
# Строка 1 Строка 2
# Как видно из примера, между выводимыми значениями автоматически вставляется пробел. С помощью параметра sep можно
# указать другой разделяющий символ. Например, выведем строки без пробела между ними, указав в качестве разделителя
# пустую строку:
print('Строка 1', 'Строка 2', sep='')
# Результат:
# Строка 1Строка 2
# Ряд функций, встроенных в Python, поддерживают так называемые именованные параметры. В число таких параметров и входит
# sep. Обратим внимание, как задается его значение в приведенном примере. После вывода нескольких значений в одном
# вызове функции print() в конце добавляется символ перевода строки. Если необходимо произвести дальнейший вывод на той
# же строке, то в именованном параметре end следует указать другой символ:
print('Строка 1', 'Строка 2', end=' ')
print('Строка 3')
# Выведет: Строка 1 Строка 2 Строка 3
# Вызов функции print() без параметров выводит пустую строку:
for n in range(1, 5):
    print(n, end=' ')
print()
print('Это текст на новой строке')
# Результат выполнения:
# 1 2 3 4
# Это текст на новой строке
# Здесь мы использовали цикл, выполняющийся четыре раза. На каждой итерации он присваивает переменной n число от 1 до 4
# и выполняет блок, содержащий вызов функции print(), которая выводит число из переменной n. Не забываем вставить в
# выражение, входящее в блок, отступ слева.
# Как только цикл выполнится четыре раза, будут исполнены два следующих за ним выражения. В них отступы слева указывать
# не следует, поскольку эти выражения не должны входить в состав блока. Первое выражение выведет пустую строку, второе -
# надпись «Это текст на новой строке».
# Если необходимо вывести большой блок текста, его следует разместить между утроенными кавычками или утроенными
# апострофами. В этом случае текс, сохраняет свое форматирование:
print('''Строка 1
Строка 2
Строка 3''')
# В результате выполнения этого примера мы получим три строки:
# Строка 1
# Строка 2
# Строка 3
# Вместо функции print() можно использовать метод write() объекта stdout из модуля sys:
stdout.write('Строка\n')
# Модуль - это просто файл с Python-кодом. Однако модуль sys поставляется в составе Python и входит в стандартную
# библиотеку (набор модулей, содержащих полезные функции, объекты и др.) этого языка. Подключив этот модуль, мы можем
# использовать созданные в нем функции и объекты. В первой строке с помощью оператора import подключаем модуль sys, в
# котором объявлен объект stdout. Далее с помощью метода write() этого объекта выводим строку. Следует заметить, что
# метод не вставляет символ перевода строки, поэтому при необходимости следует добавить его самим с помощью символа \n:
stdout.write('Строка 1\n')
stdout.write('Строка 2\n')
# Метод write() возвращает результат - значение, полученное в процессе выполненных методом вычислений. Таковым
# результатом является количество символов в выведенной строке. Его можно присвоить какой-либо переменной и
# использовать в дальнейшем:
cnt = stdout.write('Привет, Python\n')
print('Символов в выведенной строке: ', cnt)
# Результат:
# Привет, Python
# Символов в выведенной строке: 15


# 1.7. Ввод данных
# Для ввода данных в Python предназначена функция input(), которая получает данные со стандартного потока ввода stdin.
# Функция имеет следующий формат:
# input([<Сообщение>])
# Введенное значение она возвращает в качестве результата. Этот результат следует присвоить какой-либо переменной
# посредством оператора =.
# Для примера переделаем программу так, чтобы она здоровалась не со всем миром, а только с нами (test_00006.py).
# В первой инструкции значение, введенное пользователем и полученное функцией input(), присваивается переменной name.
# Сохраняем программу в файле test_00006.py и запускаем на выполнение с помощью двойного щелчка. Откроется черное окно,
# в котором мы увидим надпись: Введите ваше имя: Вводим свое имя - например, Николай, и нажимаем клавишу <Enter>.
# В результате будет выведено приветствие: Привет, Николай.
# При использовании функции input() следует учитывать, что при достижении конца файла или при нажатии комбинации клавиш
# <Ctrl>+<Z>, а затем клавиши <Enter> генерируется исключение EOFError. Если не предусмотреть обработку исключения, то
# программа аварийно завершится. Обработать исключение можно следующим образом:
# try:
#   s = input('Введите данные: ')
#   print(s)
# except EOFError:
#   print('Обработали исключение EOFError')
# Если внутри блока try возникнет исключение EOFError, то управление будет передано в блок except. После исполнения
# инструкций в блоке except программа нормально продолжит работу.
# Передать данные можно в консоли, указав их после имени файла программы. Такие данные доступны через список argv из
# модуля sys. Первый элемент списка argv будет содержать имя файла запущенной программы, а последующие элементы -
# переданные данные. Для примера создадим файл test_00007.py в каталоге C:\book.
# Теперь запустим программу на выполнение из консоли, передав ей данные. Запустим консоль, для чего выберем в меню Пуск
# пункт Выполнить, в открывшемся окне наберем команду cmd и нажмем кнопку ОК. Откроется черное окно с приглашением для
# ввода команд. Перейдем в каталог C:\book, набрав команду:
# cd C:\book
# В консоли должно появиться приглашение:
# C:\book>
# Для запуска нашей программы вводим команду:
# test_00007.py uhud opk987
# В этой команде мы передаем имя файла (test_00007.py) и некоторые данные (-uNik и -р12З).
# Результат выполнения программы будет выглядеть так:
# test2.py
# uhud
# opk987


# 1.8. Утилита pip: установка дополнительных библиотек
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


# 37
