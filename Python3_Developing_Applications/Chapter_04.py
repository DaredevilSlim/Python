#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Глава 4
# Инструкции ветвления, выбора и циклы
# Инструкция ветвления позволяет при выполнении какого-либо условия исполнить один блок кода, а при невыполнении условия
# - другой. Инструкция выбора, если указанная переменная хранит одно значение, исполняет первый блок кода, если
# переменная хранит второе значение - второй блок кода, если третье - третий блок кода и т. д. Два вида циклов выполняют
# указанный блок кода либо столько раз, сколько элементов содержится в заданной последовательности, при этом перебирая
# ее элементы, либо пока выполняется заданное условие.
# В качестве условий в подобного рода инструкциях применяются выражения, в качестве результата выдающие логическую
# величину True («истина», условие выполняется, или истинно) или False («ложь», условие не выполняется, или ложно).
# Также в качестве условия можно использовать выражение, выдающее результат любого другого типа, который в этом случае
# будет автоматически приведен к логическому типу:
# в значение True будут преобразованы:
# - любое число, не равное нулю:
print(bool(1), bool(20), bool(-20))
print(bool(1.0), bool(0.1), bool(-20.0))
# - не пустой объект:
print(bool('O'), bool([0, None]), bool((None,)), bool({'x': 5}))
# в значение False будут преобразованы:
# - число, равное нулю:
print(bool(0), bool(0.0))
# - пустой объект:
print(bool(''), bool([]), bool(()))
# (False, False, False)
# - значение None:
print(bool(None))


# 4.1. Операторы сравнения
# Операторы сравнения применяются в условиях, чтобы сравнить значения указанных операндов:
# == - равно - значения обоих операндов должны быть равны друг другу:
print(1 == 1, 1 == 5)

# != - не равно - значения обоих операндов должны быть не равны друг другу:
print(1 != 5, 1 != 1)

# < - меньше - первый операнд должен быть меньше второго:
print(1 < 5, 1 < 0)

# > - больше - первый операнд должен быть больше второго:
print(1 > 0, 1 > 5)

# <= - меньше или равно - первый операнд должен быть меньше или равен второму:
print(1 <= 5, 1 <= 0, 1 <= 1)

# >= - больше или равно - первый операнд должен быть больше или равен второму:
print(1 >= 0, 1 >= 5, 1 >= 1)

# in - вхождение - первый операнд должен входить в последовательность из второго операнда:
print('Строка' in 'Строка для поиска')  # Строки
print(2 in [1, 2, 3], 4 in [1, 2, 3])   # Списки
print(2 in (1, 2, 3), 4 in (1, 2, 3))   # Кортежи
# Оператор in также можно использовать для проверки существования ключа в словаре:
print('x' in {'x': 1, 'y': 2}, 'z' in {'x': 1, 'y': 2})

# not in - невхождение - первый операнд не должен входить в последовательность из второго операнда:
print('Строка' not in 'Строка для поиска')     # Строки
print(2 not in [1, 2, 3], 4 not in [1, 2, 3])  # Списки
print(2 not in (1, 2, 3), 4 not in (1, 2, 3))  # Кортежи

# is - переменные, заданные операндами, должны ссылаться на один и тот же объект:
x = y = [1, 2]
print(x is y)
x = [1, 2]
y = [1, 2]
print(x is y)

# is not - переменные, заданные операндами, должны ссылаться на разные объекты:
x = y = [1, 2]
print(x is not y)
x = [1, 2]
y = [1, 2]
print(x is not y)
# Значение логического выражения можно инвертировать (изменить на противоположное) с помощью оператора логического
# НЕ - not:
x = 1
y = 1
print(x == y)
print(not (x == y), not x == y)
# Круглые скобки здесь можно не указывать, поскольку оператор not имеет более низкий приоритет, чем операторы сравнения.
# В логическом выражении можно указывать сразу несколько условий:
x = 10
print(1 < x < 20, 11 < x < 20)

# Несколько логических выражений можно объединить в одно большое с помощью следующих операторов:
# and - логическое И - если оба операнда равны True, возвращается True, в противном случае - False:
print(1 < 5 and 2 < 5)  # True and True == True
print(1 < 5 and 2 > 5)  # True and False == False
print(1 > 5 and 2 < 5)  # False and True == False
# Если значение первого операнда не относится к логическому типу, интерпретатор преобразует его в логический тип. Если
# после преобразования получается False, то возвращается значение первого операнда, в противном случае - значение
# второго операнда.
print(10 and 20, 0 and 20, 10 and 0)

# or - логическое ИЛИ - если хотя бы один операнд равен True, возвращается True, в противном случае - False:
print(1 < 5 or 2 < 5)  # True or True == True
print(1 < 5 or 2 > 5)  # True or False == True
print(1 > 5 or 2 < 5)  # False or True == True
print(1 > 5 or 2 > 5)  # False or False == False
# Если значение первого операнда не относится к логическому типу, интерпретатор преобразует его в логический тип. Если
# после преобразования получается False, то возвращается значение второго операнда, в противном случае - значение
# первого операнда.
print(10 or 20, 0 or 20, 10 or 0)
print(0 or '' or None or [] or 's')

# Перечислим операторы сравнения в порядке убывания приоритета:
# 1. <, >, <=, >=, =, ! =, <>, is, is not, in, not in.
# 2. not - логическое отрицание.
# 3. and - логическое И.
# 4. or - логическое ИЛИ.


# 4.2. Инструкция ветвления
# Инструкция ветвления при выполнении одного заданного условия исполняет один блок кода, при выполнении другого условия
# - другой, при выполнении третьего - третий, а при невыполнении всех условий - четвертый. Оно записывается в следующем
# формате:
# if <Условие 1>:
#   <Блок, исполняемый, если выполняется условие 1>
# [elif <Условие 2>:
#   <Блок, исполняемый, если выполняется условие 2>
# elif <Условие 3>:
#   <Блок, исполняемый, если выполняется условие 3>
# elif <Условие n>:
#   <Блок, исполняемый, если выполняется условие n>
# ]
# [else:
#   <Блок, исполняемый, если ни одно условие не выполняется>
# ]
# Условий и соответствующих им блоков может быть произвольное количество.
# Выражения, входящие в блок, должны выделяться отступом слева, содержащим одинаковое количество пробелов (обычно
# четыре). Концом блока является инструкция, перед которой расположено меньшее количество пробелов.
# Напишем программу, которая проверяет, является ли введенное пользователем число четным, и выводит соответствующее
# сообщение (test_00014.py).
# Если блок состоит из одной инструкции, эту инструкцию можно разместить на одной строке с языковой конструкцией if,
# elif или else:
# х = int(input('Введите число: ') )
# if х % 2 == О: print(x, ' - четное число')
# else: print(x, ' - нечетное число')
# В таком случае концом блока является конец строки. Это означает, что инструкции, входящие в блок, можно разместить на
# одной строке, разделяя их точкой с запятой. Пример:
# х = int(input('Введите число: '))
# if х % 2 == О: print(x, end=' '); print('- четное число')
# else: print(x, end=' '); print('- нечетное число')
# Совет
# Код, подобный приведенному в этом примере, плохо читается. Поэтому всегда размещайте все инструкции на отдельных
# строках.
# Как говорилось ранее, выражение ветвления может содержать произвольное количество условий и соответствующих им блоков.
# Рассмотрим это на примере (test_00015.py).
# Обратите внимание, что условие в последней конструкции elif не содержит операторов сравнения:
# elif not os:
# Такая запись эквивалентна следующей:
# elif os == '':
# Пустая строка всегда преобразуется в False, и, чтобы условие в этом случае считалось выполненным, нам следует
# инвертировать полученный результат оператором not.
# Одну инструкцию ветвления можно вложить в другую. В этом случае отступ у блоков вложенной инструкции должен быть в два
# раза больше (test_00016.py).
# Инструкция ветвления может быть записана в альтернативном формате:
# <Если истина> if <Условие> else <Если ложь>
# Если заданное условие выполняется, инструкция возвращает значение <Если истина>, в противном случае - значение
# <Если ложь>. Возвращенное значение можно вывести в консоль, присвоить какой-либо переменной или использовать в
# последующих вычислениях. Пример:
print('Дa' if 10 % 2 == 0 else 'Нет')
s = 'Дa' if 10 % 2 == 0 else 'Нет'
print(s)
s = 'Дa' if 11 % 2 == 0 else 'Нет'
print(s)


# 4.3. Инструкция выбора
# Инструкция выбора, если проверяемое значение совпадает с образцом 1, исполняет блок 1, если совпадает с образцом 2
# - блок 2 и т. д. Если же проверяемое значение не совпадает ни с одним из указанных образцов, будет выполнен <Блок _>
# (если он присутствует, если же этот блок отсутствует, ничего не произойдет). Поддержка этой инструкции появилась
# в Python 3.1О.
# Формат записи инструкции выбора:
# match <Проверяемое значение>:
#   case <Образец 1>:
#       <Блок 1>
#   case <Образец 2>:
#       <Блок 2>
#   ...
#   case <Образец n>:
#       <Блок n>
#   [case _:
#       <Блок_>]
# Проверяемое значение и образцы могут принадлежать к любым типам. Языковых конструкций case, содержащих образцы и
# соответствующие им блоки, может быть произвольное количество.
# В качестве примера перепишем программу, чей код приведен в test_00015.py, с применением инструкции выбора
# (test_00017.py).
# Сразу уясним, что исполняется только один блок - соответствующий первому совпавшему образцу. После этого обработка
# инструкции прекращается, и начинают исполняться инструкции, следующие за ней. Так что при выполнении кода:
# os = '1'
# match os:
#   case '1':
#       print('Вы выбрали: Windows 11')
#   case '1':
#       print('Отличный выбор!')
#   case '2':
#       print('Вы выбрали: Windows 10')
# в консоли появится лишь строка:
# Вы выбрали: Windows 11
# Рассмотрим особенности обработки инструкцией выбора проверяемых значений разных типов:
# - числа, строки и логические величины - образцы указываются в виде соответственно чисел, строк и логических величин;
# - последовательности - образец указывается в виде кортежа (также можно указать список). При этом образец может быть
# задан:
#   - с явным перечислением всех значений - проверяемая последовательность должна содержать только заданные в образце
# значения, находящиеся в заданных позициях:
#   match seq:
#       case (1, 2, 3):
#           print('Последовательность 1: 1, 2, 3')
#       case (1, 2, 3, 4):
#           print('Последовательность 2: 1, 2, 3, 4')
#       case (3, 2, 1):
#           print('Последовательность 3: 3, 2, 1')
#       case _:
#           print('Другая последовательность')
# Результаты:
# seq = (1, 2, 3)        => Последовательность 1: 1, 2, 3
# seq = (1, 2, 3, 4)     => Последовательность 2: 1, 2, 3, 4
# seq = (3, 2, 1)        => Последовательность 3: 3, 2, 1
# seq = (1, 2, 3, 4, 5)  => Другая последовательность
# seq = (3, 2)           => Другая последовательность
#   - с явным указанием части значений (вместо остальных явно заданных значений ставятся какие-либо переменные) -
# проверяемая последовательность должна содержать, по крайней мере, заданные значения, находящиеся в заданных позициях.
# Остальные значения будут присвоены указанным в образце переменным, которые станут доступны в блоке. Пример:
#   match seq:
#       case (1, 2, 3):
#           print('Последовательность 1: 1, 2, 3')
#       case (1, 2, 3, m):
#           print('Последовательность 2: 1, 2, 3, ' + str(m))
#       case (n, 2, 1):
#           print('Последовательность 3: ' + str(n) + ', 2, 1')
#       case _:
#           print('Другая последовательность')
# Результаты:
# seq = (1, 2, 3)        => Последовательность 1: 1, 2, 3
# seq = (1, 2, 3, 4)     => Последовательность 2: 1, 2, 3, 4
# seq = (1, 2, 3, 56)    => Последовательность 2: 1, 2, 56
# seq = (3, 2, 1)        => Последовательность 3: 3, 2, 1
# seq = (800, 2, 1)      => Последовательность 3: 800, 2, 1
# seq = (1, 2, 3, 4, 5)  => Другая последовательность
# Также можно указать в образце переменную, предварив ее символом звездочки (* ). В эту переменную будет занесен список
# со всеми оставшимися элементами проверяемой последовательности. Пример:
#   match seq:
#       case (1, 2, 3, *a):
#           print('Последовательность 1: 1, 2, 3, ' + str(a))
#       case (*b, 2, 1):
#           print('Последовательность 2: ' + str(b) + ', 2, 1')
#       case _:
#           print('Другая последовательность')
# Результаты:
# seq = (1, 2, 3, 4)     => Последовательность 1: 1, 2, 3, [4]
# seq = (1, 2, 3, 4, 5)  => Последовательность 1: 1, 2, 3, [4, 5]
# seq = (1, 2, 3)        => Последовательность 1: 1, 2, 3, []
# seq = (5, 4, 3, 2, 1)  => Последовательность 2: [5, 4, 3], 2, 1
# seq = (3, 2)           => Другая последовательность
# В последнем случае вместо переменной можно указать символ подчеркивания - тогда оставшиеся значения проверяемой
# последовательности не будут сохранены ни в какой переменной:
# match seq:
#   case (1, 2, 3, * ):
#       print('Последовательность 1: 1, 2, 3 и, возможно, ' + 'какие-либо другие элементы')
# - отображения - образец указывается в виде словаря. Образец можно задать:
#   - с явным указанием всех значений - проверяемое отображение должно содержать, по крайней мере, заданные в образце
# значения под указанными ключами:
# match mpn:
#   case {'а': 1, 'b': 2}:
#       print('Отображение 1: а - 1, b - 2')
#   case {'а': 1, 'с': 3 }:
#       print('Отображение 2: а - 1, с - 3')
#   case _:
#       print('Другое отображение')
# Результаты:
# mpn = {'а': 1, 'b': 2}          => Отображение 1: а - 1, b - 2
# mpn = {'а': 1, 'b': 2, 'c': 3}  => Отображение 1: а - 1, b - 2
# mpn = {'а': 1, 'c': 3}          => Отображение 1: а - 1, c - 3
# mpn = {'e': 11, 'f': -32}       => Другое отображение
#   - с явным указанием части значений (у остальных после ключей ставятся переменные) - проверяемое отображение должно
# содержать, по крайней мере, заданные значения и какие-либо значения, указанные под ключами, в которых поставлены
# переменные. Значения из ключей с переменными будут присвоены этим переменным, которые станут доступными в блоке.
# Пример:
# match mpn:
#   case {'а': 1, 'b': 2, 'd': d}:
#       print('Отображение 1: а - 1, b - 2, d - ' + str(d))
#   case {'а': 1, 'b': 2}
#       print('Отображение 2: а - 1, b - 2')
# Результаты:
# mpn = {'а': 1, 'b': 2, 'd': 3}   => Отображение 1: а - 1, b - 2, d - 3
# mpn = {'а': 1, 'b': 2, 'd': 25}  => Отображение 1: а - 1, b - 2, d - 25
# mpn = {'а': 1, 'b': 2}           => Отображение 2: а - 1, b - 3
# mpn = {'а': 1, 'b': 2, 'c': 3}   => Отображение 2: а - 1, b - 2
# После перечисления значений в образце можно поставить переменную, предварив ее двойным символом звездочки(**). В эту
# переменную будет занесен словарь со всеми оставшимися элементами проверяемого отображения. Пример:
# match mpn:
#   case {'а': 1, 'b': 2, **d}:
#       print('Отображение 1: а - 1, b - 2, d - ' + str(d))
#   case {'а': 1, 'd': 4}
#       print('Отображение 2: а - 1, d - 4')
# Результаты:
# mpn = {'а': 1, 'b': 2, 'c': 3}          => Отображение 1: а - 1, b - 2, {'c': 3}
# mpn = {'а': 1, 'b': 2, 'c': 3, 'd': 4}  => Отображение 1: а - 1, b - 2, {'c': 3, 'd': 4}
# mpn = {'а': 1, 'b': 2}                  => Отображение 1: а - 1, b - 2, {}
# mpn = {'а': 1, 'd': 4}                  => Отображение 2: а - 1, d - 4
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


# 76

