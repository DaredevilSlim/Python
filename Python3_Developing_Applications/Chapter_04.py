#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Глава 4
# Инструкции ветвления, выбора и циклы
# Инструкция ветвления позволяет при выполнении какого-либо условия исполнить один блок кода, а при невыполнении условия
# - другой. Инструкция выбора, если указанная переменная хранит одно значение, исполняет первый блок кода, если
# переменная хранит второе значение - второй блок кода, если третье - третий блок кода и т. д. Два вида циклов выполняют
# указанный блок кода либо столько раз, сколько элементов содержится в заданной последовательности, при этом перебирая
# ее элементы, либо пока выполняется заданное условие.
# В качестве условий в подобного рода инструкциях применяются выражения, в качестве результата выдающие логическую
# величину True («истина», условие выполняется, или истинно) или False («ложь», условие не выполняется, или ложно).
# Также в качестве условия можно использовать выражение, выдающее результат любого другого типа, который в этом случае
# будет автоматически приведен к логическому типу:
# в значение True будут преобразованы:
# - любое число, не равное нулю:
print(bool(1), bool(20), bool(-20))
print(bool(1.0), bool(0.1), bool(-20.0))
# - не пустой объект:
print(bool('O'), bool([0, None]), bool((None,)), bool({'x': 5}))
# в значение False будут преобразованы:
# - число, равное нулю:
print(bool(0), bool(0.0))
# - пустой объект:
print(bool(''), bool([]), bool(()))
# (False, False, False)
# - значение None:
print(bool(None))


# 4.1. Операторы сравнения
print('4.1. Операторы сравнения')
# Операторы сравнения применяются в условиях, чтобы сравнить значения указанных операндов:
# == - равно - значения обоих операндов должны быть равны друг другу:
print(1 == 1, 1 == 5)

# != - не равно - значения обоих операндов должны быть не равны друг другу:
print(1 != 5, 1 != 1)

# < - меньше - первый операнд должен быть меньше второго:
print(1 < 5, 1 < 0)

# > - больше - первый операнд должен быть больше второго:
print(1 > 0, 1 > 5)

# <= - меньше или равно - первый операнд должен быть меньше или равен второму:
print(1 <= 5, 1 <= 0, 1 <= 1)

# >= - больше или равно - первый операнд должен быть больше или равен второму:
print(1 >= 0, 1 >= 5, 1 >= 1)

# in - вхождение - первый операнд должен входить в последовательность из второго операнда:
print('Строка' in 'Строка для поиска')  # Строки
print(2 in [1, 2, 3], 4 in [1, 2, 3])   # Списки
print(2 in (1, 2, 3), 4 in (1, 2, 3))   # Кортежи
# Оператор in также можно использовать для проверки существования ключа в словаре:
print('x' in {'x': 1, 'y': 2}, 'z' in {'x': 1, 'y': 2})

# not in - невхождение - первый операнд не должен входить в последовательность из второго операнда:
print('Строка' not in 'Строка для поиска')     # Строки
print(2 not in [1, 2, 3], 4 not in [1, 2, 3])  # Списки
print(2 not in (1, 2, 3), 4 not in (1, 2, 3))  # Кортежи

# is - переменные, заданные операндами, должны ссылаться на один и тот же объект:
x = y = [1, 2]
print(x is y)
x = [1, 2]
y = [1, 2]
print(x is y)

# is not - переменные, заданные операндами, должны ссылаться на разные объекты:
x = y = [1, 2]
print(x is not y)
x = [1, 2]
y = [1, 2]
print(x is not y)
# Значение логического выражения можно инвертировать (изменить на противоположное) с помощью оператора логического
# НЕ - not:
x = 1
y = 1
print(x == y)
print(not (x == y), not x == y)
# Круглые скобки здесь можно не указывать, поскольку оператор not имеет более низкий приоритет, чем операторы сравнения.
# В логическом выражении можно указывать сразу несколько условий:
x = 10
print(1 < x < 20, 11 < x < 20)

# Несколько логических выражений можно объединить в одно большое с помощью следующих операторов:
# and - логическое И - если оба операнда равны True, возвращается True, в противном случае - False:
print(1 < 5 and 2 < 5)  # True and True == True
print(1 < 5 and 2 > 5)  # True and False == False
print(1 > 5 and 2 < 5)  # False and True == False
# Если значение первого операнда не относится к логическому типу, интерпретатор преобразует его в логический тип. Если
# после преобразования получается False, то возвращается значение первого операнда, в противном случае - значение
# второго операнда.
print(10 and 20, 0 and 20, 10 and 0)

# or - логическое ИЛИ - если хотя бы один операнд равен True, возвращается True, в противном случае - False:
print(1 < 5 or 2 < 5)  # True or True == True
print(1 < 5 or 2 > 5)  # True or False == True
print(1 > 5 or 2 < 5)  # False or True == True
print(1 > 5 or 2 > 5)  # False or False == False
# Если значение первого операнда не относится к логическому типу, интерпретатор преобразует его в логический тип. Если
# после преобразования получается False, то возвращается значение второго операнда, в противном случае - значение
# первого операнда.
print(10 or 20, 0 or 20, 10 or 0)
print(0 or '' or None or [] or 's')

# Перечислим операторы сравнения в порядке убывания приоритета:
# 1. <, >, <=, >=, =, ! =, <>, is, is not, in, not in.
# 2. not - логическое отрицание.
# 3. and - логическое И.
# 4. or - логическое ИЛИ.


# 4.2. Инструкция ветвления
print('4.2. Инструкция ветвления')
# Инструкция ветвления при выполнении одного заданного условия исполняет один блок кода, при выполнении другого условия
# - другой, при выполнении третьего - третий, а при невыполнении всех условий - четвертый. Оно записывается в следующем
# формате:
# if <Условие 1>:
#   <Блок, исполняемый, если выполняется условие 1>
# [elif <Условие 2>:
#   <Блок, исполняемый, если выполняется условие 2>
# elif <Условие 3>:
#   <Блок, исполняемый, если выполняется условие 3>
# elif <Условие n>:
#   <Блок, исполняемый, если выполняется условие n>
# ]
# [else:
#   <Блок, исполняемый, если ни одно условие не выполняется>]
# Условий и соответствующих им блоков может быть произвольное количество.
# Выражения, входящие в блок, должны выделяться отступом слева, содержащим одинаковое количество пробелов (обычно
# четыре). Концом блока является инструкция, перед которой расположено меньшее количество пробелов.
# Напишем программу, которая проверяет, является ли введенное пользователем число четным, и выводит соответствующее
# сообщение (test_00014.py).
# Если блок состоит из одной инструкции, эту инструкцию можно разместить на одной строке с языковой конструкцией if,
# elif или else:
# х = int(input('Введите число: ') )
# if х % 2 == О: print(x, ' - четное число')
# else: print(x, ' - нечетное число')
# В таком случае концом блока является конец строки. Это означает, что инструкции, входящие в блок, можно разместить на
# одной строке, разделяя их точкой с запятой. Пример:
# х = int(input('Введите число: '))
# if х % 2 == О: print(x, end=' '); print('- четное число')
# else: print(x, end=' '); print('- нечетное число')
# Совет
# Код, подобный приведенному в этом примере, плохо читается. Поэтому всегда размещайте все инструкции на отдельных
# строках.
# Как говорилось ранее, выражение ветвления может содержать произвольное количество условий и соответствующих им блоков.
# Рассмотрим это на примере (test_00015.py).
# Обратите внимание, что условие в последней конструкции elif не содержит операторов сравнения:
# elif not os:
# Такая запись эквивалентна следующей:
# elif os == '':
# Пустая строка всегда преобразуется в False, и, чтобы условие в этом случае считалось выполненным, нам следует
# инвертировать полученный результат оператором not.
# Одну инструкцию ветвления можно вложить в другую. В этом случае отступ у блоков вложенной инструкции должен быть в два
# раза больше (test_00016.py).
# Инструкция ветвления может быть записана в альтернативном формате:
# <Если истина> if <Условие> else <Если ложь>
# Если заданное условие выполняется, инструкция возвращает значение <Если истина>, в противном случае - значение
# <Если ложь>. Возвращенное значение можно вывести в консоль, присвоить какой-либо переменной или использовать в
# последующих вычислениях. Пример:
print('Дa' if 10 % 2 == 0 else 'Нет')
s = 'Дa' if 10 % 2 == 0 else 'Нет'
print(s)
s = 'Дa' if 11 % 2 == 0 else 'Нет'
print(s)


# 4.3. Инструкция выбора
print('4.3. Инструкция выбора')
# Инструкция выбора, если проверяемое значение совпадает с образцом 1, исполняет блок 1, если совпадает с образцом 2
# - блок 2 и т. д. Если же проверяемое значение не совпадает ни с одним из указанных образцов, будет выполнен <Блок _>
# (если он присутствует, если же этот блок отсутствует, ничего не произойдет). Поддержка этой инструкции появилась
# в Python 3.1О.
# Формат записи инструкции выбора:
# match <Проверяемое значение>:
#   case <Образец 1>:
#       <Блок 1>
#   case <Образец 2>:
#       <Блок 2>
#   ...
#   case <Образец n>:
#       <Блок n>
#   [case _:
#       <Блок_>]
# Проверяемое значение и образцы могут принадлежать к любым типам. Языковых конструкций case, содержащих образцы и
# соответствующие им блоки, может быть произвольное количество.
# В качестве примера перепишем программу, чей код приведен в test_00015.py, с применением инструкции выбора
# (test_00017.py).
# Сразу уясним, что исполняется только один блок - соответствующий первому совпавшему образцу. После этого обработка
# инструкции прекращается, и начинают исполняться инструкции, следующие за ней. Так что при выполнении кода:
# os = '1'
# match os:
#   case '1':
#       print('Вы выбрали: Windows 11')
#   case '1':
#       print('Отличный выбор!')
#   case '2':
#       print('Вы выбрали: Windows 10')
# в консоли появится лишь строка:
# Вы выбрали: Windows 11
# Рассмотрим особенности обработки инструкцией выбора проверяемых значений разных типов:
# - числа, строки и логические величины - образцы указываются в виде соответственно чисел, строк и логических величин;

# - последовательности - образец указывается в виде кортежа (также можно указать список). При этом образец может быть
# задан:
#   - с явным перечислением всех значений - проверяемая последовательность должна содержать только заданные в образце
# значения, находящиеся в заданных позициях:
#   match seq:
#       case (1, 2, 3):
#           print('Последовательность 1: 1, 2, 3')
#       case (1, 2, 3, 4):
#           print('Последовательность 2: 1, 2, 3, 4')
#       case (3, 2, 1):
#           print('Последовательность 3: 3, 2, 1')
#       case _:
#           print('Другая последовательность')
# Результаты:
# seq = (1, 2, 3)        => Последовательность 1: 1, 2, 3
# seq = (1, 2, 3, 4)     => Последовательность 2: 1, 2, 3, 4
# seq = (3, 2, 1)        => Последовательность 3: 3, 2, 1
# seq = (1, 2, 3, 4, 5)  => Другая последовательность
# seq = (3, 2)           => Другая последовательность
#   - с явным указанием части значений (вместо остальных явно заданных значений ставятся какие-либо переменные) -
# проверяемая последовательность должна содержать, по крайней мере, заданные значения, находящиеся в заданных позициях.
# Остальные значения будут присвоены указанным в образце переменным, которые станут доступны в блоке. Пример:
#   match seq:
#       case (1, 2, 3):
#           print('Последовательность 1: 1, 2, 3')
#       case (1, 2, 3, m):
#           print('Последовательность 2: 1, 2, 3, ' + str(m))
#       case (n, 2, 1):
#           print('Последовательность 3: ' + str(n) + ', 2, 1')
#       case _:
#           print('Другая последовательность')
# Результаты:
# seq = (1, 2, 3)        => Последовательность 1: 1, 2, 3
# seq = (1, 2, 3, 4)     => Последовательность 2: 1, 2, 3, 4
# seq = (1, 2, 3, 56)    => Последовательность 2: 1, 2, 56
# seq = (3, 2, 1)        => Последовательность 3: 3, 2, 1
# seq = (800, 2, 1)      => Последовательность 3: 800, 2, 1
# seq = (1, 2, 3, 4, 5)  => Другая последовательность
# Также можно указать в образце переменную, предварив ее символом звездочки (* ). В эту переменную будет занесен список
# со всеми оставшимися элементами проверяемой последовательности. Пример:
#   match seq:
#       case (1, 2, 3, *a):
#           print('Последовательность 1: 1, 2, 3, ' + str(a))
#       case (*b, 2, 1):
#           print('Последовательность 2: ' + str(b) + ', 2, 1')
#       case _:
#           print('Другая последовательность')
# Результаты:
# seq = (1, 2, 3, 4)     => Последовательность 1: 1, 2, 3, [4]
# seq = (1, 2, 3, 4, 5)  => Последовательность 1: 1, 2, 3, [4, 5]
# seq = (1, 2, 3)        => Последовательность 1: 1, 2, 3, []
# seq = (5, 4, 3, 2, 1)  => Последовательность 2: [5, 4, 3], 2, 1
# seq = (3, 2)           => Другая последовательность
# В последнем случае вместо переменной можно указать символ подчеркивания - тогда оставшиеся значения проверяемой
# последовательности не будут сохранены ни в какой переменной:
# match seq:
#   case (1, 2, 3, * ):
#       print('Последовательность 1: 1, 2, 3 и, возможно, ' + 'какие-либо другие элементы')

# - отображения - образец указывается в виде словаря. Образец можно задать:
#   - с явным указанием всех значений - проверяемое отображение должно содержать, по крайней мере, заданные в образце
# значения под указанными ключами:
# match mpn:
#   case {'а': 1, 'b': 2}:
#       print('Отображение 1: а - 1, b - 2')
#   case {'а': 1, 'с': 3 }:
#       print('Отображение 2: а - 1, с - 3')
#   case _:
#       print('Другое отображение')
# Результаты:
# mpn = {'а': 1, 'b': 2}          => Отображение 1: а - 1, b - 2
# mpn = {'а': 1, 'b': 2, 'c': 3}  => Отображение 1: а - 1, b - 2
# mpn = {'а': 1, 'c': 3}          => Отображение 1: а - 1, c - 3
# mpn = {'e': 11, 'f': -32}       => Другое отображение
#   - с явным указанием части значений (у остальных после ключей ставятся переменные) - проверяемое отображение должно
# содержать, по крайней мере, заданные значения и какие-либо значения, указанные под ключами, в которых поставлены
# переменные. Значения из ключей с переменными будут присвоены этим переменным, которые станут доступными в блоке.
# Пример:
# match mpn:
#   case {'а': 1, 'b': 2, 'd': d}:
#       print('Отображение 1: а - 1, b - 2, d - ' + str(d))
#   case {'а': 1, 'b': 2}
#       print('Отображение 2: а - 1, b - 2')
# Результаты:
# mpn = {'а': 1, 'b': 2, 'd': 3}   => Отображение 1: а - 1, b - 2, d - 3
# mpn = {'а': 1, 'b': 2, 'd': 25}  => Отображение 1: а - 1, b - 2, d - 25
# mpn = {'а': 1, 'b': 2}           => Отображение 2: а - 1, b - 3
# mpn = {'а': 1, 'b': 2, 'c': 3}   => Отображение 2: а - 1, b - 2
# После перечисления значений в образце можно поставить переменную, предварив ее двойным символом звездочки(**). В эту
# переменную будет занесен словарь со всеми оставшимися элементами проверяемого отображения. Пример:
# match mpn:
#   case {'а': 1, 'b': 2, **d}:
#       print('Отображение 1: а - 1, b - 2, d - ' + str(d))
#   case {'а': 1, 'd': 4}
#       print('Отображение 2: а - 1, d - 4')
# Результаты:
# mpn = {'а': 1, 'b': 2, 'c': 3}          => Отображение 1: а - 1, b - 2, {'c': 3}
# mpn = {'а': 1, 'b': 2, 'c': 3, 'd': 4}  => Отображение 1: а - 1, b - 2, {'c': 3, 'd': 4}
# mpn = {'а': 1, 'b': 2}                  => Отображение 1: а - 1, b - 2, {}
# mpn = {'а': 1, 'd': 4}                  => Отображение 2: а - 1, d - 4

# - объекты классов - можно проверять:
#   - принадлежность проверяемого объекта указанному классу - образец записывается в формате <Имя нужного класса>():
# import datetime
# match val:
#   case str():
#       print('Строка')
#   case int():
#       print('Целое число')
#   case datetime.datetime():
#       print('Временная отметка')
# Результаты:
# val = 'Python'                         => Строка
# val = 589                              => Целое число
# val = datetime.datetime(2020, 12, 28)  => Временная отметка
#   - дополнительно - наличие в атрибутах проверяемого объекта указанных значений - образец записывается в формате:
# <Имя нужного класса>(<Атрибут l>=<Значение атрибута 1>,
#                      <Атрибут 2>=<Значение атрибута 2>,
#                      <Атрибут n>=<Значение атрибута n>)
# Пример:
# import datetime
# match val:
#   case str():
#       print('Строка')
#   case datetime.datetime(year=2020, month=12, day=28):
#       print('28 декабря 2020 года')
#   case datetime.datetime(year=2021, month=1, day=1):
#       print('1 января 2021 года')
#   case datetime.datetime():
#       print('Другие дата и время')
# . Результаты:
# val = 'Python'                         => Строка
# val = datetime.datetime(2020, 12, 28)  => 28 декабря 2020 года
# val = datetime.datetime(2021, 1, 1)    => 1 января 2021 года
# val = datetime.datetime(2021, 1, 2)    => Другие дата и время
# В конструкции <Атрибут> = <Значение атрибута> вместо значения атрибута можно задать переменную. Эта переменная получит
# значение, хранящееся в соответствующем атрибуте проверяемого объекта класса, и будет доступна в блоке. Пример:
# import datetime
# match val:
#   case datetime.datetime(year=2021, month=1, day=1):
#       print('1 января 2021 года')
#   case datetime.datetime(year=2021, month=2, day=d):
#       print(str(d) + ' февраля 2021 года')
# Результаты:
# val = datetime.datetime(2021, 1, 1)   => 1 января 2021 года
# val = datetime.datetime(2021, 2, 20)  => 20 февраля 2021 года
# В качестве образца можно указать набор значений, разделенных символами вертикальной черты (|). Соответствующий блок
# будет выполнен, если проверяемое значение совпадает с любым из перечисленных образцов. Пример:
# match n:
#     case 'Python' | 'JavaScript' | 'РНР' | 'RuЬy':
#         print('Язык программирования')
#     case 'Django' | 'Express' | 'Laravel' | 'Rails':
#         print('Веб-фреймворк')
# Результаты:
# n = 'Python'   => Язык программирования
# n = 'Laravel'  => Веб-фреймворк
# n = 'Express'  => Веб-фреймворк
# n = 'RuЬy'     => Язык программирования
# В языковой конструкции case можно дополнительно указать конструкцию if следующего формата:
# case <Образец> if <Условие>
# В этом случае проверяемое значение будет считаться совпавшим с указанным образцом только в том случае, если заданное
# условие в качестве результата выдаст True. Пример (функция len() возвращает количество значений в последовательности):
# match seq:
#   case (1, 2, 3, *а) if (len(seq) > 4):
#       print('Более 4 значений: 1, 2, 3, ' + str(a))
#   case (1, 2, 3, *а):
#       print('He менее 4 значений: 1, 2, 3, ' + str(a))
# Результаты:
# seq = (1, 2, 3, 4, 5)  => Более 4 значений: 1, 2, 3, [4, 5]
# seq = (1, 2, 3, 4)     => Не менее 4 значений: 1, 2, 3, [4]
# Инструкция выбора несколько нагляднее инструкции ветвления с множественными языковыми конструкциями elif и применяется
# в тех же случаях, что и последняя.


# 4.4. Цикл перебора последовательности
print('4.4. Цикл перебора последовательности')
# Цикл перебора последовательности выполняет указанный блок, называемый телом цикла, столько раз, сколько значений
# присутствует в заданной последовательности. Перед каждым выполнением блока (итерацией) он присваивает очередное
# значение из последовательности указанной переменной, которая становится доступной в теле цикла. Формат записи цикла
# перебора последовательности:
# for <Переменная> in <Последовательность>:
#   <Тело цикла>
# else:
#   <Блок else>
# <Блок else> выполняется, если указанная последовательность пуста (не содержит ни одного элемента), и исполнение цикла
# не было прервано оператором break.
# Цикл такого типа может обрабатывать любые последовательности: списки, кортежи, диапазоны, строки и др.
# Пример перебора символов в строке приведен в test_00018.py.
# Перебор элементов списка и кортежа с построчным выводом test_00019.py.
# Перебор чисел из диапазона между 5 и 15:
for n in range(5, 15):
    print(n, end=' ')
# Перебор списка кортежей:
print()
arr = [(1, 2), (3, 4)]  # Список кортежей
for a, b in arr:
    print(a, b)


# 4.5. Цикл с условием
print('4.5. Цикл с условием')
# Выполнение тела цикла с условием while продолжается до тех пор, пока выполняется заданное условие. Цикл записывается в
# следующем формате:
# while <Условие>:
#   <Тело цикла>
# [else:
#   <Блок else>
# ]
# <Блок else> будет выполнен, если указанное условие изначально не выполняется и исполнение цикла не было прервано
# оператором break.
# В теле цикла с условием следует произвести какие-либо действия, которые в определенный момент сделают так, чтобы
# указанное условие, перестало выполняться и цикл завершился.
# Например, условие может проверять, не превысило ли значение какой-либо переменной указанную величину,- в таком случае
# в блоке следует увеличивать значение этой переменной на 1.
# В качестве примера выведем все числа от 1 до 100, используя цикл while test_00020.py.
# Если в теле цикла с условием не предпринимается никаких действий, способных прервать цикл, он будет выполняться
# бесконечно (бесконечный цикл).
# Прервать выполнение бесконечного цикла, выводящего данные, можно нажатием комбинации клавиш <Ctrl>+<C>. В результате
# генерируется исключение KeyboardInterrupt, и выполнение программы останавливается.
# Выведем все числа от 100 до 1 test_00021.py.
# Здесь условие не содержит операторов сравнения. На каждой итерации цикла мы вычитаем единицу из значения переменной
# i. Как только значение станет равным О, цикл завершится, поскольку число О при преобразовании в логический тип даст
# значение False.
# С помощью цикла с условием можно перебирать элементы последовательностей. Однако такой цикл работает медленнее цикла
# перебора последовательности. В качестве примера умножим каждый элемент списка на 2 test_00022.py.


# 4.6. Оператор continue: переход на следующую итерацию цикла
print('4.6. Оператор continue: переход на следующую итерацию цикла')
# Оператор continue позволяет перейти к следующей итерации цикла до завершения выполнения текущей итерации. В качестве
# примера выведем все числа от 1 до 100, кроме чисел от 5 до 10 включительно test_00023.py.


# 4.7. Оператор break: прерывание цикла
print('4.7. Оператор break: прерывание цикла')
# Оператор break прерывает выполнение цикла досрочно, после чего начнут исполняться инструкции, следующие за прерванным
# циклом. Для примера выведем все числа от 1 до 100 еще одним способом test_00024.py.
# Поскольку в условии указано значение True, цикл станет выполняться бесконечно. Однако оператор break прерывает цикл,
# как только он будет выполнен 100 раз.
# Цикл с условием совместно с оператором break удобно использовать для получения не определенного заранее количества
# данных от пользователя. В качестве примера просуммируем произвольное количество чисел test_00025.py.
# Процесс ввода трех чисел и получения суммы выглядит так (значения, введенные пользователем, здесь выделены полужирным
# шрифтом):
# Введите слово 'stop' для получения результата
# Введите число: 10
# Введите число: 20
# Введите число: 30
# Введите число: stop
# Сумма чисел равна: 60


# 4.8. Оператор присваивания в составе инструкции
print('4.8. Оператор присваивания в составе инструкции')
# Оператор присваивания в составе инструкции:= полностью аналогичен оператору присваивания =, за тем искточением, что он
# выдает результат - само присвоенное значение.
# Это позволяет использовать его в условиях инструкций ветвления, выбора и циклов. Поддержка такого оператора появилась
# в Python 3.8.
# Использование оператора присваивания в составе инструкции лучше всего показать на примере. Рассмотрим код, получающий
# количество символов в строке из переменной s(с помощью функции len()) и выводящий это количество, если оно не равно О:
s = 'Строка'
l = len(s)
if 1 > 0:
    print('Длина строки: ' + str(l))
# Этот код можно сократить, выполнив вычисление длины строки и присваивание ее переменной n непосредственно в условии
# инструкции ветвления - посредством оператора :=:
s = 'Строка'
if (l := len(s)) > 0:
    print('Длина строки: ' + str(l))
# Выражение, включающее оператор присваивания в составе инструкции, следует взять в круглые скобки, поскольку этот
# оператор имеет крайне низкий приоритет - даже ниже, чем у операторов сравнения.
# Использовав в условии цикла оператор присваивания в составе инструкции, мы можем несколько сократить код программы из
# test_00025.py и записать в test_00026.py.
