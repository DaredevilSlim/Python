#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# ГЛАВА 6
# Строки и двоичные данные
# Строка - это неизменяемая последовательность произвольных символов в кодировке Unicode. Длина строки ограничена лишь
# объемом оперативной памяти компьютера.
# Двоичные данные - это последовательность байтов (чисел от О до 255), которая может быть как неизменяемой, так и
# изменяемой. Длина такой последовательности также ограничена лишь объемом оперативной памяти. В виде двоичных данных
# может быть сохранена информация любого рода: строка, графическое изображение, архив и др.


# 6.1. Создание строк
print('6.1. Создание строк')
# Создать строку можно следующими способами:
# - записав составляющие строку символы между одинарными или двойными кавычками:
print('строка', 'строка')
# Строки, созданные с применением одинарных и двойных кавычек, ничем не отличаются друг от друга.
# В строках, созданных одинарными кавычками, можно размещать двойные кавычки, а в строках, созданных двойными кавычками,
# - одинарные кавычки:
print('Группа "Кино"', "О'Брайен")
# Попытка вставить одинарную кавычку в строку, созданную одинарными кавычками, или двойную кавычку в строку в двойных
# кавычках приведет к ошибке:
# print('Группа 'КИно'')
# SyntaxError: invalid syntax
# В строках можно указать специальные символы - символы, обрабатываемые особым образом. Обозначение специального символа
# начинается со знака обратного слеша (\).
# Например, специальный символ \n обозначает разрыв строки, специальный символ \' - одинарную кавычку, символ \' -
# двойную кавычку, а \\ - обратный слеш. Более подробно специальные символы будут описаны в разд. 6.1.1. Примеры:
print('Строка1\\nСтрока2')
print('Группа \'КИно\'', 'О\'Брайен')
# Специальный символ \\ обычно применяется для вставки символа обратного слеша в конец строки:
print('string\\')
# Если же использовать единичный символ обратного слеша, интерпретатор посчитает его и следующую за ним кавычку
# специальным символом и выведет сообщение о синтаксической ошибке:
# print('string\')
# SyntaxError: unterminated string literal (detected at line 36)
# Нельзя разбивать строковый объект, созданный с помощью кавычек, на несколько строк - это вызовет синтаксическую
# ошибку:
# print('string)
# SyntaxError: unterminated string literal (detected at line 40)
# Чтобы расположить строковое значение на нескольких строках, следует либо перед символом перевода строки указать
# символ \, либо поместить отдельные части строки внутри круглых скобок, либо выполнить конкатенацию строк также внутри
# круглых скобок:
print('string1\
      string2')  # После \ не должно быть никаких символов
print('string1'
      'string2')  # Неявная конкатенация строк
print('string1' +
      'string2')  # Явная конкатенация строк
#
#
#
# - указав строку между утроенными одинарными или двойными кавычками. Такие строковые объекты могут размещаться на
# нескольких строках, содержать одинарные и двойные кавычки. Примеры:
print('''Строка1
      Строка2''')
print('''Строка1
      Строка2''')
# - с помощью функции str([ <Значение>[, <Кодировка>[, <Обработка ошибок>]]]). Если указан только первый параметр,
# функция возвращает строковое представление указанного значения. Если параметры не указаны вообще, возвращается пустая
# строка. Примеры:
print(str(), str([1, 2]), str((3, 4)), str({'x': 1}))
# При попытке преобразовать двоичные данные типа byte или bytearray в строку будет выдано строковое представление
# двоичных данных:
print(str(b'\xf1\xf2\xf0\xee\xea\xe0'))
# Чтобы получить строку, следует указать кодировку:
print(str(b'\xf1\xf2\xf0\xee\xea\xe0', 'cp1251'))
# В третьем параметре могут быть указаны значения 'strict' (при ошибке возбуждается исключение UnicodeDecodeError - 
# значение по умолчанию), 'replace' (неизвестный символ заменяется символом с кодом \uFFFD) или 'ignore' (неизвестные
# символы игнорируются):
obj1 = bytes('строка1', 'utf-8')
print(obj1)
obj2 = bytearray('строка2', ':utf-8')
print(obj2)
print(str(obj1, 'utf-8'), str(obj2, 'utf-8'))
# str(obj1, 'ascii', 'strict')
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 77, in <module>
#     str(obj1, 'ascii', 'strict')
# UnicodeDecodeError: 'ascii' codec can't decode byte 0xd1 in position 0: ordinal not in range(128)
print(str(obj1, 'ascii', 'ignore'))


# Если строка не присваивается переменной, то она считается строкой документирования.
# Такая строка сохраняется в атрибуте _doc_ того объекта, в котором расположена. В качестве примера создадим функцию со
# строкой документирования, а затем выведем содержимое строки:


def test():
    """Это описание функции"""
    pass


print(test.__doc__)


# 6.1.1. Специальные символы
print('6.1.1. Специальные символы')
# Специальные символы, как говорилось ранее, имеют особое значение и обрабатываются особым образом. Python поддерживает
# следующие специальные символы:
# - \n - перевод строки;
# - \r - возврат каретки;
# - \t - знак табуляции;
# - \v - вертикальная табуляция;
# - \а - звонок;
# - \b - забой;
# - \f - перевод формата;
# - \0 - нулевой символ;
# - \" - двойная кавычка;
# - \' - одинарная кавычка (апостроф);
# - \\ - обратный слеш;
# - \<N> - символ с восьмеричным кодом <N>. Например, \74 соответствует символу <;
# - \x<N> - символ с шестнадцатеричным кодом <N>. Например, \x6a соответствует символу j;
# - \u<nnnn> - символ с 16-битным Unicode-кодом <nnnn>. Например, \u04За соответствует русской букве к;
# - \U<nnnnnnnn> - символ с 32-битным Unicode-кодом <nnnnnnnn>;
# - \N{<name>} - символ с Unicode-именем <name>. Например, \N{Registered Sign} соответствует знаку зарегистрированной
# торговой марки ®·
# Комбинация обратного слеша с любым другим символом выводится как есть:
print('Этот символ \не специальный')
# Тем не менее для вставки обратного слеша лучше использовать специальный символ \\:
print('Этот символ \\не специальный')
# Этот символ \не специальный


# 6.1.2. Необрабатываемые строки
print('6.1.2. Необрабатываемые строки')
# В необрабатываемых строках специальные символы не обрабатываются, а выводятся как есть. Чтобы превратить строку в
# необрабатываемую, достаточно предварить ее модификатором r или R. Примеры:
print('Строка1\nСтрока2')
print(r'Строка1\nСтрока2')
print(R'Строка1\nСтрока2')
print(r"""Строка1\nСтрока2""")
# Необрабатываемые строки удобно использовать в шаблонах регулярных выражений и при записи файловых путей:
print(r'C:\Python310\lib\site-packages')
# В обычных строках все обратные слеши придется заменять на специальные символы \\:
print('C:\\Python310\\lib\\site-packages')
# Если в конце необрабатываемой строки должен располагаться слеш, следует использовать специальный символ \\. Однако
# этот символ будет добавлен в строку. Пример:
# print(r'C:\Python310\lib\site-packages\')
# File "/Chapter_06.py", line 140
#     print(r'C:\Python310\lib\site-packages\')
# SyntaxError: unterminated string literal (detected at line 140)
print(r'C:\Python310\lib\site-packages\\')
# Избавиться от лишнего слеша можно, использовав конкатенацию строк, обычные строки
# или удалив слеш явно:
print(r'C:\Python310\lib\site-packages' + '\\')  # Конкатенация
print('С:\\Python310\\lib\\site-packages\\')     # Обычная строка
print(r'C:\PythonЗlO\lib\site-packages\\'[:-1])  # Удаление слеша


# 6.2. Операции над строками
print('6.2. Операции над строками')
# Строки относятся к последовательностям и, соответственно, поддерживают все операции, выполняемые над
# последовательностями.
# Можно извлечь любой символ строки, указав индекс этого символа в квадратных скобках. Нумерация символов начинается
# с нуля. Пример:
s = "Python"
print(s[0], s[1], s[2], s[3], s[4], s[5])
# При обращении к символу с несуществующим индексом возбуждается исключение IndexError:
# s = "Python"
# print(s[10])
# Traceback (most recent call last):
#   File "/Chapter_06.py", line 162, in <module>
#     print(s[10])
# IndexError: string index out of range
# Можно указать отрицательный индекс - он будет отсчитываться от конца строки:
s = "Python"
print(s[-1], s[-4])
# Так как строки относятся к неизменяемым типам данных, то изменить символ с указанным индексом нельзя:
# s = "Python"
# s[0] = 'J'
# Traceback (most recent call last):
#   File "Chapter_06.py", line 172, in <module>
#     s[0] = 'J'
# TypeError: 'str' object does not support item assignment
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


# 95
