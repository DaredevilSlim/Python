#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re  # Подключаем модуль re

# ГЛАВА 7
# Регулярные выражения
# Регулярное выражение - это шаблон, применяемый для поиска совпадающих с ним фрагментов в строках. Регулярное выражение
# состоит как из обычных знаков, так и всевозможных специальных символов: метасимволов, квантификаторов и др.
# В Python использовать регулярные выражения позволяет модуль re, который необходимо предварительно подключить с помощью
# инструкции:
# import re


# 7.1. Синтаксис регулярных выражений
print('7.1. Синтаксис регулярных выражений')
# Создать откомпилированное и готовое к использованию регулярное выражение позволяет функция compile(). Формат ее
# вызова:
# re.compile(<Шаблон регулярного выражения>[, <Флаги>])
# Шаблон создаваемого регулярного выражения указывается в виде строки или последовательности байтов типа bytes или
# bytearray. Флаги управляют особенностями обработки регулярного выражения. Можно указать как один флаг, так и их
# комбинацию через оператор |. Все поддерживаемые флаги также объявлены в модуле re:
# - I или IGNORECASE - регистр символов не учитывается:
p = re.compile(r'[а-яе]+$', re.I | re.U)
print('Найдено' if p.search('АБВГДЕЕ') else 'Нет')
p = re.compile(r'^[а-яе]+$', re.U)
print('Найдено' if p.search('АБВГДЕЕ') else 'Нет')

# - M или MULTILINE - метасимвол ^ обозначает начало каждой подстроки в строке, в которой выполняется поиск (сразу после
# символа перевода строки \n, который используется для разбиения строки на подстроки), а символ $ - конец каждой
# подстроки (непосредственно перед символом перевода строки). Без этого флага метасимвол ^ обозначает начало самой
# строки, в которой выполняется поиск, а символ $ - ее конец. Примеры:
p = re.compile(r'^.*$', re.M)
print(p.findall('Python\nDjango\nSQLite'))
p = re.compile(r'^.*$')
print(p.findall('Python\nDjango\nSQLite'))

# - S или DOTALL - метасимвол «точка» соответствует любому символу, включая перевод строки (\n). Без этого флага
# метасимвол «точка» будет соответствовать любому символу, исключая перевод строки. Примеры:
p = re.compile(r'^.*$')
print(p.findall('Python\nDjango\nSQLite'))
p = re.compile(r'^.*$', re.S)
print(p.findall('Python\nDjango\nSQLite'))

# - X или VERВOSE - пробелы, символы перевода строки и комментарии, поставленные в шаблоне регулярного выражения,
# игнорируются. Этот флаг позволяет форматировать шаблоны регулярных выражений для наилучшей читабельности. Примеры:
p = re.compile(r"""^  # Привязка к началу строки
               [0-9]+ # Строка должна содержать одну цифру (или более)
               $      # Привязка к концу строки
               """, re.X | re.S)
print('Найдено' if p.search('1234567890') else 'Нет')
print('Найдено' if p.search('abcd123') else 'Нет')

# - A или ASCII - классы \w, \W, \b, \B, \d, \D, \s и \S соответствуют символам в кодировке ASCII. Без этого флага
# указанные классы соответствуют Unicode-символам.
# ПРИМЕЧАНИЕ - Флаги U и UNICODE, включающие режим соответствия классов \w, \W, \b, \B, \d, \D, \s и \S
# Unicode-символам, сохранены в Python лишь для совместимости с ранними версиями этого языка и никакого влияния на
# обработку регулярных выражений не оказывают.

# - L или LOCALE - учитываются настройки текущей локали. Флаг принимается во внимание, только если шаблон регулярного
# выражения задан в виде последовательности байтов типа bytes или bytearray.

# Шаблоны регулярных выражений удобно записывать в виде необрабатываемых строк (содержащих модификатор r):
# p = re.compile(r'^\w+S')
# В обычных строках все обратные слеши придется заменять специальными символами \\:
# p = re.compile(r'^\\w+S')
# В шаблоне регулярного выражения символы ., ^, $, *, +, ?, {, [, ], \, |, (и) являются специальными и обрабатываются
# особым образом. Если же эти символы должны трактоваться как есть, их следует предварить обратными слешами. Некоторые
# специальные символы теряют свое особое значение, если их разместить внутри квадратных скобок,- в этом случае
# экранировать их не нужно. Например, как уже было отмечено ранее, метасимвол «точка» по умолчанию соответствует любому
# символу, кроме символа перевода строки. Если необходимо найти именно точку, то перед точкой нужно указать символ \ или
# разместить точку внутри квадратных скобок: [.] Продемонстрируем это на примере проверки правильности введенной даты
# test_00030.py.
# Метасимвол - это специальный символ, обозначающий привязку к началу или концу строки:
# - ^ - к началу строки или подстроки. Поведение зависит от флагов M (или MULTILINE) и S (или DOTALL);
# - $ - к концу строки или подстроки. Поведение зависит от флагов M (или MULTILINE) и S (или DOTALL);
# - \А - к началу строки (не зависит от флагов);
# - \Z - к концу строки (не зависит от флагов).
# Если указан флаг M (или MULTILINE), то при поиске в строке, состоящей из нескольких подстрок, разделенных символом \n,
# метасимвол ^ обозначает привязку к началу каждой такой подстроки (сразу после символа \n), а метасимвол $ - к концу
# каждой подстроки (непосредственно перед символом \n):
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


# 132

