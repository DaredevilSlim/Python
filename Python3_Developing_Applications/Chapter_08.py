#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import copy  # Подключаем модуль сору

# ГЛАВА 8
# Списки, кортежи, множества и диапазоны
# Список, кортеж, множество и диапазон - это упорядоченные наборы значений, иначе говоря, последовательности. Значение,
# входящее в последовательность, называется элементом и может быть любого типа: числом, строкой, логической величиной и
# даже другой последовательностью. Количество элементов в последовательности называется размером.
# Большинство последовательностей (в частности, список, кортеж и диапазон) являются пронумерованными, поскольку в них за
# каждым элементом закреплен порядковый номер - индекс. Зная его, можно извлечь из списка или кортежа соответствующий
# этому индексу элемент. Нумерация элементов в пронумерованной последовательности начинается с О.
# Часть последовательностей (например, множество) относятся к группе непронумерованных, т. к. у их элементов нет


# 8.1. Создание списков
print('8.1. Создание списков')
# Список - это изменяемая пронумерованная последовательность.
# Создать список можно следующими способами:
# - с помощью функции list([<Последовательность>]). Функция возвращает список, созданный на основе указанной
# последовательности. Если последовательность не указана, выдается пустой список. Примеры:
print(list())                 # Создаем пустой список
print(list('String'))         # Преобразуем строку в список
print(list((1, 2, 3, 4, 5)))  # Преобразуем кортеж в список

# - приведя элементы списка внутри квадратных скобок через запятую:
arr = [1, 'str', 3, '4']
print(arr)

# - заполнив список поэлементно с помощью метода append() :
arr = list()       # Создаем пустой список
arr.append(1)      # Добавляем элемент1 (индекс О)
arr.append('str')  # Добавляем элемент2 (индекс 2)
print(arr)

# Не забываем, что при присваивании объекта (например, списка) какой-либо переменной в последнюю заносится не сам
# объект, а ссылка на него. В результате получатся две переменные, указывающие на один и тот же объект. Пример:
x = y = [1, 2]  # Якобы создали два списка
print(x, y)
y[1] = 100      # Изменяем второй элемент списка из второй переменной
print(x, y)     # Изменилось значение сразу в двух переменных
# Но что же делать, если необходимо создать копию списка? Первый способ заключается в применении операции извлечения
# среза, второй - в использовании функции list(), а третий - в вызове метода сору(). Примеры:
x = [1, 2, 3, 4, 5]  # Создали список
# Создаем копию списка
y = list(x)          # или с помощью среза: у = х[:] или вызовом метода сору(): у = х.сору()
print(y)
print(x is y)        # Оператор is показывает, что это разные объекты
y[1] = 100           # Изменяем второй элемент
print(x, y)          # Изменился только список в переменной у
# Однако, если в числе элементов копируемого списка имеются другие списки (вложенные), будут скопированы не сами эти
# списки, а ссылки на них. Как говорят в таких случаях программисты, будет создана поверхностная, копия. Рассмотрим
# пример:
x = [1, [2, 3, 4, 5]]  # Создали вложенный список
y = list(x)            # Якобы сделали копию списка
print(x is y)          # Разные объекты
y[1][1] = 100          # Изменяем элемент вложенного списка
print(x, y)            # Изменение затронуло переменную х!!!
# Чтобы получить полную копию списка вместе с вложенными списками, следует воспользоваться функцией deepcopy() из модуля
# сору:
# import copy # Подключаем модуль сору
x = [1, [2, 3, 4, 5]]
y = copy.deepcopy(x)  # Делаем полную копию списка
y[1][1] = 100         # Изменяем элемент вложенного списка
print(x, y)           # Изменился только список в переменной у
# Функция deepcopy() создает копию каждого объекта, при этом сохраняя внутреннюю структуру списка. Иными словами, если в
# списке существуют два элемента, ссылающиеся на один объект, то будет создана копия объекта и элементы будут ссылаться
# на этот новый объект, а не на разные объекты. Пример:
x = [1, 2]
y = [x, x]            # Два элемента ссылаются на один список
print(y)
z = copy.deepcopy(y)  # Сделали копию списка
print(z[0] is x, z[1] is x, z[0] is z[1])
z[0][0] = 300         # Изменили один элемент вложенного списка
print(z)              # Значение изменилось сразу в двух вложенных списках!
print(x)              # Начальный список не изменился


# 8.2. Операции над списками
print('8.2. Операции над списками')
# Чтобы получить элемент списка по его индексу, следует поставить после списка квадратные скобки и указать индекс в них:
arr = [1, 'str', 3.2, '4']
print(arr[0], arr[1], arr[2], arr[3])
# С помощью позиционного присваивания можно присвоить значения элементов списка каким-либо переменным. Количество
# элементов справа и слева от оператора = должно совпадать, иначе будет выведено сообщение об ошибке. Примеры:
x, y, z = [1, 2, 3]  # Позиционное присваивание
print(x, y, z)
# x, y = [1, 2, 3]   # Количество элементов должно совпадать
# Traceback (most recent call last):
#   File "/Chapter_08.py", line 89, in <module>
#     x, y = [1, 2, 3]
#     ^^^^
# ValueError: too many values to unpack (expected 2)
# Перед одной из переменных слева от оператора = можно указать звездочку - и тогда в этой переменной будет сохранен
# список из «лишних» элементов. Если таких элементов нет, список будет пустым. Примеры:
x, y, *z = [1, 2, 3]
print(x, y, z)
x, y, *z = [1, 2, 3, 4, 5]
print(x, y, z)
x, y, *z = [1, 2]
print(x, y, z)
*x, y, z = [1, 2]
print(x, y, z)
x, *y, z = [1, 2, 3, 4, 5]
print(x, y, z)
*z, = [1, 2, 3, 4, 5]
print(z)
# В качестве индекса можно указать отрицательное значение. Такой индекс будет отсчитываться от конца списка. Пример:
arr = [1, 2, 3, 4, 5]
print(arr[-1], arr[-3])
# Так как списки относятся к изменяемым типам данных, мы можем изменить элемент по его индексу:
arr = [1, 2, 3, 4, 5]
arr[0] = 600           # Изменение элемента по индексу
print(arr)
# Если элемент с указанным индексом отсутствует в списке, возбуждается исключение IndexError:
# arr = [1, 2, 3, 4, 5]
# print(arr[5])          # Обращение к несуществующему элементу
# Traceback (most recent call last):
#   File "/Chapter_08.py", line 118, in <module>
#     print(arr[5])      # Обращение к несуществующему элементу
#           ~~~^^^
# IndexError: list index out of range
# Получить размер списка (количество элементов в нем) позволяет функция len():
arr = [1, 2, 3, 4, 5]
print(len(arr))           # Получаем количество элементов
print(arr[len(arr) - 1])  # Получаем последний элемент
# Срез - это фрагмент списка, который сам является списком и содержит элементы, индексы которых располагаются между
# указанными начальным, конечным индексами и отстоят друг от друга на заданный шаг. Формат операции извлечения среза:
# [<Начало>:<Конец>:<Шаг>]
# Все параметры не являются обязательными. Если параметр <Начало> не указан, используется значение 0. Если параметр
# <Конец> не указан, возвращается фрагмент до конца списка. Элемент с индексом, указанным в параметре <Конец>, не входит
# в возвращаемый срез. Если параметр <Шаг> не указан, используется значение 1. В качестве значения параметров можно
# указать отрицательные значения. Рассмотрим несколько примеров:
# - получение поверхностной копии списка:
arr = [1, 2, 3, 4, 5]
m = arr[:]             # Создаем поверхностную копию и выводим значения
print(m)
print(m is arr)        # Оператор is показывает, что это разные объекты
# - вывод элементов списка в обратном порядке:
arr = [1, 2, 3, 4, 5]
print(arr[::-1])       # Шаг -1
# - вывод списка без первого и последнего элементов:
print(arr[1:])         # Без первого элемента
print(arr[:-1])        # Без последнего элемента
# - извлечение среза, содержащего первые два элемента списка:
print(arr[0:2])        # Символ с индексом 2 не входит в диапазон
# - получение среза, содержащего последний элемент списка:
print(arr[-1:])        # Последний элемент списка
# - получение среза с элементами от второго до четвертого включительно:
print(arr[1:4])        # Возвращаются элементы с индексами 1, 2 и 3
# С помощью среза можно изменить фрагмент списка. Если срезу присвоить пустой список, то элементы, попавшие в срез,
# будут удалены. Примеры:
arr = [1, 2, 3, 4, 5]
arr[1:3] = [6, 7]      # Изменяем значения элементов с индексами 1 и 2
print(arr)
arr[1:3] = []          # Удаляем элементы с индексами 1 и 2
print(arr)
# Объединить два списка в один список позволяет оператор +. Результатом объединения будет новый список. Пример:
arr1 = [1, 2, 3, 4, 5]
arr2 = [6, 7, 8, 9]
arr3 = arr1 + arr2
print(arr3)
# Вместо оператора + можно использовать оператор +=. Следует учитывать, что в этом случае элементы добавляются в текущий
# список. Пример:
arr = [1, 2, 3, 4, 5]
arr += [6, 7, 8, 9]
print(arr)
# Еще списки поддерживают операции повторения (оператор *), проверки на вхождение (оператор in) и на невхождение
# (оператор not in):
print([1, 2, 3] * 3)                                 # Повторение
print(2 in [1, 2, 3, 4, 5], 6 in [1, 2, 3, 4, 5])    # Проверка на вхождение
print(2 not in [1, 2, 3, 4], 6 not in [1, 2, 3, 4])  # Проверка на невхождение


# 8.3. Многомерные списки
print('8.3. Многомерные списки')
# Многомерным называется список, содержащий в числе своих элементов вложенные списки (или иные последовательности).
# Создать многомерный список можно, например, так:
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(arr)
# Как вы уже знаете, выражение внутри скобок может располагаться на нескольких строках. Следовательно, предыдущий пример
# можно записать иначе:
arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
print(arr)
# Чтобы получить значение элемента из вложенного списка, следует указать два индекса:
print(arr[1][1])
# Вложенные списки также могут содержать вложенные списки. В этом случае для доступа к элементам указывается несколько
# индексов подряд, например:
arr = [[1, ['a', 'b'], 3], [4, 5, 6], [7, 8, 9]]
print(arr[0][1][0])
arr = [[1, {'a': 10, 'b': ['s', 5]}]]
print(arr[0][1]['b'][0])


# 8.4. Перебор списков
print('8.4. Перебор списков')
# Последовательно перебрать все элементы списка можно с помощью цикла перебора последовательности:
arr = [1, 2, 3, 4, 5]
for i in arr:
    print(i, end=' ')
print()
# Значение очередного элемента списка заносится в переменную, указанную в цикле. Его можно изменить в теле цикла, но
# если оно относится к неизменяемому типу данных (например, числовому или строковому), это не отразится на исходном
# списке. Пример:
arr = [1, 2, 3, 4]      # Элементы имеют неизменяемый тип (число)
for i in arr:
    i += 10
print(arr)              # Список не изменился
arr = [[1, 2], [3, 4]]  # Элементы имеют изменяемый тип (список)
for i in arr:
    i[0] += 10
print(arr)              # Список изменился
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


# 143

