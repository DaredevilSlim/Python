#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import math
import locale
import keyword
import pickle
import hashlib

# Глава 6
# Строки и двоичные данные
print('Строки и двоичные данные:')
# Строки представляют собой упорядоченные последовательности символов. Длина строки ограничена лишь объемом оперативной
# памяти компьютера. Как и все последовательности, строки поддерживают обращение к элементу по индексу, получение среза,
# конкатенацию (оператор +), повторение (оператор *), проверку на вхождение (операторы in и not in). Кроме того, строки
# относятся к неизменяемым типам данных. Поэтому практически все строковые методы в качестве значения возвращают новую
# строку. При использовании небольших строк это не приводит к каким-либо проблемам, но при работе с большими строками
# можно столкнуться с проблемой нехватки памяти. Иными словами, можно получить символ по индексу, но изменить его будет
# нельзя.
s = 'Python'
print(s[0])  # Получение символа по индексу
# В некоторых языках программирования концом строки является нулевой символ. В языке Python нулевой символ может быть
# расположен внутри строки:
print('string\x00string')  # Нулевой символ - это НЕ конец строки
# Язык Python 3 поддерживает следующие строковые типы:
print('Язык Python 3 поддерживает следующие строковые типы:')
# str - Unicode-строка. Конкретная кодировка: UTF-8, UTF-16 или UTF-32 - здесь не указана. Рассматривайте такие строки,
# как строки в некой абстрактной кодировке, позволяющие хранить символы Unicode и производить манипуляции с ними. При
# выводе Unicode-строку необходимо преобразовать в последовательность байтов в какой-либо кодировке:
print('str - Unicode-строка:')
print(type('Строка'))
print('Строка'.encode(encoding='cp1251'))
print('Строка'.encode(encoding='utf-8'))
# bytes - Неизменяемая последовательность байтов. Каждый элемент последовательности может хранить целое число от 0 до
# 255, которое обозначает код символа. Объект типа bytes поддерживает большинство строковых методов и, если это
# возможно, выводится как последовательность символов. Однако доступ по индексу возвращает целое число, а не символ.
print('bytes - Неизменяемая последовательность байтов:')
s = bytes('стр str', 'cp1251')
print(s[0], s[5], s[0:3], s[4:7])
print(s)
# Объект типа bytes может содержать как однобайтовые, так и многобайтовые символы. Функции и методы строк некорректно
# работают с многобайтовыми кодировками, например, функция len() вернет количество байтов, а не символов:
print(len('Строка'))
print(len(bytes('Строка', 'cp1251')))
print(len(bytes('Строка', 'utf-8')))
# bytearray - изменяемая последовательность байтов. Тип bytearray аналогичен типу bytes, но позволяет изменять элементы
# по индексу и содержит дополнительные методы, дающие возможность добавлять и удалять элементы.
print('bytearray - изменяемая последовательность байтов:')
s = bytearray("str", 'cp1251')
print(s)
s[0] = 49  # Можно изменить символ
print(s)
s.append(55)  # Можно добавить символ
print(s)
# Во всех случаях, когда речь идет о текстовых данных, следует использовать тип str. Именно этот тип мы будем называть
# словом «строка». Типы bytes и bytearray следует задействовать для записи бинарных данных - например, изображений,
# а также для промежуточного хранения текстовых данных.


# 6.1 Создание строки
print('Создание строки:')
print('Создать строку можно следующими способами:')
# C помощью функции str([<Объект>[, <Кодировка>[, <Обработка ошибок>]]]). Если указан только первый параметр, то
# функция возвращает строковое представление любого объекта. Если параметры не указаны вообще, то возвращается пустая
# строка.
print('C помощью функции str([<Объект>[, <Кодировка>[, <Обработка ошибок>]]]):')
print(str(), str([1, 2]), str((3, 4)), str({'x': 1}))
print(str(b'\xd1\xf2\xf0\xee\xea\xe0'))
# Обратите внимание на преобразование объекта типа bytes. Было получено строковое представление объекта, а не нормальная
# строка. Чтобы получить из объектов типа bytes и bytearray именно строку, следует указать кодировку во втором
print(str(b'\xd1\xf2\xf0\xee\xea\xe0', 'cp1251'))
# В третьем параметре могут быть указаны значения "strict" (при ошибке возбуждается исключение UnicodeDecodeError -
# значение по умолчанию), "replace" (неизвестный символ заменяется символом, имеющим код \uFFFD) или "ignore"
# (неизвестные символы игнорируются):
obj1 = bytes('Строка1', 'utf-8')
print(obj1)
obj2 = bytearray('Строка2', 'utf-8')
print(obj2)
print(str(obj1, 'utf-8'), str(obj2, 'utf-8'))
print(str(obj1, 'ascii', 'ignore'))
# Указав строку между апострофами или двойными кавычками:
print('Указав строку между апострофами или двойными кавычками:')
print('Строка', "Строка", '"х": 5', "'х': 5")
print('Строка1\nСтрока2')
print("Строка1\nСтрока2")
# В некоторых языках программирования (например, в РНР) строка в апострофах отличается от строки в кавычках тем, что
# внутри апострофов специальные символы выводятся как есть, а внутри кавычек они интерпретируются. В языке Python
# никакого отличия между строкой в апострофах и строкой в кавычках нет. Это одно и то же. Если строка содержит кавычки,
# то ее лучше заключить в апострофы, и наоборот. Все специальные символы в таких строках интерпретируются. Например,
# последовательность символов \n преобразуется в символ новой строки. Чтобы специальный символ выводился как есть, его
# необходимо экранировать с помощью слеша:
print('Строка1\\nСтрока2')
print("Строка1\\nСтрока2")
# Кавычку внутри строки в кавычках и апостроф внутри строки в апострофах также необходимо экранировать с помощью слеша:
print("\"х\": 5", '\'х\': 5')
# Заключать объект в одинарные кавычки (или апострофы) на нескольких строках нельзя. Переход на новую строку вызовет
# синтаксическую ошибку. Чтобы расположить объект на нескольких строках, следует перед символом перевода строки указать
# символ \, поместить две строки внутри скобок или использовать конкатенацию внутри скобок:
print("Строка1\
Строка2")         # После \ не должно быть никаких символов
print('Строка1'
      'Строка2')  # Неявная конкатенация строк
print('Строка1' +
      'Строка2')  # Явная конкатенация строк
# Если в конце строки расположен символ \, то его необходимо экранировать, иначе будет выведено сообщение об ошибке.
# Указав строку между утроенными апострофами или утроенными кавычками. Такие объекты можно разместить на нескольких
# строках, допускается также одновременно использовать и кавычки, и апострофы без необходимости их экранировать. В
# остальном такие объекты эквивалентны строкам в апострофах и кавычках. Все специальные символы в таких строках
# интерпретируются.
print('Указав строку между утроенными апострофами или утроенными кавычками:')
print('''Строка1
Строка2''')
print("""Строка1
Строка2""")
# Если строка не присваивается переменной, то она считается строкой документирования. Такая строка сохраняется в
# атрибуте _doc_ того объекта, в котором расположена. Функция со строкой документирования, и вывод содержимого строки:
print('Функция со строкой документирования, и вывод содержимого строки:')


def test():
    """Это описание функции"""
    pass


print(test. __doc__)
# Поскольку выражения внутри таких строк не выполняются, то утроенные кавычки (или утроенные апострофы) очень часто
# используются для комментирования больших фрагментов кода на этапе отладки программы. Если перед строкой разместить
# модификатор r, то специальные символы внутри строки выводятся как есть. Например, символ \n не будет преобразован в
# символ перевода строки.
# Иными словами, он будет считаться последовательностью двух символов:\ и n:
print("Строка1\nСтрока2")
print(r"Строка1\nСтрока2")
# Такие неформатированные строки удобно использовать в шаблонах регулярных выражений, а также при указании пути к
# файлу или каталогу:
print(r"C:\Python34\lib\site-packages")
# Если модификатор не указать, то все слеши при указании пути необходимо экранировать:
print("C:\\Python34\\lib\\site-packages")
# Если в конце не форматированной строки расположен слеш, то его необходимо экранировать. Однако следует учитывать, что
# этот слеш будет добавлен в исходную строку. Пример:
print(r"C:\Python34\lib\site-packages\\")
# Чтобы избавиться от лишнего слеша, можно использовать операцию конкатенации строк, обычные строки или удалить слеш
# явным образом:
print(r"C:\Python34\lib\site-packages" + "\\")  # Конкатенация
print("C:\\Python34\\lib\\site-packages\\")     # Обычная строка
print(r"C:\Python34\lib\site-packages\\"[:-1])  # Удаление спеша


# 6.2 Специальные символы
print('Специальные символы:')
# Специальные символы - это комбинации знаков, обозначающих служебные или непечатаемые символы, которые невозможно
# вставить обычным способом.
# Перечень специальных символов, допустимых внутри строки, перед которой нет модификатора r:
print('Перечень специальных символов, допустимых внутри строки, перед которой нет модификатора r:')
# \n - перевод строки;
print(r'\n - перевод строки;')
# \r - возврат каретки;
print(r'\r - возврат каретки;')
# \t - знак табуляции;
print(r'\t - знак табуляции;')
# \v - вертикальная табуляция;
print(r'\v - вертикальная табуляция;')
# \а - звонок;
print(r'\а - звонок;')
# \b - забой;
print(r'\b - забой;')
# \f - перевод формата;
print(r'\f - перевод формата;')
# \0 - нулевой символ (не является концом строки);
print(r'\О - нулевой символ (не является концом строки);')
# \" - кавычка;
print(r'\" - кавычка;')
# \' - апостроф;
print(r'\' - апостроф;')
# \N - восьмеричное значение N. Например, \74 соответствует символу <;
print(r'\N - восьмеричное значение N;')
# \xN - шестнадцатеричное значение N. Например, \х6а соответствует символу j;
print(r'\xN - шестнадцатеричное значение N;')
# \\ - обратный слеш;
print(r'\\ - обратный слеш;')
# \uxxxx - 16-битный символ Unicode. Например, \u04За соответствует русской букве к;
print(r'\uxxxx - 16-битный символ Unicode;')
# \Uxxxxxxxx - 32-битный символ Unicode.
print(r'\Uxxxxxxxx - 32-битный символ Unicode.')
# Если после слеша не стоит символ, который вместе со слешем интерпретируется как спецсимвол, то слеш сохраняется в
# составе строки:
print("Этот символ \ не специальный:")
# Тем не менее, лучше экранировать слеш явным образом:
print("Этот символ \\не специальный:")


# 6.3 Операции над строками
print('Операции над строками:')
# Строки относятся к последовательностям. Как и все последовательности, строки поддерживают обращение к элементу по
# индексу, получение среза, конкатенацию, повторение и проверку на вхождение.
# К любому символу строки можно обратиться как к элементу списка - достаточно указать его индекс в квадратных скобках.
# Нумерация начинается с нуля:
print('Нумерация начинается с нуля:')
s = 'Python'
print(s[0], s[1], s[2], s[3], s[4], s[5])
# Если символ, соответствующий указанному индексу, отсутствует в строке, то возбуждается исключение IndexError.
# В качестве индекса можно указать отрицательное значение. В этом случае смещение будет отсчитываться от конца строки,
# а точнее - чтобы получить положительный индекс, значение вычитается из длины строки:
s = 'Python'
print(s[-1], s[len(s) - 1])
# Так как строки относятся к неизменяемым типам данных, то изменить символ по индексу нельзя.
# Чтобы выполнить изменение, можно воспользоваться операцией извлечения среза, которая возвращает указанный фрагмент
# строки. Формат операции:
# [<Начало>:<Конец>:<Шаг>]
# Все параметры здесь не являются обязательными. Если параметр <Начало> не указан, то используется значение 0. Если
# параметр <Конец> не указан, то возвращается фрагмент до конца строки. Символ с индексом, указанным в этом параметре,
# не входит в возвращаемый фрагмент. Если параметр <Шаг> не указан, то используется значение 1. В качестве значения
# параметров можно указать отрицательные значения.
# Получение копии строки:
print('Получение копии строки:')
s = 'Python'
print(s[:])  # Возвращается фрагмент от позиции 0 до конца строки
# Вывод символов в обратном порядке:
print('Вывод символов в обратном порядке:')
print(s[::-1])  # Указывается отрицательное значение в параметре <Шаг>
# Замена первого символа в строке:
print('Замена первого символа в строке:')
print('J' + s[1:])  # Извлечение фрагмента от символа 1 до конца строки
# Удаление последнего символа:
print('Удаление последнего символа:')
print(s[:-1])  # Вывод фрагмента от 0 до len(s) - 1
# Получение первого символа в строке:
print('Получение первого символа в строке:')
print(s[0:1])  # Символ с индексом 1 не входит в диапазон
# Получение последнего символа в строке:
print('Получение последнего символа в строке:')
print(s[-1:])  # Вывод фрагмента от len(s) - 1 до конца строки
# Вывод символов с индексами 2,3 и 4:
print('Вывод символов с индексами 2,3 и 4:')
print(s[2:5])  # Вывод символов с индексами 2,3 и 4:
# Узнать количество символов в строке позволяет функция len():
print('Узнать количество символов в строке позволяет функция len():')
print(len('Python'), len('\r\n\t'), len(r'\r\n\t'))
# Перебор всех символов с помощью цикла for:
print('Перебор всех символов с помощью цикла for:')
s = 'Python'
for i in range(len(s)):
    print(s[i], end=' ')
print()
# Так как строки поддерживают итерации, можно просто указать строку в качестве параметра цикла:
for i in s:
    print(i, end=' ')
print()
# Объединение двух строк в одну строку при помощи оператора +:
print('Объединение двух строк в одну строку при помощи оператора +:')
print('Строка1' + 'Строка2')
# Неявная конкатенация строк. В этом случае две строки указываются рядом без оператора между ними:
print('Неявная конкатенация строк:')
print('Строка1' 'Строка2')
# Если между строками указать запятую, то результатом будет кортеж, а не строка:
print('Если между строками указать запятую, то результатом будет кортеж, а не строка:')
s = 'Строка1', 'Строка2'
print(type(s))  # Кортеж, а не строка
# Если соединяются, переменная и строка, то следует обязательно указывать символ конкатенации строк, иначе будет
# выведено сообщение об ошибке:
s = 'Строка!'
print(s + 'Строка2')
# При необходимости соединить строку с другим типом данных (например, с числом) следует произвести явное преобразование
# типов с помощью функции str():
print('string' + str(10))
# Кроме рассмотренных операций, строки поддерживают операцию повторения, проверку на вхождение и не вхождение. Повторить
# строку указанное количество раз можно с помощью оператора *, выполнить проверку на вхождение фрагмента в строку
# позволяет оператор in, а проверить на не вхождение - оператор not in:
print('-' * 20)
print('yt' in 'Python')       # Найдено
print('yt' in 'Perl')         # Не найдено
print('PHP' not in 'Python')  # Не найдено


# 6.4 Форматирование строк
print('Форматирование строк:')
# Вместо соединения строк с помощью оператора + лучше использовать форматирование. Эта операция позволяет соединять
# строку с любым другим типом данных и выполняется быстрее конкатенации.
# Примечание - В последующих версиях Python оператор форматирования % может быть удален. Вместо этого оператора в новом
# коде следует использовать метод format().
# Форматирование имеет следующий синтаксис:
# <Строка специального формата> % <Значения>
# Внутри параметра <Строка специального формата> могут быть указаны спецификаторы, имеющие следующий синтаксис:
# %[(<Ключ>)] [<Флаг>] [<Ширина>] [.<Точность>]<Тип преобразования>
# Количество спецификаторов внутри строки должно быть равно количеству элементов в параметре <Значения>. Если
# используется только один спецификатор, то параметр <Значения> может содержать одно значение, в противном случае
# необходимо перечислить значения через запятую внутри круглых скобок, создавая тем самым кортеж.
print('%s' % 10)  # Один элемент
print('%s - %s - %s' % (10, 20, 30))  # Несколько элементов
# Параметры внутри спецификатора имеют следующий смысл:
print('Параметры внутри спецификатора имеют следующий смысл:')
# <Ключ> - ключ словаря. Если задан ключ, то в параметре <Значения> необходимо ука­зать словарь, а не кортеж.
print('<Ключ> - ключ словаря:')
print('%(name)s - %(year)s' % {'year': 1978, 'name': 'Nik'})
# <Флаг> - флаг преобразования. Может содержать следующие значения:
print('<Флаг> - флаг преобразования:')
# # - для в восьмеричных значений добавляет в начало комбинацию символов 0o, для шестнадцатеричных значений добавляет
# комбинацию символов 0x (если используется тип x) или 0X (если используется тип X), для вещественных чисел
# предписывает всегда выводить дробную точку, даже если задано значение 0 в параметре <Точность>:
print('# - для в восьмеричных значений добавляет в начало комбинацию символов 0o ...')
print('%#o %#o %#o' % (0o77, 10, 15))
print('%#x %#x %#x' % (0xff, 10, 15))
print("%#X %#X %#X" % (0xff, 10, 15))
print("%#.0F %.0F" % (300, 300))
# 0 - задает наличие ведущих нулей для числового значения:
print('0 - задает наличие ведущих нулей для числового значения:')
print("'%d' - '%05d'" % (3, 3))  # 5 - ширина поля
# - - задает выравнивание по левой границе области. По умолчанию используется выравнивание по правой границе. Если флаг
# указан одновременно с флагом 0, то действие флага 0 будет отменено.
print('- - задает выравнивание по левой границе области:')
print("'%5d' - '%-5d'" % (3, 3))  # 5 - ширина поля)
print("'%05d' - '%-05d'" % (3, 3))
# пробел - вставляет пробел перед положительным числом. Перед отрицательным числом будет стоять минус.
print('пробел - вставляет пробел перед положительным числом:')
print("'% d' - '% d'" % (-3, 3))
# + - задает обязательный вывод знака как для отрицательных, так и для положительных чисел. Если флаг + указан
# одновременно с флагом пробел, то действие флага пробел будет отменено.
print('+ - задает обязательный вывод знака как для отрицательных, так и для положитель­ных чисел')
print("'%+d' - '%+d'" % (-3, 3))
# <Ширина> - минимальная ширина поля. Если строка не помещается в указанную ширину, то значение игнорируется, и строка
# выводится полностью:
print('<Ширина> - минимальная ширина поля:')
print("'%10d' - '%-10d'" % (3, 3))
print("'%3s''%10s'" % ("string", "string"))
# Вместо значения можно указать символ '*'. В этом случае значение следует задать внутри кортежа:
print("'%*s''%10s'" % (10, "string", "str"))
# <Точность> - количество знаков после точки для вещественных чисел. Перед этим параметром обязательно должна стоять
# точка.
print('<Точность> - количество знаков после точки для вещественных чисел:')
print("%s %f %.2f" % (math.pi, math.pi, math.pi))
# Вместо значения можно указать символ '*'. В этом случае значение следует задать внутри кортежа:
print("'%*.*f'" % (8, 5, math.pi))
# <Тип преобразования> - задает тип преобразования. Параметр является обязательным.
print('<Тип преобразования> - задает тип преобразования:')
# В параметре <Тип преобразования> могут быть указаны следующие символы:
# s - преобразует любой объект в строку с помощью функции str():
print('В параметре <Тип преобразования> могут быть указаны следующие символы:')
print('s - преобразует любой объект в строку с помощью функции str():')
print('%s' % 'Обычная строка')
print('%s %s %s' % (10, 10.52, [1, 2, 3]))
# r - преобразует любой объект в строку с помощью функции repr():
print('r - преобразует любой объект в строку с помощью функции repr():')
print('%r' % 'Обычная строка')
# а - преобразует объект в строку с помощью функции ascii():
print('а - преобразует объект в строку с помощью функции ascii():')
print("%a" % 'строка')
# с - выводит одиночный символ или преобразует числовое значение в символ. В качестве примера выведем числовое
# значение и соответствующий этому значению символ:
print('с - выводит одиночный символ или преобразует числовое значение в символ:')
for i in range(33, 127):
    print('%s => %c' % (i, i))
# d и i - возвращают целую часть числа:
print('%d %d %d' % (10, 25.6, -80))
print('%i %i %i' % (10, 25.6, -80))
# о - восьмеричное значение:
print('о - восьмеричное значение:')
print('%o %o %o' % (0o77, 10, 15))
print('%#o %#o %#o' % (0o77, 10, 15))
# х - шестнадцатеричное значение в нижнем регистре:
print('х - шестнадцатеричное значение в нижнем регистре:')
print('%x %x %x' % (0xff, 10, 15))
print('%#x %#x %#x' % (0xff, 10, 15))
# X - шестнадцатеричное значение в верхнем регистре:
print('X - шестнадцатеричное значение в верхнем регистре:')
print('%X %X %X' % (0xff, 10, 15))
print('%#X %#X %#X' % (0xff, 10, 15))
# f и F - вещественное число в десятичном представлении:
print('f и F - вещественное число в десятичном представлении:')
print('%f %f %f' % (300, 18.65781452, -12.5))
print('%F %F %F' % (300, 18.65781452, -12.5))
print('%#.0F %.0F' % (300, 300))
# е - вещественное число в экспоненциальной форме (буква "е" в нижнем регистре):
print('е - вещественное число в экспоненциальной форме (буква "е" в нижнем регистре):')
print('%e %e' % (3000, 18657.81452))
# Е - вещественное число в экспоненциальной форме (буква "Е" в верхнем регистре):
print('Е - вещественное число в экспоненциальной форме (буква "Е" в верхнем регистре):')
print('%E %E' % (3000, 18657.81452))
# g - эквивалентно f или е (выбирается более короткая запись числа):
print('g - эквивалентно f или е (выбирается более короткая запись числа):')
print('%g %g %g' % (0.086578, 0.000086578, 1.865E-005))
# G - эквивалентно f или Е (выбирается более короткая запись числа):
print('G - эквивалентно f или Е (выбирается более короткая запись числа):')
print('%G %G %G' % (0.086578, 0.000086578, 1.865E-005))
# Если внутри строки необходимо использовать символ процента, то этот символ следует удвоить, иначе будет выведено
# сообщение об ошибке:
# print("% %s" % ("- это символ процента")) # Ошибка
print('%% %s' % '- это символ процента')    # Нормально
# % - это символ процента
# Форматирование строк очень удобно использовать при передаче данных в шаблон вебстраницы.  Для этого заполняем словарь
# данными и указываем его справа от символа %, а сам шаблон - слева. Продемонстрируем это на примере (test_00030.py).
print('Для форматирования строк можно также использовать следующие методы:')
# expandtabs([<Ширина поля>]) - заменяет символ табуляции пробелами таким образом, чтобы общая ширина фрагмента вместе
# с текстом, расположенным перед символом табуляции, была равна указанной величине. Если параметр не указан, то ширина
# поля предполагается равной 8 символам.
print('expandtabs([<Ширина поля>]) - заменяет символ табуляции пробелами:')
s = '1\t12\tl23\t'
print("'%s'" % s.expandtabs(4))
# В этом примере ширина задана равной четырем символам. Поэтому во фрагменте 1\t табуляция будет заменена тремя
# пробелами, во фрагменте 12\t - двумя пробелами, а во фрагменте 123\t - одним пробелом. Во всех трех фрагментах ширина
# будет равна четырем символам.
# Если перед символом табуляции нет текста или количество символов перед табуляцией равно указанной в вызове метода
# ширине, то табуляция заменяется указанным количеством пробелов:
s = '\t'
print("'%s' - '%s'" % (s.expandtabs(), s.expandtabs(4)))
s = '1234\t'
print("'%s'" % s.expandtabs(4))
# Если количество символов перед табуляцией больше ширины, то табуляция заменяется пробелами таким образом, чтобы
# ширина фрагмента вместе с текстом делилась без остатка на указанную ширину:
s = "12345\tl23456\tl234567\tl234567890\t"
print("'%s'" % s.expandtabs(4))
# Таким образом, если количество символов перед табуляцией больше 4, но менее 8, то фрагмент дополняется пробелами до 8
# символов. Если количество символов больше 8, но менее 12, то фрагмент дополняется пробелами до 12 символов и т. д.
# Все это справедливо при указании в качестве параметра числа 4;
# center(<Ширина>[, <Символ>]) - производит выравнивание строки по центру внутри поля указанной ширины. Если второй
# параметр не указан, то справа и слева от исходной строки будут добавлены пробелы.
print('center(<Ширина>[, <Символ>]) - производит выравнивание строки по центру внутри поля указанной ширины:')
s = 'str'
print(s.center(15), s.center(11, '-'))
# Выравнивание трех фрагментов шириной 15 символов. Первый фрагмент будет выровнен по правому краю, второй - по левому,
# а третий - по центру:
s = 'str'
print("'%15s' '%-15s' '%s'" % (s, s, s.center(15)))
# Если количество символов в строке превышает ширину поля, то значение ширины игнорируется, и строка возвращается
# полностью:
s = 'string'
print(s.center(6), s.center(5))
# ljust(<Ширина>[, <Символ>]) - производит выравнивание строки по левому краю внутри поля указанной ширины. Если второй
# параметр не указан, то справа от исходной строки будут добавлены пробелы. Если количество символов в строке превышает
# ширину поля, то значение ширины игнорируется, и строка возвращается полностью.
print('ljust(<Ширина>[, <Символ>]) - производит выравнивание строки по левому краю внутри поля указанной ширины:')
s = 'string'
print(s.ljust(15), s.ljust(15, "-"))
print(s.ljust(6), s.ljust(5))
# rjust(<Ширина>[, <Символ>]) - производит выравнивание строки по правому краю внутри поля указанной ширины. Если
# второй параметр не указан, то слева от исходнойСтроки и двоичные данные 87 строки будут добавлены пробелы. Если
# количество символов в строке превышает ширину поля, то значение ширины игнорируется, и строка возвращается полностью.
print('rjust(<Ширина>[, <Символ>]) - производит выравнивание строки по правому краю внутри поля указанной ширины:')
s = 'string'
print(s.rjust(15), s.rjust(15, "-"))
print(s.rjust(6), s.rjust(5))
# zfill(<Ширина>) - производит выравнивание фрагмента по правому краю внутри поля указанной ширины. Слева от фрагмента
# будут добавлены нули. Если количество символов в строке превышает ширину поля, то значение ширины игнорируется, и
# строка возвращается полностью.
print('zfill(<Ширина>) - производит выравнивание фрагмента по правому краю внутри поля указанной ширины:')
print("5".zfill(20), "123456".zfill(5))


# 6.5 Метод format()
print('Метод format():')
# Помимо операции форматирования, мы можем использовать для этой же цели метод format (). Синтаксис метода format():
print('Синтаксис метода format():')
# <Строка> = <Строка специального формата>.format(*args, **kwargs)
# В параметре <Строка специального формата> внутри символов фигурных скобок: {и} - указываются спецификаторы, имеющие
# следующий синтаксис:
# {[<Поле>][!<Функция>][:<Формат>]}
# Все символы, расположенные вне фигурных скобок, выводятся без преобразований. Если внутри строки необходимо
# использовать символы {и}, то эти символы следует удвоить, иначе возбуждается исключение ValueError.
print('Символы {{и}} - {0}'.format('специальные'))
# В параметре <Поле> можно указать индекс позиции (нумерация начинается с нуля) или ключ. Допустимо комбинировать
# позиционные и именованные параметры. В этом случае в методе format() именованные параметры указываются в самом конце.
print('<Поле> - можно указать индекс позиции (нумерация начинается с нуля) или ключ:')
print('{0} - {1} - {2}'.format(10, 12.3, 'string'))          # Индексы
arr = [10, 12.3, 'string']
print('{0} - {1} - {2}'.format(*arr))                        # Индексы
print('{model} - {color}'.format(color='red', model='ВМW'))  # Ключи
d = {'color': 'red', 'model': 'ВМW'}
print('{model} - {color}'.format(**d))                       # Ключи
print('{color} - {0}'.format(2015, color="red"))             # Комбинация
# В качестве параметра в методе format() можно указать объект. Для доступа к элементам по индексу внутри строки формата
# применяются квадратные скобки, а для доступа к атрибутам объекта используется точечная нотация:
arr = [10, [12.3, 'string']]
print('{0[0]} - {0[1][0]} - {0[1][1]}'.format(arr))  # Индексы
print('{arr[0]} - {arr[1][1]}'.format(arr=arr))      # Индексы


class Car:
    color, model = 'red', 'BMW'


car = Car()
print('{0.model} - {0.color}'.format(car))  # Атрибуты
# Существует также краткая форма записи, при которой параметр <Поле> не указывается. В этом случае скобки без
# указанного индекса нумеруются слева направо, начиная с нуля:
print('{} - {} - {} - {n}'.format(1, 2, 3, n=4))
print('{} - {} - {n} - {}'.format(1, 2, 3, n=4))
# Параметр <Функция> задает функцию, с помощью которой обрабатываются данные перед вставкой в строку. Если указано
# значение s, то данные обрабатываются функцией str(), если значение r, то функцией repr(), а если значение а, то
# функцией ascii(). Если параметр не указан, то для преобразования данных в строку используется функция str().
print('<Функция> - задает функцию, с помощью которой обрабатываются данные перед вставкой в строку:')
print('{0!s}'.format('Строка'))  # str()
print('{0!r}'.format('Строка'))  # repr()
print('{0!a}'.format('Строка'))  # ascii()
# В параметре <Формат> указывается значение, имеющее следующий синтаксис:
print('<Формат> - указывается значение, имеющее следующий синтаксис:')
# [[<Заполнитель>] <Выравнивание>][<Знак>][#][О][<Ширина>][,][.<Точность>] [<Преобразование>]
# Параметр <Ширина> задает минимальную ширину поля. Если строка не помещается в указанную ширину, то значение
# игнорируется, и строка выводится полностью.
print('<Ширина> - задает минимальную ширину поля:')
print("'{0:10}' '{1:3}'".format(3, 'String'))
# Ширину поля можно передать в качестве параметра в методе format(). В этом случае вместо числа указывается индекс
# параметра внутри фигурных скобок:
print("'{0:{1}}'".format(3, 10))
# по умолчанию значение внутри поля выравнивается по правому краю. Управлять выравниванием позволяет параметр
# <Выравнивание>. Можно указать следующие значения:
# < - по левому краю;
print("'{0:<10}'".format(3))
# > - по правому краю;
print("'{0:>10}'".format(3))
# ^ - по центру поля.
print("'{0:^10}'".format(3))
# = - знак числа выравнивается по левому краю, а число по правому краю:
print("'{0:=10}' '{1:=10}'".format(-3, 3))
# Пространство между знаком и числом по умолчанию заполняется пробелами, а знак положительного числа не указывается.
# Чтобы вместо пробелов пространство заполнялось нулями, необходимо указать нуль перед шириной поля:
print("'{0:=010}' '{1:=010}'".format(-3, 3))
# Такого же эффекта можно достичь, указав нуль в параметре <Заполнитель>. В этом параметре допускаются и другие символы,
# которые будут выводится вместо пробелов:
print("'{0:0=10}' '{1:0=10}'".format(-3, 3))
print("'{0:*<10}' '{1:+>10}' '{2:.^10}'".format(3, 3, 3))
# Управлять выводом знака числа позволяет параметр <Знак>. Допустимые значения:
# + - задает обязательный вывод знака как для отрицательных, так и для положительных чисел;
# - - вывод знака только для отрицательных чисел (значение по умолчанию);
# пробел - вставляет пробел перед положительным числом. Перед отрицательным числом будет стоять минус.
print("'{0:+}' '{1:-}' '{0:-}' '{1:-}'".format(3, -3))
print("'{0: }' '{1: }'".format(3, -3))  # Пробел
# для целых чисел в параметре <Преобразование> могут быть указаны следующие опции:
# b - двоичное значение:
print("'{0:b}' '{0:#b}'".format(3))
# c - преобразует целое число в соответствующий символ:
print("'{0:c}'".format(100))
# d - десятичное значение;
# n - аналогично опции d, но учитывает настройки локали.
# Вывод большого числа с разделением тысячных разрядов пробелом:
# import locale
# print(locale.setlocale(locale.LC_NUMERIC, 'Russian_Russia.1251'))
print('{0:n}'.format(100000000).replace('\uffa0', ' '))
# В Python 3 между разрядами вставляется символ с кодом \uffa0, который отображается квадратиком. Чтобы вывести символ
# пробела, мы производим замену в строке с помощью метода replace(). В Python версии 2 поведение было другим. Там
# вставлялся символ с кодом \xa0 и не нужно было производить замену. Чтобы в Python 3 вставлялся символ с кодом \xa0,
# следует воспользоваться функцией format() из модуля locale:
# import locale
# locale.setlocale(locale.LC_NUMERIC, "ru_RU.utf8")
# print(locale.setlocale(locale.LC_ALL, 'Russian_Russia.1251'))
print(locale.format_string('%d', 100000000, grouping=True))
print("'{0:s}'".format(locale.localeconv()['thousands_sep']))
# Можно также разделить тысячные разряды запятой, указав ее в строке формата:
print('{0:,d}'.format(100000000))
# o - восьмеричное значение:
print("'{0:d}' '{0:o}' '{0:#o}'".format(511))
# х - шестнадцатеричное значение в нижнем регистре:
print("'{0:x}' '{0:#x}'".format(255))
# X - шестнадцатеричное значение в верхнем регистре:
print("'{0:X}' '{0:#X}'".format(255))
# Для вещественных чисел в параметре <Преобразование> могут быть указаны следую­щие опции:
# f и F - вещественное число в десятичном представлении:
print("'{0:f}' '{1:f}' '{2:f}'".format(30, 18.6578145, -2.5))
# По умолчанию выводимое число имеет шесть знаков после запятой. Задать другое количество знаков после запятой мы
# можем в параметре <Точность>:
print("'{0:.7f}' '{1:.2f}'".format(18.6578145, -2.5))
# е - вещественное число в экспоненциальной форме (буква е в нижнем регистре):
print("'{0:e}' '{1:e}'".format(3000, 18657.81452))
# Е- вещественное число в экспоненциальной форме (буква Е в верхнем регистре):
print("'{0:E}' '{1:E}'".format(3000, 18657.81452))
# Здесь по умолчанию количество знаков после запятой также равно шести, но мы можем указать другую величину этого
# параметра:
print("'{0:.2e}' '{1:.2E}'".format(3000, 18657.81452))
# g - эквивалентно f или е (выбирается более короткая запись числа):
print("'{0:g}' '{1:g}'".format(0.086578, 0.000086578))
# n - аналогично опции g, но учитывает настройки локали;
# G - эквивалентно f или Е (выбирается более короткая запись числа):
print("'{0:G}' '{1:G}'".format(0.086578, 0.000086578))
# % - умножает число на 100 и добавляет символ процента в конец. Значение отображается в соответствии с опцией f.
print("'{0:%}' '{1:.4%}'".format(0.086578, 0.000086578))


# 6.5.1 Форматируемые строки
print('Форматируемые строки:')
# В Python 3.6 появилась весьма удобная альтернатива методу format() - форматируемые строки.
# Форматируемая строка обязательно должна предваряться буквой f или F. В нужных местах такой строки записываются команды
# на вставку в эти места значений, хранящихся в переменных, - точно так же, как и в строках специального формата,
# описанных ранее. Такие команды имеют следующий синтаксис:
# {[<Переменная>][!<Функция>][:<Формат>]}
# Параметр <Переменная> задает имя переменной, из которой будет извлечено вставляемое в строку значение. Вместо имени
# переменной можно записать выражение, вычисляющее значение, которое нужно вывести. Параметры <Функция> и <Формат> имеют
# то же назначение и записываются так же, как и в случае метода format():
a = 10
b = 12.3
s = 'string'
print(f'{a} - {b} - {s}')          # Простой вывод чисел и строк
print(f'{a} - {b:5.2f} - {s}')     # Вывод с форматированием
d = 3
print(f'{a} - {b :5.{d}f} - {s}')  # В командах можно использовать значения из переменных
arr = [3, 4]
print(f'{arr[0]} - {arr[1]}')      # Вывод элементов массива
print(f'{arr[0]} - {arr[1] * 2}')  # Использование выражений


# 6.6 Функции и методы для работы со строками
print('Функции и методы для работы со строками:')
# Основные функции для работы со строками:
print('Основные функции для работы со строками:')
# str([<Объект>]) - преобразует любой объект в строку. Если параметр не указан, то возвращается пустая строка.
# Используется функцией print() для вывода объектов.
print('str([<Объект>]) - преобразует любой объект в строку:')
print(str(), str([1, 2]), str((3, 4)), str({'x': 5}))
print('Строка1\nСтрока2')
# repr(<Объект>) - возвращает строковое представление объекта. Используется при выводе объектов в окне Python Shell
# редактора IDLE.
print('repr(<Объект>) - возвращает строковое представление объекта:')
print(repr('Строка'), repr([1, 2, 3]), repr({'x': 5}), repr('Строка1\nСтрока2'))
# ascii(<Объект>) - возвращает строковое представление объекта. В строке могут быть символы только из кодировки ASCII.
print('ascii([<Объект>]) - возвращает строковое представление объекта:')
print(ascii([1, 2, 3]), ascii({'x': 5}), ascii('строка'))
# len(<Строка>) - возвращает количество символов в строке:
print('len(<Строка>) - возвращает количество символов в строке:')
print(len('Python'), len('\r\n\t'), len(r'\r\n\t'), len('строка'))
# Основные методы для работы со строками:
print('Основные методы для работы со строками:')
# strip([<Символы>]) - удаляет указанные в параметре символы в начале и в конце строки. Если параметр не задан,
# удаляются пробельные символы: пробел, символ перевода строки(\n), символ возврата каретки(\r), символы
# горизонтальной(\t) и вертикальной табуляции(\v):
print('strip([<Символы>]) - удаляет указанные в параметре символы в начале и в конце строки:')
s1 = '     str\n\r\v\t'
s2 = 'strstrstrokstrstrstr'
print("'%s' - '%s'" % (s1.strip(), s2.strip('tsr')))
# lstrip([<Символы>]) - удаляет пробельные или указанные символы в начале строки:
print('lstrip([<Символы>]) - удаляет пробельные или указанные символы в начале строки:')
s1 = '     str     '
s2 = 'strstrstrokstrstrstr'
print("'%s' - '%s'" % (s1.lstrip(), s2.lstrip('tsr')))
# rstrip([<Символы>]) - удаляет пробельные или указанные символы в конце строки:
print('rstrip([<Символы>]) - удаляет пробельные или указанные символы в конце строки:')
s1 = '     str     '
s2 = 'strstrstrokstrstrstr'
print("'%s' - '%s'" % (s1.rstrip(), s2.rstrip('tsr')))
# split([<Разделитель>[, <Лимит>]) - разделяет строку на подстроки по указанному разделителю и добавляет эти
# подстроки в список, который возвращается в качестве результата. Если первый параметр не указан или имеет значение
# None, то в качестве разделителя используется символ пробела. Во втором параметре можно задать количество подстрок
# в результирующем списке - если он не указан или равен -1, в список попадут все подстроки. Если подстрок больше
# указанного количества, то список будет содержать еще один элемент - с остатком строки:
print('split([<Разделитель>[, <Лимит>]) - разделяет строку на подстроки по указанному разделителю:')
s = 'word1 word2 word3'
print(s.split(), s.split(None, 1))
s = 'word1\nword2\nword3'
print(s.split('\n'))
# Если в строке содержится несколько пробелов подряд, и разделитель не указан, то пустые элементы не будут добавлены
# в список:
s = 'word1       word2 word3'
print(s.split())
# При использовании другого разделителя могут возникнуть пустые элементы:
s = ',,word1,,word2,,word3,,'
print(s.split(','))
print('1,,2,,3'.split(','))
# Если разделитель не найден в строке, то список будет состоять из одного элемента, представляющего исходную строку:
print('word1 word2 word3'.split('\n'))
# rsplit([<Разделитель>[, <Лимит>]) - аналогичен методу split(), но поиск символа разделителя производится не слева
# направо, а наоборот, справа налево:
print('rsplit([<Разделитель>[, <Лимит>]) - аналогичен методу split():')
s = 'word1 word2 word3'
print(s.rsplit(), s.rsplit(None, 1))
print('word1\nword2\nword3'.rsplit('\n'))
# splitlines([True]) - разделяет строку на подстроки по символу перевода строки(\n) и добавляет их в список. Символы
# новой строки включаются в результат, только если необязательный параметр имеет значение True. Если разделитель не
# найден в строке, то список будет содержать только один элемент.
print('splitlines([True]) - разделяет строку на подстроки по символу перевода строки(\\n):')
print('word1\nword2\nword3'.splitlines())
print('word1\nword2\nword3'.splitlines(True))
print('word1\nword2\nword3'.splitlines(False))
print('word1 word2 word3'.splitlines())
# partition(<Разделитель>) - находит первое вхождение символа-разделителя в строку и возвращает кортеж из трех
# элементов: первый элемент будет содержать фрагмент, расположенный перед разделителем, второй элемент - сам
# разделитель, а третий элемент - фрагмент, расположенный после разделителя. Поиск  производится слева направо. Если
# символ-разделитель не найден, то первый элемент кортежа будет содержать всю строку, а остальные элементы останутся
# пустыми:
print('partition(<Разделитель>) - находит первое вхождение символа-разделителя в строку:')
print('word1 word2 word3'.partition(' '))
print('word1 word2 word3'.partition('\n'))
# rpartition(<Разделитель>) - метод аналогичен методу partition(), но поиск символа-разделителя производится справа
# налево. Если символ-разделитель не найден, то первые два элемента кортежа окажутся пустыми, а третий элемент будет
# содержать всю строку.
print('rpartition(<Разделитель>) - метод аналогичен методу partition():')
print('word1 word2 word3'.rpartition(' '))
print('word1 word2 word3'.rpartition('\n'))
# join() - преобразует последовательность в строку. Элементы добавляются через указанный разделитель. Элементы
# последовательности должны быть строками.
print('join() - преобразует последовательность в строку:')
# Синтаксис метода - <Строка> - <Разделитель>.join(<Последовательность>)
# Преобразование списка и кортежа в строку:
print(' => '.join(['word1', 'word2', 'word3']))  # Преобразование списка
print(' '.join(('word1', 'word2', 'word3')))  # Преобразование кортежа
# Как вы уже знаете, строки относятся к неизменяемым типам данных. Если попытаться изменить символ по индексу, возникнет
# ошибка. Чтобы изменить символ по индексу, можно преобразовать строку в список с помощью функции list(), произвести
# изменения, а затем с помощью метода join() преобразовать список обратно в строку:
s = 'Python'
print(s)
arr = list(s)     # Преобразование строки в список
print(arr)
arr[0] = 'J'      # Изменение элемента по индексу
print(arr)
s = ''.join(arr)  # Преобразование списка в строку
print(s)
# В Python 3 можно также преобразовать строку в тип bytearray, а затем изменить символ по индексу:
s = 'Python'
print(s)
b = bytearray(s, 'cp1251')
print(b)
b[0] = ord('J')
print(b)
s = b.decode('cp1251')
print(s)


# 6.7 Настройка локали
print('Настройка локали:')
# Для установки локали(совокупности локальных настроек системы) служит функция setlocale() из модуля locale. Перед
# использованием функции ее необходимо подключить.
# Функция setlocale() имеет следующий формат:
# setlocale(<Категория>[, <Локаль>])
# Параметр <Категория> может принимать следующие значения:
# locale.LC_ALL - устанавливает локаль для всех режимов;
# locale.LC_COLLATE - для сравнения строк;
# locale.LC_CTYPE - для перевода символов в верхний или нижний регистр;
# locale.LC_MONETARY - для отображения денежных единиц;
# locale.LC_NUMERIC - для форматирования чисел;
# locale.LC_TIME - для форматирования вывода даты и времени.
# Получить текущее значение локали позволяет функция getlocale([<Категория>]).
# Для кодировки windows-1251:
print('Для кодировки windows-1251:')
# print(locale.setlocale(locale.LC_NUMERIC, "ru_RU.utf8"))
# print(locale.setlocale(locale.LC_ALL, 'Russian_Russia.1251'))
# Локаль по умолчанию:
print('Локаль по умолчанию:')
print(locale.setlocale(locale.LC_ALL, ''))
# Текущее значение локали для всех категорий:
print('Текущее значение локали для всех категорий:')
print(locale.getlocale())
# Текущее значение категории locale.LC_COLLATE:
print('Текущее значение категории locale.LC_COLLATE:')
print(locale.getlocale(locale.LC_COLLATE))
# Получить настройки локали позволяет функция localeconv(). Функция возвращает словарь с настройками. Результат
# выполнения функции для локали Russian_Russia.1251:
print('Результат выполнения функции для локали Russian_Russia.1251:')
print(locale.localeconv())


# 6.8 Изменение регистра символов
print('Изменение регистра символов:')
# Методы для изменения регистра символов:
print('Методы для изменения регистра символов:')
# upper() - заменяет все символы строки соответствующими прописным буквами:
print('upper() - заменяет все символы строки соответствующими прописным буквами:')
print('строка'.upper())
# lower() - заменяет все символы строки соответствующими строчными буквами:
print('lower() - заменяет все символы строки соответствующими строчными буквами:')
print('СТРОКА'.lower())
# swapcase() - заменяет все строчные символы соответствующими прописными буквами, а все прописные символы - строчными:
print('swapcase() - заменяет все строчные символы соответствующими прописными буквами:')
print('СТРОКА строка'.swapcase())
# capitalize() - делает первую букву строки прописной:
print('capitalize() - делает первую букву строки прописной:')
print('строка строка'.capitalize())
# title() - делает первую букву каждого слова прописной:
print('title() - делает первую букву каждого слова прописной:')
s = 'первая буква каждого слова станет прописной'
print(s.title())
# casefold() - то же самое, что и lower(), но дополнительно преобразует все символы с диакритическими знаками и
# лигатуры в буквы стандартной латиницы. Обычно применяется для сравнения строк:
print('casefold() - то же самое, что и lower():')
print('Python'.casefold() == 'python'.casefold())
print('grosse'.casefold() == 'große'.casefold())


# 6.9 Функции для работы с символами
print('Функции для работы с символами:')
# Функции для работы с отдельными символами:
print('Функции для работы с отдельными символами:')
# chr(<Код символа>) - возвращает символ по указанному коду:
print('chr(<Код символа>) - возвращает символ по указанному коду:')
print(chr(1055))
# ord(<Символ>) - возвращает код указанного символа:
print('ord(<Символ>) - возвращает код указанного символа:')
print(ord('П'))


# 6.10 Поиск и замена в строке
print('Поиск и замена в строке:')
# Методы для поиска и замены в строке:
print('Методы для поиска и замены в строке:')
# find() - ищет подстроку в строке. Возвращает номер позиции, с которой начинается вхождение подстроки в строку.
# Если подстрока не входит в строку, то возвращается значение -1. Метод зависит от регистра символов.
print('find() - ищет подстроку в строке:')
# Формат метода:
# <Строка>.find(<Подстрока>[, <Начало>[,<Конец>]])
# Если начальная позиция не указана, то поиск осуществляется с начала строки. Если указаны <Начало> и <Конец>, то
# производится операция извлечения среза и поиск будет производится в этом фрагменте:
# <Строка>[<Начало>:<Конец>]
s = 'пример пример Пример'
print(s.find('при'), s.find('При'), s.find('тест'))
print(s.find('при', 9), s.find('при', 0, 6), s.find('при', 7, 12))
# index() - аналогичен методу find(), но если подстрока в строку не входит, то возбуждается исключение Value Error.
print('index() - аналогичен методу find():')
# Формат метода:
# <Строка>.index(<Подстрока>[, <Начало>[,<Конец>]])
s = 'пример пример Пример'
print(s.index('при'), s.index('при', 7, 12), s.index('При', 1))
# print(s.index('тест'))  # Возвратит ошибку Value Error
# rfind() - ищет подстроку в строке. Возвращает позицию последнего вхождения подстроки в строку. Если подстрока не
# входит в строку, то возвращается значение -1. Метод зависит от регистра символов. Формат метода:
print('rfind() - ищет подстроку в строке:')
# <Строка>.rfind(<Подстрока>[, <Начало>[,<Конец>]])
# Если указаны <Начало> и <Конец>, то производится операция извлечения среза и поиск будет производится в этом
# фрагменте:
s = 'пример пример Пример Пример'
print(s.rfind('при'), s.rfind('При'), s.rfind('тест'))
print(s.rfind('при', 0, 6), s.rfind('При', 10, 20))
# rindex() - аналогичен методу rfind(), но если подстрока в строку не входит, то возбуждается исключение ValueError.
print('rindex() - аналогичен методу rfind():')
# Формат метода:
# <Строка>.rindex(<Подстрока>[, <Начало>[,<Конец>]])
s = 'пример пример Пример Пример'
print(s.rindex('при'), s.rindex('При'), s.index('при', 0, 6))
# print(s.rindex('тест'))  # Возвратит ошибку Value Error
# count() - возвращает число вхождений подстроки в строку. Если подстрока не входит в строку, то возвращается
# значение 0. Метод зависит от регистра символов.
print('count() - возвращает число вхождений подстроки в строку:')
# Формат метода:
# <Строка>.count(<Подстрока>[, <Начало>[,<Конец>]])
s = 'пример пример Пример Пример'
print(s.count('при'), s.count('при', 6), s.count('При'))
print(s.count('тест'))
# startswith() - проверяет, начинается ли строка с указанной подстроки. Если начинается, то возвращается значение
# True, в противном случае - False. Метод зависит от регистра символов.
print('startswith() - проверяет, начинается ли строка с указанной подстроки:')
# Формат метода:
# <Строка>.startswith(<Подстрока>[, <Начало>[,<Конец>]])
# Если начальная позиция не указана, то поиск осуществляется с начала строки. Если указаны <Начало> и <Конец>, то
# производится операция извлечения среза и поиск будет производится в этом фрагменте:
s = 'пример пример Пример Пример'
print(s.startswith('при'), s.startswith('При'))
print(s.startswith('при', 6), s.startswith('При', 14))
# Начиная с Python 2.5 параметр <Подстрока> может быть кортежем:
s = 'пример пример Пример Пример'
print(s.startswith(('при', 'При')))
# endswith() - проверяет, заканчивается ли строка указанной подстрокой. Если заканчивается, то возвращается
# значение True, в противном случае - False. Метод зависит от регистра символов.
print('endswith() - проверяет, заканчивается ли строка с указанной подстроки:')
# Формат метода:
# <Строка>.endswith(<Подстрока>[, <Начало>[,<Конец>]])
# Если начальная позиция не указана, то поиск осуществляется с начала строки. Если указаны <Начало> и <Конец>, то
# производится операция извлечения среза и поиск будет производится в этом фрагменте:
s = 'подстрока ПОДСТРОКА'
print(s.endswith('ока'), s.endswith('ОКА'))
print(s.endswith('ока', 0, 9))
# Начиная с Python 2.5 параметр <Подстрока> может быть кортежем:
s = 'подстрока ПОДСТРОКА'
print(s.endswith(('ока', 'ОКА')))
# replace() - производит замену всех вхождений заданной подстроки в строке на другую подстроку и возвращает
# результат в виде новой строки. Метод зависит от регистра символов.
print('replace() - производит замену всех вхождений заданной подстроки в строке:')
# Формат метода:
# <Строка>.replace(<Подстрока для замены>, <Новая подстрока>[,<Максимальное количество замен>])
# Если количество замен не указано, будет выполнена замена всех найденных подстрок.
s = 'Привет, Петя'
print(s.replace('Петя', 'Вася'))
print(s.replace('петя', 'вася'))  # Зависит от регистра
s = 'strstrstrstrstr'
print(s.replace('str', ''), s.replace('str', '', 3))
# translate(<Таблица символов>) - заменяет символы в соответствии с параметром <Таблица символов>. Параметр <Таблица
# символов> должен быть словарем, ключами которого являются Unicode-коды заменяемых символов, а значениями
# Unicode-коды заменяющих символов. Если в качестве значения указать None, то символ будет удален.
print('translate(<Таблица символов>) - заменяет символы в соответствии с параметром <Таблица символов>:')
s = 'Пример'
d = {ord('П'): None, ord('р'): ord('Р')}
print(d)
print(s.translate(d))
# Упростить создание параметра <Таблица символов> позволяет статический метод maketrans().
# Формат метода:
# str.maketrans(<X>[, <Y>[, <Z>]])
# Если указан лишь первый параметр то он должен быть словарем:
t = str.maketrans({'а': 'А', 'о': 'О', 'с': None})
print(t)
print('строка'.translate(t))
# Если указаны два первых параметра, то они должны быть строками одинаковой длины. В результате будет создан словарь
# с ключами из строки <X> и значениями из строки <Y>, расположенными в той же позиции.
t = str.maketrans('абвгдежзи', 'АБВГДЕЖЗИ')
print(t)
print('абвгдежзи'.translate(t))
# В третьем параметре можно дополнительно указать строку из символов, которым будет сопоставлено значение None.
# После выполнения метода translate() эти символы будут удалены из строки.
t = str.maketrans('123456789', '0' * 9, 'str')
print(t)
print('str123456789str'.translate(t))


# 6.11 Проверка типа содержимого строки
print('Проверка типа содержимого строки:')
# Методы для проверки типа содержимого строки:
print('Методы для проверки типа содержимого строки:')
# isalnum() - возвращает True, если строка содержит только буквы и (или) цифры, в противном случае - False. Если
# строка пустая, то возвращается значение False.
print('isalnum() - возвращает True, если строка содержит только буквы и (или) цифры, в противном случае - False:')
print('0123'.isalnum(), '123аЬс'.isalnum(), 'аЬс123'.isalnum())
print('строка'.isalnum())
print(''.isalnum(), '123 аЬс'.isalnum(), 'аЬс, 123.'.isalnum())
# isalpha() - возвращает True, если строка содержит только буквы, в противном случае False. Если строка пустая, то
# возвращается значение False.
print('isalpha() - возвращает True, если строка содержит только буквы, в противном случае False:')
print('string'.isalpha(), 'строка'.isalpha(), ''.isalpha())
# (True, True, False)
print('123аЬс'.isalpha(), 'str str'.isalpha(), 'st, st'.isalpha())
# isdigit() - возвращает True, если строка содержит только цифры, в противном случае - False:
print('isdigit() - возвращает True, если строка содержит только цифры, в противном случае - False:')
print('0123'.isdigit(), '123abc'.isdigit(), 'abcl23'.isdigit())
# isdecimal() - возвращает True, если строка содержит только десятичные символы, в противном случае - False.
# К десятичным символам относятся не только десятичные цифры в кодировке ASCII, но и надстрочные и подстрочные
# десятичные цифры в других языках.
print('isdecimal() - возвращает True, если строка содержит только десятичные символы, в противном случае - False:')
print('123'.isdecimal(), '123cтp'.isdecimal())
# isnumeric() - возвращает True, если строка содержит только числовые символы, в противном случае - False. К числовым
# символам относятся не только десятичные цифры в кодировке ASCII, но символы римских чисел, дробные числа и др.
print('isnumeric() - возвращает True, если строка содержит только числовые символы, в противном случае - False:')
print('\u2155'.isnumeric(), '\u2155'.isdigit())
print('\u2155')  # Выведет символ "1/5"
# isupper() - возвращает True, если строка содержит буквы только верхнего регистра, в противном случае - False:
print('isupper() - возвращает True, если строка содержит буквы только верхнего регистра, в противном случае - False:')
print('STRING'.isupper(), 'СТРОКА'.isupper(), ''.isupper())
# (True, True, False)
print('STRING1'.isupper(), 'СТРОКА, 123'.isupper(), '123'.isupper())
print('string'.isupper(), 'STRing'.isupper())
# islower() - возвращает тrue, если строка содержит буквы только нижнего регистра, в противном случае - False:
print('islower() - возвращает тrue, если строка содержит буквы только нижнего регистра, в противном случае - False:')
print('string'.islower(), 'строка'.islower(), ''.islower())
print('string1'.islower(), 'str, 123'.islower(), '123'.islower())
print('STRING'.islower(), 'Строка'.islower())
# istitie() - возвращает True, если все слова в строке начинаются с заглавной буквы, в противном случае - False.
# Если строка пуста, также возвращается False.
print('istitie() - возвращает True, если все слова в строке начинаются с заглавной буквы, в противном случае - False')
print('Str Str'.istitle(), 'Стр Стр'.istitle())
print('Str Str 123'.istitle(), 'Стр Стр 123'.istitle())
print('Str str'.istitle(), 'Стр cтp'.istitle())
print(''.istitle(), '123'.istitle())
# ispriпtable() - возвращает True, если строка содержит только печатаемые символы, в противном случае - False.
# Пробел относится к печатаемым символам.
print('ispriпtable() - возвращает True, если строка содержит только печатаемые символы, в противном случае - False:')
print('123'.isprintable())
print('PHP Python'.isprintable())
print('\n'.isprintable())
# isspace() - возвращает True, если строка содержит только пробельные символы, в противном случае - False:
print('isspace() - возвращает True, если строка содержит только пробельные символы, в противном случае - False:')
print(''.isspace(), ' \n\r\t'.isspace(), 'str str'.isspace())
# isidentifier() - возвращает True, если строка представляет собой допустимое с точки зрения Python имя переменной,
# функции или класса, в противном случае - False:
print('isidentifier() - возвращает True, если строка представляет собой допустимое имя переменной:')
print('s'.isidentifier())
print('func'.isidentifier())
print('123func'.isidentifier())
# Метод isidentifier() лишь проверяет, удовлетворяет ли заданное имя правилам языка. Он не проверяет, совпадает ли
# это имя с ключевым словом Python. Для этого надлежит применять функцию iskeyword(), объявленную в модуле keyword,
# которая возвращает True, если переданная ей строка совпадает с одним из ключевых слов:
# import keyword
print(keyword.iskeyword('else'))
print(keyword.iskeyword('elsewhere'))
# Переделаем нашу программу суммирования произвольного количества целых чисел, введенных пользователем (test_00028.py)
# таким образом, чтобы при вводе строки вместо числа программа не завершалась с фатальной ошибкой. Кроме того,
# предусмотрим возможность ввода отрицательных целых чисел (test_00031.py).


# 6.12. Вычисление выражений, заданных в виде строк
print('Вычисление выражений, заданных в виде строк')
# Иногда возникает необходимость вычислить результат выражения Python, заданного в виде обычной строки. Для этого
# предназначена функция eval(), которая принимает в качестве единственного параметра строку с выражением и возвращает
# результат вычисления этого выражения:
s = '2 * 3'
n = eval(s)
print(n)
# В выражении, переданном функции eval(), могут использоваться переменные, уже существующие к настоящему моменту:
print(eval('n / 12'))
# Внимание! - Функция eval() выполнит любое переданное ей выражение. Используйте ее осторожно.


# 6.13 Тип данных bytes
print('Тип данных bytes:')
# Типы bytes и bytearray, позволяют хранить последовательность целых чисел в диапазоне от о до 255. Каждое такое число
# обозначает код символа. Тип данных bytes относится к неизменяемым типам, как и строки, а тип данных bytearray - к
# изменяемым, как и списки.
# Способы создания объекта типа bytes:
print('Способы создания объекта типа bytes:')
# С помощью функции bytes([<Строка>, <Кодировка> [, <Обработка ошибок>]]). Если параметры не указаны, то возвращается
# пустой объект. Чтобы преобразовать строку в объект типа bytes, необходимо передать минимум два первых параметра.
# Если строка указана только в первом параметре, то возбуждается исключение TypeError.
print('С помощью функции bytes([<Строка>, <Кодировка> [, <Обработка ошибок>]]):')
print(bytes())
print(bytes('Строка', 'cp1251'))
# В третьем параметре могут быть указаны значения "strict" (при ошибке возбуждается исключение UnicodeEncodeError -
# значение по умолчанию), "replace" (неизвестный символ заменяется символом вопроса) или "ignore" (неизвестные символы
# игнорируются).
print(bytes('string\uFFFD', 'cp1251', 'replace'))
print(bytes('string\uFFFD', 'cp1251', 'ignore'))
# С помощью метода строк encode([encoding="utf-8"] [, errors="strict"]). Если кодировка не указана, то строка
# преобразуется в последовательность байтов в кодировке UTF-8. В параметре errors могут быть указаны значения "strict"
# (значение по умолчанию), "replace", "ignore", "xmlcharrefreplace" или "backslashreplace".
print('С помощью метода строк encode([encoding="utf-8"] [, errors="strict"]):')
print('строка'.encode())
print('строка'.encode(encoding='cp1251'))
print('строка\uFFFD'.encode(encoding='cp1251', errors='xmlcharrefreplace'))
print('строка\uFFFD'.encode(encoding='cp1251', errors='backslashreplace'))
# Указав букву b (регистр не имеет значения) перед строкой в апострофах, кавычках, тройных апострофах или тройных
# кавычках. Обратите внимание на то, что в строке могут быть только символы с кодами, входящими в кодировку ASCII.
# Все остальные символы должны быть представлены специальными последовательностями:
print('Указав букву b (регистр не имеет значения) перед строкой в апострофах:')
print(b'string', b"string", b'''string''', b"""string""")
print(b'\xf1\xf2\xf0\xee\xea\xe0')
# С помощью функции bytes (<Последовательность>), которая преобразует последовательность целых чисел от 0 до 255 в
# объект типа bytes. Если число не попадает в диапазон, то возбуждается исключение ValueError.
print('С помощью функции bytes (<Последовательность>):')
b = bytes([225, 226, 224, 174, 170, 160])
print(b)
print(str(b, 'cp866'))
# С помощью функции bytes(<Число>), которая задает количество элементов в последовательности. Каждый элемент будет
# содержать нулевой символ.
print('С помощью функции bytes(<Число>):')
print(bytes(10))
# С помощью метода bytes.fromhex(<Строка>). Строка в этом случае должна содержать шестнадцатеричные значения символов.
print('С помощью метода bytes.fromhex(<Строка>):')
b = bytes.fromhex(' e1 e2e0ae aaa0 ')
print(b)
print(str(b, 'cp866'))
# Объекты типа bytes относятся к последовательностям. Каждый элемент такой последовательности может хранить целое число
# от 0 до 255, которое обозначает код символа. Как и все последовательности, объекты поддерживают обращение к элементу
# по индексу, получение среза, конкатенацию, повторение и проверку на вхождение.
b = bytes('string', 'cp1251')
print(b)
print(b[0])        # Обращение по индексу
print(b[1:3])      # Получение среза
print(b + b'123')  # Конкатенация
print(b * 3)       # Повторение
print(115 in b, b'tr' in b, b'as' in b)
# Как видно из примера, при выводе объекта целиком, а также при извлечении среза, производится попытка отображения
# символов. Однако доступ по индексу возвращает целое число, а не символ. Если преобразовать объект в список, то мы
# получим последовательность целых чисел.
print(list(bytes('string', 'cp1251')))
# Тип bytes относится к неизменяемым типам. Это означает, что можно получить значение по индексу. но изменить его
# нельзя.
b = bytes('string', 'cp1251')
print(b[0])
# Объекты типа bytes поддерживают большинство строковых методов. Однако некоторые из этих методов могут некорректно
# работать с русскими буквами - в этих случаях следует использовать тип str, а не тип bytes. Не поддерживаются
# объектами типа bytes строковые методы encode(), isidentifier(), isprintable(), isnumeric(), isdecimal(),
# format_map() и format(), а также операция форматирования. При использовании методов следует учитывать, что в
# параметрах нужно указывать объекты типа bytes, а не строки:
b = bytes('string', 'cp1251')
print(b.replace(b's', b'S'))
# Необходимо также помнить, что смешивать строки и объекты типа bytes в выражениях нельзя. Предварительно необходимо
# явно преобразовать объекты к одному типу, а лишь затем производить операцию:
print(b'string' + 'string'.encode('ascii'))
# Объект типа bytes может содержать как однобайтовые символы, так и многобайтовые. При использовании многобайтовых
# символов некоторые функции могут работать не так, как вы думаете, - например, функция len() вернет количество байтов,
# а не символов:
print(len('строка'))
print(len(bytes('строка', 'cp1251')))
print(len(bytes('строка', 'utf-8')))
# Преобразовать объект типа bytes в строку позволяет метод decode(). Метод имеет следующий формат:
# decode([encoding="utf-8"][, errors="strict"])
# Параметр encoding задает кодировку символов (по умолчанию UTF-8) в объекте bytes, а параметр errors - способ
# обработки ошибок при преобразовании. В параметре errors можно указать значения "strict" (значение по умолчанию),
# "replace" или "ignore". Пример преобразования:
b = bytes('строка', 'cp1251')
print(b.decode(encoding='cp1251'), b.decode('cp1251'))
# Для преобразования можно также воспользоваться функцией str():
b = bytes('строка', 'cp1251')
print(str(b, 'cp1251'))
# Чтобы изменить кодировку данных, следует сначала преобразовать тип bytes в строку, а затем произвести обратное
# преобразование, указав нужную кодировку. Преобразуем данные из кодировки Windows-1251 в кодировку KOI8-R, а затем
# обратно.
w = bytes('Строка', 'cp1251')  # Данные в кодировке windows-1251
k = w.decode('cp1251') .encode('koi8-r')
print(k, str(k, 'koi8-r'))     # Данные в кодировке KOI8-R
w = k.decode('koi8-r') .encode('cp1251')
print(w, str(w, 'cp1251'))     # Данные в кодировке windows-1251
# Начиная с Python 3.5, у нас появились два полезных инструмента для работы с типом дан­ных bytes. Во-первых, теперь
# можно форматировать такие данные с применением описан­ного в разд. 6.4 оператора %:
print(b'%i - %i - %f' % (10, 20, 30))
# Однако здесь нужно помнить, что тип преобразования s (то есть вывод в виде Unicode-строки) в этом случае не
# поддерживается, и его использование приведет к возбуждению исключения TypeError:
# print(b'%s - %s - %s' % (10, 20, 30))
# Во-вторых, тип bytes получил поддержку метода hex(), который возвращает строку с шестнадцатеричным представлением
# значения:
print(b'string'.hex())


# 6.14 Тип данных bytearray
print('Тип данных bytearray:')
# Тип данных bytearray является разновидностью типа bytes и поддерживает те же самые методы и операции. В отличие от
# типа bytes, тип bytearray допускает возможность непосредственного изменения объекта и содержит дополнительные методы,
# позволяющие выполнять эти изменения.
# Способы создания объекта типа bytearray:
print('Способы создания объекта типа bytearray:')
# С помощью функции bytearray([<Строка>, <Кодировка> [, <Обработка ошибок>]]). Если параметры не указаны, то
# возвращается пустой объект. Чтобы преобразовать строку в объект типа bytearray, необходимо передать минимум два
# первых параметра. Если строка указана только в первом параметре, то возбуждается исключение TypeError.
print('С помощью функции bytearray([<Строка>, <Кодировка> [, <Обработка ошибок>]]):')
print(bytearray())
print(bytearray('Строка', 'cp1251'))
# В третьем параметре могут быть указаны значения "strict" (при ошибке возбуждается исключение UnicodeEncodeError -
# значение по умолчанию), "replace" (неизвестный символ заменяется символом вопроса) или "ignore" (неизвестные
# символы игнорируются).
print(bytearray('string\uFFFD', 'cp1251', 'replace'))
print(bytearray('string\uFFFD', 'cp1251', 'ignore'))
# С помощью функции bytearray(<Последовательность>), которая преобразует последовательность целых чисел от 0 до 255 в
# объект типа bytearray. Если число не попадает в диапазон, то возбуждается исключение ValueError.
print('С помощью функции bytearray(<Последовательность>):')
b = bytearray([225, 226, 224, 174, 170, 160])
print(b)
print(bytearray(b'\xe1\xe2\xe0\xae\xaa\xa0'))
print(str(b, 'cp866'))
# С помощью функции bytearray(<Число>), которая задает количество элементов в последовательности. Каждый элемент
# будет содержать нулевой символ:
print('С помощью функции bytearray(<Число>):')
print(bytearray(5))
# С помощью метода bytearray.fromhex(<Строка>). Строка в этом случае должна содержать шестнадцатеричные значения
# символов:
print('С помощью метода bytearray.fromhex(<Строка>):')
b = bytearray.fromhex(' e1 e2e0ae aaa0 ')
print(b)
print(str(b, 'cp866'))
# Тип bytearray относится к изменяемым типам. Поэтому можно не только получить значение по индексу, но и изменить его
# (что не свойственно строкам):
b = bytearray('Python', 'ascii')
print(b)
print(b[0])     # Можем получить значение
b[0] = b'J'[0]  # Можем изменить значение
print(b)
# При изменении значения важно помнить, что присваиваемое значение должно быть целым числом в диапазоне от 0 до 255.
# Чтобы получить число в предыдущем примере, мы создали объект типа bytes, а затем присвоили значение, расположенное
# по индексу 0 (b[0] = b'J'[0]). Можно, конечно, сразу указать код символа, но ведь держать все коды символов в памяти
# свойственно компьютеру, а не человеку.
# Методы используемые для изменения объекта:
print('Методы используемые для изменения объекта:')
# append(<Число>) - добавляет один элемент в конец объекта. Метод изменяет текущий объект и ничего не возвращает.
print('append(<Число>) - добавляет один элемент в конец объекта:')
b = bytearray('string', 'ascii')
b.append(b'1'[0])
print(b)
# extend(<Последовательность>) - добавляет элементы последовательности в конец объекта. Метод изменяет текущий объект
# и ничего не возвращает.
print('extend(<Последовательность>) - добавляет элементы последовательности в конец объекта:')
b = bytearray('string', 'ascii')
b.extend(b'123')
print(b)
# Добавить несколько элементов можно с помощью операторов + и +=:
b = bytearray('string', 'ascii')
print(b + b'123')  # Возвращает новый объект
b += b'456'  # Изменяет текущий объект
print(b)
# Кроме того, можно воспользоваться операцией присваивания значения срезу:
b = bytearray('string', 'ascii')
b[len(b):] = b'123'  # Добавляем элементы в последовательность
print(b)
# insert(<Индекс>, <Число>) - добавляет один элемент в указанную позицию. Остальные элементы смещаются. Метод изменяет
# текущий объект и ничего не возвращает.
print('insert(<Индекс>, <Число>) - добавляет один элемент в указанную позицию:')
# Добавим элемент в начало объекта:
b = bytearray('string', 'ascii')
b.insert(0, b'1'[0])
print(b)
# Метод insert() позволяет добавить только один элемент. Чтобы добавить несколько элементов, можно воспользоваться
# операцией присваивания значения срезу. Добавим несколько элементов в начало объекта:
b = bytearray('string', 'ascii')
b[:0] = b'123'
print(b)
# рор([<Индекс>]) - удаляет элемент, расположенный по указанному индексу, и возвращает его. Если индекс не указан, то
# удаляет и возвращает последний элемент.
print('рор([<Индекс>]) - удаляет элемент, расположенный по указанному индексу, и возвращает его:')
b = bytearray('string', 'ascii')
b.pop()   # Удаляем последний элемент
print(b)
b.pop(0)  # Удаляем первый элемент
print(b)
# Удалить элемент списка позволяет также оператор del:
b = bytearray('string', 'ascii')
del b[5]   # Удаляем последний элемент
print(b)
del b[:2]  # Удаляем первый и второй элементы
print(b)
# remove(<Число>) - удаляет первый элемент, содержащий указанное значение. Если элемент не найден, возбуждается
# исключение ValueError. Метод изменяет текущий объект и ничего не возвращает.
print('remove(<Число>) - удаляет первый элемент, содержащий указанное значение:')
b = bytearray('strstr', 'ascii')
b.remove(b's'[0])  # Удаляет только первый элемент
print(b)
# reverse() - изменяет порядок следования элементов на противоположный. Метод изменяет текущий объект и ничего не
# возвращает.
print('reverse() - изменяет порядок следования элементов на противоположный:')
b = bytearray('string', 'ascii')
b.reverse()
print(b)
# Преобразовать объект типа bytearray в строку позволяет метод decode(). Метод имеет следующий формат:
# decode([encoding="utf-8"][, errors="strict"])
# Параметр encoding задает кодировку символов (по умолчанию UTF-8) в объекте bytearray, а параметр errors - способ
# обработки ошибок при преобразовании. В параметре errors можно указать значения "strict" (значение по умолчанию),
# "replace" или "ignore".
b = bytearray('строка', 'cp1251')
print(b.decode(encoding='cp1251'), b.decode('cp1251'))
# Для преобразования можно также воспользоваться функцией str():
b = bytearray('строка', 'cp1251')
print(str(b, 'cp1251'))


# 6.15 Преобразование объекта в последовательность байтов
print('Преобразование объекта в последовательность байтов:')
# Преобразовать объект в последовательность байтов (выполнить его сериализацию), а затем восстановить (десериализовать)
# объект позволяет модуль pikle. Прежде чем использовать функции из этого модуля, необходимо подключить модуль с помощью
# инструкции:
# import pickle
# Функции предназначенные для преобразования:
print('Функции предназначенные для преобразования:')
# dumps(<Объект>[, <Протокол>][, fix_imports=True]) - производит сериализацию объекта и возвращает последовательность
# байтов специального формата. Формат зависит от указанного протокола: число от 0 до 4 (поддержка протокола 4 появилась
# в Python 3.4). Если второй параметр не указан, будет использован протокол 4 для Python 3.4 или 3 - для предыдущих
# версий Python 3. Пример преобразования списка и кортежа:
print('dumps(<Объект>[, <Протокол>][, fix_imports=True]):')
obj1 = [1, 2, 3, 4, 5]  # Список
obj2 = (6, 7, 8, 9, 10)  # Кортеж
print(pickle.dumps(obj1))
print(pickle.dumps(obj2))
# loads(<Последовательность байтов>[, fix_imports=True][, encoding="ASCII"][, errors=" strict"]) - преобразует
# последовательность байтов специального формата
# обратно в объект, выполняя его десериализацию. Пример восстановления списка и кортежа:
print('lоаds(<Последовательность байтов>[, fix_imports=True][, encoding="ASCII"][, errors=" strict"]):')
print(pickle.loads(b'\x80\x03]q\x00(K\x01K\x02K\x03K\x04K\x05e.'))
print(pickle.loads(b'\x80\x03(K\x06K\x07K\x08K\tK\ntq\x00.'))


# 6.15 Шифрование строк
print('Шифрование строк:')
# Для шифрования строк предназначен модуль hashlib. Прежде чем использовать функции из этого модуля, необходимо
# подключить модуль с помощью инструкции:
# Модуль предоставляет следующие функции: md5 (), sha1(), sha224(), sha256(), sha384() и sha512(). В качестве
# необязательного параметра функциям: можно передать шифруемую последовательность байтов.
h = hashlib.sha1(b'password')
print(h)
# Передать последовательность байтов можно также с помощью метода update(). В этом случае объект присоединяется к
# предыдущему значению:
h = hashlib.sha1()
h.update(b'password')
print(h)
# Получить зашифрованную последовательность байтов и строку позволяют два метода: digest() и hexdigest(). Первый метод
# возвращает значение, относящееся к типу bytes, а второй - строку, содержащую шестнадцатеричные цифры.
h = hashlib.sha1(b'password')
print(h.digest())
print(h.hexdigest())
# Наиболее часто применяемой является функция md5(). которая шифрует строку с помощью алгоритма MD5. Эта функция
# используется для шифрования паролей. т. к. не существует алгоритма для дешифровки зашифрованных ей значений. Для
# сравнения введенного пользователем пароля с сохраненным в базе необходимо зашифровать введенный пароль. а затем
# произвести сравнение.
# import hashlib
h = hashlib.md5(b'password')
p = h.hexdigest()
print(p)  # Пароль, сохраненный в базе
h2 = hashlib.md5(b'password')  # Пароль, введенный пользователем
if p == h2.hexdigest():
    print('Правильный пароль')
# Свойство digest_size хранит размер значения, генерируемого описанными ранее функциями шифрования, в байтах:
h = hashlib.sha512(b'password')
print(h.digest_size)
# Поддерживается еще несколько функций, выполняющих устойчивое к взлому шифрование паролей:
# pbkdf2_hmac(<Основной алгоритм шифрования>, <Шифруемый пароль>, <'Соль'>, <Количество проходов шифрования>,
# dklen=None)
# В качестве основного алгоритма шифрования следует указать строку с наименованием этого алгоритма: 'md5', 'sha1',
# 'sha224', 'sha256', 'sha384' и 'sha512'. Шифруемый пароль указывается в виде значения типа bytes. 'Соль' - это
# особая величина типа bytes, выступающая в качестве ключа шифрования, - ее длина не должна быть менее 16 символов.
# Количество проходов шифрования следует указать достаточно большим (так, при использовании алгоритма SHA512 оно
# должно составлять 100000). Последним параметром функции pbkdf2_hmac() можно указать длину результирующего
# закодированного значения в байтах - если она не задана или равна None, будет создано значение стандартной для
# выбранного алгоритма длины (64 байта для алгоритма SHA512). Закодированный пароль возвращается в виде величины типа
# bytes.
dk = hashlib.pbkdf2_hmac('sha512', b'1234567', b'saltsaltsaltsalt', 100000)
print(dk)
# Примечание - Кодирование данных с применением функции pbkdf2_hmac() отнимает очень много системных ресурсов и может
# занять значительное время, особенно на маломощных компьютерах.
# В Python 3.6 появилась поддержка двух следующих функций:
# blake2s([<Шифруемый пароль>][, digest_size=32], [salt=b""]) - шифрует пароль по алгоритму BLAKE2s, оптимизированному
# для 32-разрядных систем. Второй параметр задает размер значения в виде числа от 1 до 32, третий - "соль" в виде
# величины типа bytes, которая может иметь в длину не более 8 байтов. Возвращает объект, хранящий закодированный пароль:
h = hashlib.blake2s(b'string', digest_size=16, salt=b"saltsalt")
print(h.digest())
# blake2b([<Шифруемый пароль>][, digest_size=64], [salt=b""]) - шифрует пароль no алгоритму BLAKE2b, оптимизированному
# для 64-разрядных систем. Второй параметр задает размер значения в виде числа от 1 до 64, третий - «соль» в виде
# величины типа bytes, которая может иметь в длину не более 16 байтов. Возвращает объект, хранящий закодированный
# пароль:
h = hashlib.blake2b(b"string", digest_size=48, salt=b"saltsaltsalt")
print(h.digest())
# Примечание - Функции blake2b() и blake2s() поддерживают большое количество параметров, которые применяются только в
# специфических случаях. Полное описание этих функций можно найти в документации по Python.
