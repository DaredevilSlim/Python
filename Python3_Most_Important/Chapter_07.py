#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re  # Подключение модуля re

# Глава 7
# Регулярные выражения
print('Регулярные выражения:')
# Регулярные выражения предназначены для выполнения в строке сложного поиска или замены. В языке Python использовать
# регулярные выражения позволяет модуль re. Прежде чем задействовать функции из этого модуля, необходимо подключить
# модуль с помощью инструкции:
# import re


# 7.1 Синтаксис регулярных выражений
print('Синтаксис регулярных выражений:')
# Создать откомпилированный шаблон регулярного выражения позволяет функция compile(). Функция имеет следующий формат:
# <Шаблон> = re.compile(<Регулярное выражение>[, <Модификатор>])
# В параметре <Модификатор> могут быть указаны следующие флаги (или их комбинация через оператор |):
# L или LOCALE     - учитываются настройки текущей локали;
# I или IGNORECASE - поиск без учета регистра
p = re.compile(r'^[а-яе]+$', re.I | re.U)
print('Найдено' if p.search('АБВГДЕЕ') else 'Нет')
p = re.compile(r'^[а-яе]+$', re.U)
print('Найдено' if p.search('АБВГДЕЕ') else 'Нет')
# M или MULTILINE - поиск в строке, состоящей из нескольких подстрок, разделенных символом новой строки ('\n').
# Символ ^ соответствует привязке к началу каждой подстроки, а символ $ - позиции перед символом перевода строки;
# S или DOTALL - метасимвол "точка" по умолчанию соответствует любому символу, кроме символа перевода строки (\n).
# Символу перевода строки метасимвол "точка" будет соответствовать в присутствии дополнительного модификатора.
# Символ ^ соответствует привязке к началу всей строки, а символ $ - привязке к концу всей строки.
p = re.compile(r'^.$')
print('Найдено' if p.search('\n') else 'Нет')
p = re.compile(r'^.$', re.M)
print('Найдено' if p.search('\n') else 'Нет')
p = re.compile(r'^.$', re.S)
print('Найдено' if p.search('\n') else 'Нет')
# X или VERBOSE- если флаг указан. то пробелы и символы перевода строки будут проигнорированы. Внутри регулярного
# выражения можно использовать и комментарии.
p = re.compile(r'''^      # Привязка к началу строки
                   [0-9]+ # Строка должна содержать одну цифру (или более)
                   $      # Привязка к концу строки
               ''', re.X | re.S)
print('Найдено' if p.search('1234567890') else 'Нет')
print('Найдено' if p.search('abcd123') else 'Нет')
# A или ASCII - классы \w, \W, \b, \B, \d, \D, \s и \S будут соответствовать символам в кодировке ASCII (по умолчанию
# перечисленные классы соответствуют Unicode-символам).
# U и UNICODE, включающие режим соответствия Unicode-символам классов \w, \W, \b, \B, \d, \D, \s и \S, сохранены в
# Python 3 лишь для совместимости с ранними версиями этого языка и никакого влияния на обработку регулярных выражений не
# оказывают.
# Как видно из примеров, перед всеми строками, содержащими регулярные выражения, указан модификатор r. Иными словами, мы
# используем неформатированные строки. Если модификатор не указать, то все слэши необходимо экранировать.
p = re.compile(r'^\w+$')
print('Найдено' if p.search('apple') else 'Нет')
p = re.compile('^\\w+$')
print('Найдено' if p.search('apple') else 'Нет')
# Внутри регулярного выражения символы ., ^, $, *, +, ?, {, }, [, ], \, |, ( и ) имеют специальное значение. Если эти
# символы должны трактоваться как есть, их следует экранировать с помощью слэша. Некоторые специальные символы теряют
# свое особое значение, если их разместить внутри квадратных скобок, - в этом случае экранировать их не нужно. Например,
# как уже было отмечено ранее, метасимвол "точка" по умолчанию соответствует любому символу, кроме символа перевода
# строки. Если необходимо найти именно точку, то перед точкой нужно указать символ \ или разместить точку внутри
# квадратных скобок: [.].
# В примере test_00032.py мы осуществляли привязку к началу и концу строки с помощью следующих метасимволов:
# ^ - привязка к началу строки или подстроки. Она зависит от флагов M (или МULTILINE) и S (ИЛИ DOТALL);
# $ - привязка к концу строки или подстроки. Она зависит от флагов M (или МULTILINE) и S (ИЛИ DOТALL);
# \А - привязка к началу строки (не зависит от модификатора);
# \Z - привязка к концу строки (не зависит от модификатора).
# Если в параметре <Модификатор> указан флаг M (или МULTILINE), то поиск производится в строке, состоящей из нескольких
# подстрок, разделенных символом новой строки (\n). В этом случае символ ^ соответствует привязке к началу каждой
# подстроки, а символ $ - позиции перед символом перевода строки.
p = re.compile(r'^.+$')  # Точка не соответствует \n
print(p.findall('str1\nstr2\nstr3'))  # Ничего не найдено
p = re.compile(r'^.+$', re.S)  # Теперь точка соответствует \n
print(p.findall('str1\nstr2\nstr3'))  # Строка полностью соответствует
p = re.compile(r'^.+$', re.M)  # Многострочный режим
print(p.findall('str1\nstr2\nstr3'))  # Получили каждую подстроку
# Привязку к началу и концу строки следует использовать, если строка должна полностью соответствовать регулярному
# выражению (test_00033.py).
# Если убрать привязку к началу и концу строки, то любая строка, содержащая хотя бы одну цифру, будет распознана как
# число (test_00034.py).
# Кроме того, можно указать привязку только к началу или только к концу строки (test_00035.py).
# Поддерживаются также два метасимвола, позволяющие указать привязку к началу или концу слова:
# \Ь - привязка к началу слова (началом слова считается пробел или любой символ, не являющийся буквой, цифрой или знаком
# подчеркивания);
# \В - привязка к позиции, не являющейся началом слова.
# Рассмотрим несколько примеров:
p = re.compile(r'\bpython\b')
print('Найдено' if p.search('python') else 'Нет')
print('Найдено' if p.search('pythonware') else 'Нет')
p = re.compile(r'\Bth\B')
print('Найдено' if p.search('python') else 'Нет')
print('Найдено' if p.search('this') else 'Нет')
# В квадратных скобках [] можно указать символы, которые могут встречаться на этом месте в строке. Можно перечислить
# символы подряд или указать диапазон через дефис:
# [09]                - соответствует числу 0 или 9;
# [0-9]               - соответствует любому числу от 0 до 9;
# [абв]               - соответствует буквам "а", "б" и "в";
# [а-г]               - соответствует буквам "а", "б", "в" и "г";
# [а-яё]              - соответствует любой букве от "а" до "я";
# [АБВ]               - соответствует буквам "А", "Б" и "В";
# [А-ЯЁ]              - соответствует любой букве от "А" до "Я";
# [а-яА-ЯёЁ]          - соответствует любой русской букве в любом регистре;
# [О-9а-яА-ЯёЁa-zA-Z] - любая цифра и любая буква независимо от регистра и языка.
# Внимание! - Буква ё не входит в диапазон а-я, а буква Ё в диапазон А-Я.
# Значение в скобках инвертируется, если после первой скобки вставить символ ^. Таким образом можно указать символы
# которых не должно быть на этом месте в строке:
# [^09]            - не цифра 0 или 9;
# [^0-9]           - не цифра от 0 до 9;
# [а-яА-ЯёЁa-zA-Z] - не буква.
# Точка теряет свое специальное значение, если ее заключить в квадратные скобки. Кроме того, внутри квадратных скобок
# могут встретится символы, которые имеют специальное значение (например, ^ и -). Символ ^ теряет свое специальное
# значение если он не расположен сразу после открывающей квадратной скобки. Чтобы отменить специальное значение
# символа -, его следует указать после перечисления всех символов, перед закрывающей квадратной скобкой или сразу после
# открывающей квадратной скобки. Все специальные символы можно сделать обычными, если перед ними указывать символ \ .
# Метасимвол | позволяет сделать выбор между альтернативными значениями. Выражение n|m соответствует одному из символов
# n илии m.
p = re.compile(r'красн((ая)|(ое))')
print('Найдено' if p.search('красная') else 'Нет')
print('Найдено' if p.search('красное') else 'Нет')
print('Найдено' if p.search('красный') else 'Нет')
# Вместо перечисления символов можно использовать стандартные классы:
# \d - соответствует любой цифре. При указании флага A(ASCII) эквивалентно [0-9]
# \w - соответствует любой букве, цифре или символу подчеркивания. При указании флага A(ASCII) эквивалентно [a-zA-Z0-9_]
# \s - любой пробельный символ. При указании флага A(ASCII) эквивалентно [\t\n\r\f\v]
# \D - не цифра. При указании флага A(ASCII) эквивалентно [^0-9]
# \W - не буква, не цифра и не символ подчеркивания. При указании флага A(ASCII) эквивалентно [^a-zA-Z0-9_]
# \S - не пробельный символ. При указании флага A(ASCII) эквивалентно [^\t\n\r\f\v]
# Примечание - В Python 3 поддержка Unicode в регулярных выражениях установлена по умолчанию. При этом все классы
# трактуются гораздо шире. Так, класс \d соответствует не только десятичным цифрам, но и другим цифрам из кодировки
# Unicode, например дробям, класс \w включает не только латинские буквы, но и любые другие, а класс \s охватывает также
# неразрывные пробелы. Поэтому на практике лучше явно указывать символы внутри квадратных скобок, а не использовать
# классы.
# Количество вхождений символа в строку задается с помощью квантификаторов:
# {n} - n вхождений символа в строку. Например, шаблон r'^[0-9]{2}$' соответствует двум вхождениям любой цифры;
# {n,} - n или более вхождений символа в строку. Например, шаблон r'^[0-9]{2,}$' соответствует двум и более вхождениям
# любой цифры;
# {n,m} - не менее n и не более m вхождений символа в строку. Например, шаблон r'^[0-9]{2,4}$' соответствует от двух до
# четырех вхождений любой цифры;
# * - ноль или большее число вхождений символа в строку. Эквивалентно комбинации {0,};
# + - одно или большее число вхождений символа в строку. Эквивалентно комбинации {1,};
# ? - ни одного или одно вхождение символа в строку. Эквивалентно комбинации {0,1};
# Все квантификаторы являются "жадными". При поиске соответствия ищется самая длинная подстрока, соотвтетствующая
# шаблону, и не учитываются более короткие соответствия.
# Получение содержимого всех тегов <b>:
s = '<b>Text1</b>Text2<b>Text3</b>'
p = re.compile(r'<b>.*</b>', re.S)
print(p.findall(s))
# Чтобы ограничить "жадность", необходимо после квантификатора указать символ ?
s = '<b>Text1</b>Text2<b>Text3</b>'
p = re.compile(r'<b>.*?</b>', re.S)
print(p.findall(s))
# Если необходимо получить содержимое без тэгов, то нужный фрагмент внутри шаблона следует разместить внутри круглых
# скобок.
# Получение содержимого всех тегов <b> без самих тэгов:
s = '<b>Text1</b>Text2<b>Text3</b>'
p = re.compile(r'<b>(.*?)</b>', re.S)
print(p.findall(s))
# Круглые скобки часто используются для группировки фрагментов внутри шаблона. В этом случае не требуется, чтобы
# фрагмент запоминался и был доступен в результатах поиска. Чтобы избежать захвата фрагмента, следует после открывающей
# круглой скобки разместить символ ?
# Получение списка с двумя элементами. Каждый элемент списка является кортежем, содержащем четыре элемента. Все эти
# элементы соответствуют фрагментам, заключенным в шаблоне в круглые скобки. Первый элемент кортежа содержит фрагмент,
# расположенный в первых круглых скобках, второй во вторых круглых скобках.
s = 'test text'
p = re.compile(r'([a-z]+((st)|(xt)))', re. S)
print(p.findall(s))
# Три последних элемента кортежа являются лишними. Чтобы они не выводились в результатах, мы добавили символ ?: после
# каждой открывающей круглой скобки. В результате список состоит только из фрагментов, полностью соответствующих
# регулярному выражению.
s = 'test text'
p = re.compile(r'([a-z]+(?:(?:st)|(?:xt)))', re. S)
print(p.findall(s))
# К найденному фрагменту в круглых скобках внутри шаблона можно обратиться с помощью механизма обратных ссылок. Для
# этого порядковый номер круглых скобок в шаблоне указывается после слэша - например так \1. Нумерация скобок внутри
# шаблона начинается с 1.
# Получение текста между одинаковыми парными тегами:
s = '<b>Text1</b>Text2<I>Text3</I><b>Text4</b>'
p = re.compile(r'<([a-z]+)>(.*?)</\1>', re.S | re.I)
print(p.findall(s))
# Фрагментам в круглых скобках можно дать имена. Для этого после открывающей круглой скобки следует указать комбинацию
# символов ?P<name>.
# Разбор e-mail на составные части:
email = 'test@mail.ru'
p = re.compile(r'''(?P<name>[a-z0-9_.-]+)  # Название ящика
    @                                      # Символ '@"
    (?P<host>(?:[a-z0-9-]+\.)+[a-z]{2,6})  # Домен
    ''', re.I | re.VERBOSE)
r = p.search(email)
print(r.group('name'))  # Название ящика
print(r.group('host'))  # Домен
# Чтобы внутри шаблона обратится к именованным фрагментам, используется следующий синтаксис: (?P=name).
# Текст между одинаковыми парными тегами:
s = '<b>Text1</b>Text2<I>Text3</I>'
p = re.compile(r'<(?P<tag>[a-z]+)>(.*?)</(?P=tag)>', re.S | re.I)
print(p.findall(s))
# Кроме того, внутри круглых скобок могут быть расположены следующие конструкции:
# (?aiLmsux) - позволяет установить опции регулярного выражения. Буквы a, i, L, m, s, u и x имеют такое же назначение,
# что и одноименные модификаторы в функции compile();
# (?#...) - комментарий. Текст внутри круглых скобок игнорируется;
# (?=...) - положительный просмотр вперед.
# Вывод всех слов, после которых расположена запятая:
s = 'text1, text2, text3 text4'
p = re.compile(r'\w+(?=[,])', re.S | re.I)
print(p.findall(s))
# (?!...) - отрицательный просмотр вперед.
# Вывод всех слов, после которых нет запятой:
s = 'text1, text2, text3 text4'
p = re.compile(r'[a-z]+[0-9](?![,])', re.S | re.I)
print(p.findall(s))
# (?<=...) - положительный просмотр назад.
# Вывод всех слов, перед которыми расположена запятая с пробелом:
s = 'text1, text2, text3 text4'
p = re.compile(r'(?<=[,][ ])[a-z]+[0-9]', re.S | re.I)
print(p.findall(s))
# (?<!...) - отрицательный просмотр назад.
# Вывод всех слов, перед которыми расположен пробел, но перед пробелом нет запятой:
s = 'text1, text2, text3 text4'
p = re.compile(r'(?<![,]) ([a-z]+[0-9])', re.S | re.I)
print(p.findall(s))
# (?(id  name) шаблон1|шаблон2) - если группа с номером или названием найдена, то должно выполнятся условие из щаблон1,
# в противном случае должно выполняться условие из шаблон2.
# Вывод всех слов, которые расположены внутри апострофов. Если перед словом нет апострофа, то в конце слова должна быть
# запятая:
s = "text1 'text2' 'text3 text4, text5"
p = re.compile(r"(')?([a-z]+[0-9])(?(1)'|,)", re.S | re.I)
print(p.findall(s))
# (?aiLmsux) - позволяет установить опции регулярного выражения. Буквы a, i, l , m, s, u и x имеют такое же назначение,
# что и одноименные модификаторы в функции compile().
# Внимание! - Начиная с Python 3.6, опции, задаваемые внутри регулярного выражения в круглых скобках, объявлены
# устаревшими и не рекомендованными к использованию. В будущих версиях Python их поддержка будет удалена.
# Вывод всех слов, расположенных после дефиса, причем перед дефисом и после слов должны следовать пробельные символы:
s = '-word1 -word2 -word3 -word4 -word5'
p = re.compile(r'(?:^|\s)\-([a-z]+[0-9])(?=\s|$)', re.S | re.I)
print(p.findall(s))
# Как видно из примера, мы получили только два слова вместо пяти. Первое и последнее слова не попали в результат, т. к.
# расположены в начале и в конце строки. Чтобы эти слова попали в результат, необходимо добавить альтернативный выбор
# (^|\s) - для начала строки и (\s|$) - для конца строки. Чтобы найденные выражения внутри круглых скобок не попали в
# результат, следует добавить символы ?: после открывающей скобки:
re.findall(r'(?:^|\s)\-([a-z0-9]+)(?:\s|$)', s, re.S | re.I)
# Здесь первое и последнее слова успешно попали в результат. Почему же слова word2 и word4 не попали в список совпадений
# - ведь перед дефисом есть пробел и после слова есть пробел? Чтобы понять причину, рассмотрим поиск по шагам. Первое
# слово успешно попадает в результат, т. к. перед дефисом расположено начало строки, и после слова есть пробел. После
# поиска указатель перемещается, и строка для дальнейшего поиска примет следующий вид:
# '-word1 <Указатель>-word2 -word3 -word4 -wordS'
# Обратите внимание на то, что перед фрагментом -word2 больше нет пробела, и дефис не расположен в начале строки.
# Поэтому следующим совпадением окажется слово word3, и указатель снова будет перемещен:
# '-word1 -word2 -word3 <Указатель>-word4 -wordS'
# Опять перед фрагментом -word4 нет пробела, и дефис не расположен в начале строки. По­ этому следующим совпадением
# окажется слово word5, и поиск будет завершен. Таким обра­зом, слова word2 и word4 не попадают в результат, поскольку
# пробел до фрагмента уже был использован в предыдущем поиске. Чтобы этого избежать, следует воспользоваться
# положительным просмотром вперед (?= ...):
re.findall(r'(?:^|\s)\-([a-z0-9]+)(?=\s|$)', s, re.S | re.I)
# В этом примере мы заменили фрагмент (?:\s|$) на (?=\s|$). Поэтому все слова успешно попали в список совпадений.


# 7.2 Поиск первого совпадения с шаблоном
print('Поиск первого совпадения с шаблоном:')
# Для поиска первого совпадения с шаблоном предназначены следующие функции и методы:
# match() - проверяет соответствие с началом строки. Формат метода:
# match(<Строка>[, <Начальная позиция>[, <Конечная позиция>]])
# Если соответствие найдено, то возвращается объект Match, в противном случае возвращается значение None.
p = re.compile(r'[0-9]+')
print('Найдено' if p.match('str123') else 'Нет')
print('Найдено' if p.match('str123', 3) else 'Нет')
print('Найдено' if p.match('123str') else 'Нет')
# Вместо метода match() можно воспользоваться функцией match(). Формат функции:
# re.match(<Шаблон>, <Строка>[, <Модификатор>])
# В параметре <Шаблон> указывается строка с регулярным выражением или скомпилированное регулярное выражение. В параметре
# <Модификатор> можно указать флаги, используемые в функции compile()
# Если соответствие найдено, то возвращается объект Match, в противном случае возвращается значение None.
p = r'[0-9]+'
print('Найдено' if re.match(p, 'str123') else 'Нет')
print('Найдено' if re.match(p, '123str') else 'Нет')
p = re.compile(r'[0-9]+')
print('Найдено' if re.match(p, '123str') else 'Нет')
# search() - проверяет соответствие с любой частью строки. Формат метода:
# search(<Строка>[, <Начальная позиция>[, <Конечная позиция>]])
# Если соответствие найдено, то возвращается объект Match, в противном случае возвращается значение None.
p = re.compile(r'[0-9]+')
print('Найдено' if p.search('str123') else 'Нет')
print('Найдено' if p.search('123str') else 'Нет')
print('Найдено' if p.search('123str', 3) else 'Нет')
# Вместо метода search() можно воспользоваться функцией search(). Формат функции:
# re.search(<Шаблон>, <Строка>[, <Модификатор>])
# В параметре <Шаблон> указывается строка с регулярным выражением или скомпилированное регулярное выражение. В параметре
# <Модификатор> можно указать флаги, используемые в функции compile()
# Если соответствие найдено, то возвращается объект Match, в противном случае возвращается значение None.
p = r'[0-9]+'
print('Найдено' if re.search(p, 'str123') else 'Нет')
p = re.compile(r'[0-9]+')
print('Найдено' if re.search(p, 'str123') else 'Нет')
# fullmatch() - выполняет проверку, соответствует ли переданная строка регулярному выражению целиком. Формат:
# fullmatch(<Строка>[, <Начальная позиция>[, <Конечная позиция>]])
# Если соответствие найдено, то возвращается объект Match, в противном случае возвращается значение None.
p = re.compile(r'[Pp]ython')
print('Найдено' if p.fullmatch('Python') else 'Нет')
print('Найдено' if p.fullmatch('py') else 'Нет')
print('Найдено' if p.fullmatch('PythonWare') else 'Нет')
print('Найдено' if p.fullmatch('PythonWare', 0, 6) else 'Нет')
# Вместо метода fullmatch() можно воспользоваться функцией fullmatch(). Формат функции:
# re.fullmatch(<Шаблон>, <Строка>[, <Модификатор>])
# В параметре <Шаблон> указывается строка с регулярным выражением или скомпилированное регулярное выражение. В параметре
# <Модификатор> можно указать флаги, используемые в функции compile()
# Если соответствие найдено, то возвращается объект Match, в противном случае возвращается значение None.
p = r'[Pp]ython'
print('Найдено' if re.fullmatch(p, 'Python') else 'Нет')
print('Найдено' if re.fullmatch(p, 'py') else 'Нет')
# В качестве примера переделаем нашу программу суммирования произвольного количества целых чисел, введенных
# пользователем (test_00028.py), таким образом, чтобы при вводе строки вместо числа программа не завершалась фатальной
# ошибкой. Предусмотрим также возможность ввода отрицательных целых чисел (test_00036.py).
# Объект Match, возвращаемый методами (функциями) match() и search(), имеет следующие свойства и методы:
# re - ссылка на скомпилированный шаблон, указанный в методах (функциях) match() и search(). Через эту ссылку доступны
# следующие свойства:
# - groups     - количество групп в шаблоне;
# - groupindex - словарь с названиями групп и их номерами;
# - pattern    - исходная строка в регулярном выражении;
# - flags      - комбинация флагов, заданных при создании регулярного выражения в функции compile(), и флагов,
# указанных в самом регулярном выражении, в конструкции (&aiLmsux);
# string - значение параметра <Строка> в методах (функциях) match() и search();
# pos - значение параметра <Начальная позиция> в методах (функциях) match() и search();
# endpos - значение параметра <Конечная позиция> в методах (функциях) match() и search();
# lastindex - возвращает номер последней группы или значение None, если поиск завершился неудачей;
# lastgroup - возвращает номер последней группы или значение None, если эта группа не имеет имени, или поиск завершился
# неудачей;
p = re.compile(r'(?P<num>[0-9]+)(?P<str>[a-z]+)')
m = p.search('123456string 67890text')
print(m.re.groups, m.re.groupindex)
print(p.groups, p.groupindex)
print(m.string)
print(m.lastindex, m.lastgroup)
print(m.pos, m.endpos)
# group([<id1 или name1>[, ... , <idN или nameN> ]]) - возвращает фрагменты, соответствующие шаблону. Если параметр не
# задан или указано значение 0, возвращается фрагмент, полностью соответствующий шаблону. Если указан номер или
# название группы, возвращается фрагмент, совпадающий с этой группой. Через запятую можно указать несколько номеров или
# названий групп - в этом случае возвращается кортеж, содержащий фрагменты, что соответствуют группам. Если нет группы
# с указанным номером или названием, то возбуждается исключение IndexError.
p = re.compile(r'(?P<num>[0-9]+)(?P<str>[a-z]+)')
m = p.search('123456string 67890text')
print(m.group(), m.group(0))                 # Полное соответствие шаблону
print(m.group(1), m.group(2))                # Обращение по индексу
print(m.group('num'), m.group('str'))        # Обращение по названию
print(m.group(1, 2), m.group('num', 'str'))  # Несколько параметров
# groupdict([<Значение по умолчанию>]) - возвращает словарь, содержащий значения именованных групп. С помощью
# необязательного параметра можно указать значение, которое будет выводиться вместо значения None для групп, не имеющих
# совпадений:
p = re.compile(r'(?P<num>[0-9]+)(?P<str>[a-z]+)?')
m = p.search('123456')
print(m.groupdict())
print(m.groupdict(''))
# groups([<Значение по умолчанию>]) - возвращает кортеж, содержащий значения всех групп. С помощью необязательного
# параметра можно указать значение, которое будет выводиться вместо значения None для групп, не имеющих совпадений:
p = re.compile(r'(?P<num>[0-9]+)(?P<str>[a-z]+)?')
m = p.search('123456')
print(m.groups())
print(m.groups(''))
# start([<Номер или название группы>]) - возвращает индекс начала фрагмента, соответствующего заданной группе. Если
# параметр не указан, то фрагментом является полное соответствие с шаблоном. Если соответствия нет, то возвращается
# значение -1;
# end([<Номер или название группы>]) - возвращает индекс конца фрагмента, соответствующего заданной группе. Если
# параметр не указан, то фрагментом является полное соответствие с шаблоном. Если соответствия нет, то возвращается
# значение -1;
# span([<Номер или название группы>]) - возвращает кортеж, содержащий начальный и конечный индексы фрагмента,
# соответствующего заданной группе. Если параметр не указан, то фрагментом является полное соответствие с шаблоном.
# Если соответствия нет, то возвращается значение (-1, -1);
p = re.compile(r'(?P<num>[0-9]+)(?P<str>[a-z]+)?')
s = 'str123456str'
m = p.search(s)
print(m.start(), m.end(), m.span())
print(m.start(1), m.end(1), m.start('num'), m.end('num'))
print(m.start(2), m.end(2), m.start('str'), m.end('str'))
print(m.span(1), m.span('num'), m.span(2), m.span('str'))
print(s[m.start(1):m.end(1)], s[m.start(2):m.end(2)])
# expand(<Шаблон>) - производит замену в строке. Внутри указанного шаблона можно использовать обратные ссылки:
# \номер группы, \g<номер группы> и \g<название группы>.
# Для примера поменяем два тега местами:
p = re.compile(r'<(?P<tag1>[a-z]+)><(?P<tag2>[a-z]+)>')
m = p.search('<br><hr>')
print(m.expand(r'<\2><\1>'))              # \номер
print(m.expand(r'<\g<2>><\g<1>>'))        # \g<номер>
print(m.expand(r'<\g<tag2>><\g<tag1>>'))  # \g<название>
# В качестве примера использования метода search() проверим на соответствие шаблону введенный пользователем адрес
# электронной почты (test_00037.py).


# 7.3 Поиск всех совпадений с шаблоном
print('Поиск всех совпадений с шаблоном:')
# Для поиска всех совпадений с шаблоном предназначено несколько функций и методов.
# Метод findall() ищет все совпадения с шаблоном. Формат метода:
# findall(<Строк>[, <Начальная позиция>[, <Конечная позиция:>]])
# Если соответствия найдены, возвращается список с фрагментами, в противном случае возвращается пустой список. Если
# внутри шаблона есть более одной группы, то каждый элемент списка будет кортежем, а не строкой.
p = re.compile(r'[0-9]+')
print(p.findall('2007, 2008, 2009, 2010, 2011'))
p = re.compile(r'[a-z]+')
print(p.findall('2007, 2008, 2009, 2010, 2011'))
t = r'(([0-9]{3})-([0-9]{2})-([0-9]{2}))'
p = re.compile(t)
print(p.findall('322-77-20, 528-22-98'))
# Вместо метода findall() можно воспользоваться функцией findall(). Формат функции:
# re.findall(<Шаблон>, <Строка> [, <Модификатор>])
# В параметре <Шаблон> указывается строка с регулярным выражением или скомпилированное регулярное выражение. В
# параметре <Модификатор> можно указать флаги, используемые в функции compile().
print(re.findall(r'[0-9]+', '1 2 3 4 5 6'))
p = re.compile(r'[0-9]+')
print(re.findall(p, '1 2 3 4 5 6'))
# Метод finditer() аналогичен методу findall(), но возвращает итератор, а не список. На каждой итерации цикла
# возвращается объект Match. Формат метода:
# finditer(<Строка>[, <Начальная позиция>[, <Конечная позиция>]])
p = re.compile(r'[0-9]+')
for m in p.finditer('2007, 2008, 2009, 2010, 2011'):
    print(m.group(0), 'start:', m.start(), 'end:', m.end())
# Вместо метода finditer() можно воспользоваться функцией finditer(). Формат функции:
# re.finditer(<Шаблон>, <Строка>[, <Модификатор>])
# В параметре <Шаблон> указывается строка с регулярным выражением или скомпилированное регулярное выражение. В
# параметре <Модификатор> можно указать флаги, используемые в функции compile(). Получим содержимое между тегами:
p = re.compile(r'<b>(.+?)</b>', re.I | re.S)
s = '<b>Text1</b>Text2<b>Text3</b>'
for m in re.finditer(p, s):
    print(m.group(1))


# 7.4 Замена в строке
print('Замена в строке:')
# Метод sub() ищет все совпадения с шаблоном и заменяет их указанным значением. Если совпадения не найдены, возвращается
# исходная строка. Метод имеет следующий формат:
# sub(<Новый фрагмент или ссылка на функцию>, <Строка для замены> [, <Максимальное количество замен>])
# Внутри нового фрагмента можно использовать обратные ссылки \номер группы, \g<номер группы> и \g<название группы>.
# Для примера поменяем два тега местами:
p = re.compile(r'<(?P<tag1>[a-z]+)><(?P<tag2>[a-z]+)>')
print(p.sub(r'<\2><\1>', '<br><hr>'))  # \номер
print(p.sub(r'<\g<2>><\g<1>>', '<br><hr>'))  # \g<номер>
print(p.sub(r'<\g<tag2>><\g<tag1>>', '<br><hr>'))  # \g<>
# В качестве первого параметра можно указать ссылку на функцию. В эту функцию будет передаваться объект Match,
# соответствующий найденному фрагменту. Результат, возвращаемый этой функцией, служит фрагментом для замены. Для
# примера найдем все числа в строке и прибавим к ним число 10 (test_00038.py):
# Вместо метода sub() можно воспользоваться функцией sub(). Формат функции:
# rе.sub(<Шаблон>, <Новый фрагмент или ссылка на функцию>, <Строка для замены>
#       [, <Максимальное количество замен> [, flags=O]])
# В качестве параметра <Шаблон> можно указать строку с регулярным выражением или скомпилированное регулярное выражение.
# Поменяем два тега местами, а также изменим регистр букв (test_00039.py):
# Метод subn() аналогичен методу sub(), но возвращает не строку, а кортеж из двух эле­ментов:
# измененной строки и количества произведенных замен. Метод имеет следующий формат:
# subn(<Новый фрагмент или ссылка на функцию>, <Строка для замены>[, <Максимальное количество замен>])
# Заменим все числа в строке на 0:
p = re.compile(r'[0-9]+')
print(p.subn('0', '2008, 2009, 2010, 2011'))
# Вместо метода subn() можно воспользоваться функцией subn(). Формат функции:
# rе.subn(<Шаблон>, <Новый фрагмент или ссылка на функцию>, <Строка для замены>
#        [, <Максимальное количество замен> [, flags=O]])
# В качестве параметра <Шаблон> можно указать строку с регулярным выражением или скомпилированное регулярное выражение.
p = r'200[79]'
print(re.subn(p, '2001', '2007, 2008, 2009, 2010'))
# Для выполнения замен также можно использовать метод expand(), поддерживаемый объектом Match. Формат метода:
# expand(<Шаблон>)
# Внутри указанного шаблона можно использовать обратные ссылки: \номер группы, \g<номер группы> и \g<название группы>.
p = re.compile(r'<(?P<tag1>[a-z]+)><(?P<tag2>[a-z]+)>')
m = p.search('<br><hr>')
print(m.expand(r'<\2><\1>'))              # \номер
print(m.expand(r'<\g<2>><\g<1>>'))        # \g<номер>
print(m.expand(r'<\g<tag2>><\g<tag1>>'))  # \g<название>


# 7.5 Прочие функции и методы
# Метод split() разбивает строку по шаблону и возвращает список подстрок. Его формат:
# split(<Исходная строка>[, <Лимит>])
# Если во втором параметре задано число, то в списке окажется указанное количество под­строк. Если подстрок больше
# указанного количества, то список будет содержать еще один элемент - с остатком строки.
p = re.compile(r'[\s,.]+')
print(p.split('word1, word2\nword3\r\nword4.word5'))
print(p.split('word1, word2\nword3\r\nword4.word5', 2))
# Если разделитель в строке не найден, то список будет состоять только из одного элемента, содержащего исходную строку:
p = re.compile(r'[0-9]+')
print(p.split('word, word\nword'))
# Вместо метода split() можно воспользоваться функцией split(). Формат функции:
# rе.split(<Шаблон>, <Исходная строка>[, <Лимит>[, flags=O]])
# В качестве параметра <Шаблон> можно указать строку с регулярным выражением или скомпилированное регулярное выражение.
p = re.compile(r'[\s,.]+')
print(re.split(p, 'word1, word2\nword3'))
print(re.split(r'[\s,.]+', 'word1, word2\nword3'))
# Функция escape(<Строка>) позволяет экранировать все специальные символы в строке, полученной от пользователя.
# Эту строку в дальнейшем можно безопасно использовать внутри регулярного выражения.
print(re.escape(r'[]().*'))
# \[\)\(\)\.\•
# Функция purge() выполняет очистку кэша, в котором хранятся промежуточные данные, используемые в процессе выполнения
# регулярных выражений. Ее рекомендуется вызывать после обработки большого количества регулярных выражений.
# Результата эта функция не возвращает.
re.purge()
