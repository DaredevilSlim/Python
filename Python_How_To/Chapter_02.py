#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re  # Импорт модуля re

# Глава 2
# Обработка и формирование строк
print('Обработка и формирование строк')


# 2.1. КАК ИСПОЛЬЗОВАТЬ F-СТРОКИ ДЛЯ ИНТЕРПОЛЯЦИИ И ФОРМАТИРОВАНИЯ
print('2.1. КАК ИСПОЛЬЗОВАТЬ F-СТРОКИ ДЛЯ ИНТЕРПОЛЯЦИИ И ФОРМАТИРОВАНИЯ')


# 2.1.1. Форматирование строк до появления f-строк
print('2.1.1. Форматирование строк до появления f-строк')
# Класс str работает с текстовыми данными через свои экземпляры, которые мы будем называть строковыми переменными.
# Помимо строковых переменных, в текстовую информацию также часто включаются такие типы данных, как целые числа и числа
# с плавающей точкой. Теоретически мы могли бы преобразовать нестроковые данные в строки и соединить их для получения
# нужного текстового вывода, как показано в листинге test_0001.py.
# Методами обычно называются функции, определяемые в классах. В данном случае функция format определяется в классе str,
# поэтому этот метод вызывается для экземпляров str.


# 2.1.2. Использование f-строк для интерполяции переменных
print('2.1.2. Использование f-строк для интерполяции переменных')
# Форматирование строк часто подразумевает объединение строковых литералов и переменных разных типов (например, целых
# чисел и строк). При интеграции переменных в f-строку можно интерполировать эти переменные, чтобы они автоматически
# преобразовывались в строки нужного вида.
# Для начала рассмотрим, как использовать f-строки при создании вывода, представленного в листинге 2.1 (test_0001.py).
name = 'Homework'
urgency = 5
task_f = f'Name: {name}; Urgency Level: {urgency}'
assert task_f == 'Name: Homework; Urgency Level: 5'
# В этом примере переменная task_f создается с применением f-строк. Главное, на что следует обратить внимание, —
# фигурные скобки, в которые заключаются интерполируемые переменные. Так как f-строки интегрируют механизм строковой
# интерполяции, они также называются интерполируемыми строковыми литералами.
# Термин «строковая интерполяция» (string interpolation) не относится к специфике Python, этот механизм присутствует
# в большинстве основных современных языков (таких, как JavaScript, Swift и C#). В общем случае он предоставляет более
# компактный и удобочитаемый синтаксис для создания отформатированных строк, чем конкатенация строк и альтернативные
# способы их форматирования.
# Инструкция assert
# Ключевое слово Python assert используется для проверок (ассертов), которые вычисляют заданное условие. Если результат
# равен True, программа продолжает выполняться. Если же результат равен False, выполнение прерывается, а программа
# выдает ошибку AssertionError.
tasks = ['homework', 'laundry']
assert f'Tasks: {tasks}' == "Tasks: ['homework', 'laundry']"  # Интерполирует объект списка
task_hwk = ('Homework', 'Complete physics work')
assert f'Task: {task_hwk}' == "Task: ('Homework', 'Complete physics work')"  # Интерполирует объект кортежа
task = {'name': 'Laundry', 'urgency': 3}
assert f'Task: {task}' == "Task: {'name': 'Laundry', 'urgency': 3}"  # Интерполирует объект словаря


# 2.1.3. Использование f-строк для интерполяции выражений
print('2.1.3. Использование f-строк для интерполяции выражений')
# На более общем уровне f-строки также могут интерполировать выражения, что избавляет вас от необходимости создания
# промежуточных переменных. Например, при создании строкового вывода можно обратиться к элементу объекта dict или
# использовать результат вызова функции. В таких распространенных ситуациях можно включить эти выражения в f-строки, как
# показывает следующий фрагмент кода:
tasks = ["homework", "laundry", "grocery shopping"]
assert f"First Task: {tasks[0]}" == 'First Task: homework'  # Обращается к элементу списка
task_name = "grocery shopping"
assert f"Task Name: {task_name.title()}" == 'Task Name: Grocery Shopping'  # Вызывает функцию
number = 5
assert f"Square: {number * number}" == 'Square: 25'  # Прямые вычисления
# Эти выражения заключаются в фигурные скобки, чтобы f-строки напрямую вычислили их для получения нужного строкового
# вывода: {tasks[0]} -> "homework";
# {task_name.title()} -> "Grocery Shopping";
# {number * number} -> 25.
# В тексте часто встречается термин «выражение» (expression), относящийся к числу ключевых понятий программирования.
# Начинающие программисты могут путать его со связанным понятием — инструкцией (statement). Выражение обычно
# представляет собой одну строку кода (хотя может занимать несколько строк при заключении в тройные кавычки),
# результатом вычисления которой является значение объекта, например строки или экземпляра нестандартного класса. Из
# этого определения легко выводится, что переменные являются разновидностями выражений.
# С другой стороны, инструкции не создают никакого значения или объекта. Цель инструкции заключается в выполнении
# некоторого действия. Например, ключевое слово assert создает проверочную инструкцию (или команду), которая проверяет
# выполнение некоторого условия, прежде чем процесс продолжится. Мы не пытаемся получить логическое значение True или
# False, а проверяем условие.
# Различия между выражениями и инструкциями. Выражения представляют некие вычисления, в результате которых получается
# значение или объект, тогда как инструкция выполняет конкретные действия и не может вычисляться для получения значения.
# Хотя f-строки поддерживают интерполяцию выражений, эту возможность следует использовать с осторожностью, потому что
# любые сложные выражения в f-строках ухудшают читаемость вашего кода. Следующий пример демонстрирует злоупотребление
# f-строками, использующими сложные выражения:
summary_text = f'Your Average Score: {sum([95, 98, 97, 96, 97, 93]) / len([95, 98, 97, 96, 97, 93])}.'
print(summary_text)
# Существует хороший практический критерий оценки удобочитаемости вашего кода — определите, сколько времени потребуется
# читателю, чтобы разобраться в нем. Чтобы понять, что происходит в приведенном выше фрагменте, читателю понадобятся
# десятки секунд. Сравните со следующей переработанной версией:
scores = [95, 98, 97, 96, 97, 93]
total_score = sum(scores)
subject_count = len(scores)
average_score = total_score / subject_count
summary_text = f'Your Average Score: {average_score}.'
print(summary_text)
# В этой версии заслуживает внимания ряд обстоятельств. Во-первых, оценки сохраняются в объекте list, что позволяет
# избавиться от дублирования данных. Во-вторых, вычисления разбиты на несколько шагов, при этом каждый шаг представляет
# собой более простое вычисление. В-третьих, ключевым фактором для улучшения удобочитаемости становится использование на
# каждом шаге содержательного имени, обозначающего результат вычислений. Такой код хорошо читается без единого
# комментария, все понятно само по себе.
# Создайте необходимые промежуточные переменные с содержательными именами, чтобы наглядно обозначить каждый шаг ваших
# операций. Для простых операций вам даже не придется писать комментарии, потому что содержательные имена описывают
# смысл каждой операции.


# 2.1.4. Применение спецификаторов для форматирования f-строк
print('2.1.4. Применение спецификаторов для форматирования f-строк')
# Так как f-строки проектировались для форматирования строк, они предоставляют возможность задать спецификатор формата
# (начинающийся с двоеточия) для применения дополнительных правил форматирования к выражению в фигурных скобках.
# При интерполяции можно воспользоваться спецификатором формата — необязательным компонентом, который определяет, как
# должна форматироваться интерполированная строка выражения. F-строка может получать разные виды спецификаторов формата.

# Выравнивание строк для формирования визуальной структуры
# Для выравнивания текста в f-строках используются три символа: <, > и ^, включающие выравнивание текста по левому краю,
# по правому краю и по центру соответственно.
# Для определения режима выравнивания текста в спецификаторе формата используется синтаксис f"{expr:x<n}", где
# expr — интерполированное выражение, x — символ-заполнитель для выравнивания (если не указан, по умолчанию используется
# пробел), < — признак выравнивания по левому краю и n — целочисленный интервал, до которого расширяется вывод.
# Листинг 2.2 (test_0002.py) показывает, как создать две записи с выровненными полями для получения более наглядного
# вывода. В листинге 2.3 (test_0003.py) приведено возможное решение, в котором выделяется повторяющаяся
# часть — спецификатор формата. Для заполнения в приведенном примере используются пробелы, но можно использовать и
# другие символы.
task = "homework"
print(f'{task:*>10}')  # Выравнивание по правому краю, заполнитель *
print(f'{task:*<10}')  # Выравнивание по левому краю, заполнитель *
print(f'{task:*^10}')  # Выравнивание по центру, заполнитель *
print(f'{task:^10}')  # Выравнивание по центру, заполнитель — пробел

# Форматирование чисел
# Числа — неотъемлемые источники информации, которые часто включаются в текстовый материал. Существуют различные формы
# числовых значений: большие целые числа, числа с плавающей точкой, проценты и т. д.
# Множество простых чисел бесконечно. Обычный поиск в Google показывает, что наименьшее простое число, превышающее 1
# миллиард, равно 1 000 000 007. При выводе такого большого числа желательно разделять группы цифр, и чаще всего после
# каждых трех цифр вставляется запятая. Для назначения разделителей групп разрядов в целых числах в f-строке
# используется спецификатор формата xd, где x — разделитель, а d — спецификатор формата для целых чисел:
large_prime_number = 1000000007
print(f'Use commas: {large_prime_number:,d}')
# Числа с плавающей точкой, как и дробные числа вообще, встречаются почти в каждом научном или инженерном отчете. Как и
# следовало ожидать, у f-строк существуют спецификаторы формата, которые позволяют форматировать дробные числа в
# удобочитаемом виде.
decimal_number = 1.23456
print(f'Two digits: {decimal_number:.2f}')
print(f'Four digits: {decimal_number:.4f}')
# Если для целых чисел использовался спецификатор формата d, то для дробных значений используется спецификатор f. Хотя
# спецификатор f может использоваться автономно, чаще указывается, сколько цифр должно выводиться в дробной части:
# .2 для вывода двух цифр, .4 — для четырех цифр, и т. д.
# По аналогии с использованием f для дробных чисел, можно воспользоваться спецификатором формата e для экспоненциальной
# (научной) записи.
sci_number = 0.00000000412733
print(f'Sci notation: {sci_number:e}')
print(f'Sci notation: {sci_number:.2e}')
# Другая распространенная форма числовых значений — проценты. При выводе процентов используется спецификатор формата %.
# Как и в случае со спецификаторами e и f, мы можем использовать спецификатор % сам по себе или с указанием точности
# (например, .2 для вывода двух знаков в дробной части):
pct_number = 0.179323
print(f'Percentage: {pct_number:%}')
print(f'Percentage two digits: {pct_number:.2%}')
# Популярные спецификаторы при форматировании чисел с использованием f-строк
number = 15
point = 1.2345
# Целые числа:
print(f'{number:b}')  # Двоичный формат (запись по основанию 2)
print(f'{number:c}')  # Представление целого числа в Юникоде
print(f'{number:d}')  # Десятичный формат (запись по основанию 10)
print(f'{number:o}')  # Восьмеричный формат (запись по основанию 8)
print(f'{number:x}')  # Шестнадцатеричный формат (запись по основанию 16)
# Числа с плавающей точкой:
print(f'{point:.2e}')  # Научная запись
print(f'{point:.2f}')  # Запись с фиксированной точкой и двумя цифрами в дробной части
print(f'{point:.2g}')  # Общий формат с автоматическим применением e или f
print(f'{point:.2%}')  # Проценты с точностью 2 знака


# 2.1.5. Обсуждение
print('2.1.5. Обсуждение')
# Хотя с прямой интерполяцией выражений f-строками код становится более чистым, избегайте использования сложных
# выражений в f-строках — они могут запутать читателей вашего кода. Если выражения слишком сложные, создайте
# промежуточные переменные с содержательными именами. В Python все еще поддерживаются традиционные способы в стиле C и
# с использованием format, но реальной необходимости в их изучении нет (впрочем, они могут встретиться вам в старом
# коде). Каждый раз, когда вам потребуется создать строковый вывод, используйте f-строки. И не забывайте о выравнивании
# текста и форматировании числовых значений — это сделает текстовый вывод более понятным.


# 2.1.6. Задача
print('2.1.6. Задача')
# Джеймс работает в IT-отделе компании оптовой торговли и готовит шаблон для ценников. Допустим, данные товара
# сохраняются в объекте dict: {'name': 'Vacuum', 'price': 130.675}. Как Джеймсу записать f-строку, если нужно, чтобы в
# ценнике выводилась строка Vacuum: {130.68}? Обратите внимание: цена должна выводиться с точностью до двух знаков, а
# вывод включает фигурные скобки — символы, используемые для строковой интерполяции в f-строках.
# ПОДСКАЗКА Фигурные скобки являются специальными символами в f-строках. Если строковый литерал включает специальные
# символы, необходимо экранировать их, чтобы они не рассматривались как специальные символы. Для экранирования фигурных
# скобок включите дополнительную фигурную скобку: {{ означает {, а }} означает }.
template = {'name': 'Vacuum', 'price': 130.675}
print(f'{template['name']}: {{{template['price']}}}')


# 2.2. КАК ПРЕОБРАЗОВАТЬ СТРОКИ ДЛЯ ПОЛУЧЕНИЯ ПРЕДСТАВЛЯЕМЫХ ДАННЫХ
print('2.2. КАК ПРЕОБРАЗОВАТЬ СТРОКИ ДЛЯ ПОЛУЧЕНИЯ ПРЕДСТАВЛЯЕМЫХ ДАННЫХ')
# Хотя внешне строки являются текстовыми данными, фактически они могут представлять целые числа, словари и другие типы
# данных. Например, встроенная функция input предоставляет простейший способ получения пользовательского ввода с консоли
# Python:
# age = input('Please enter your age:')
# print(type(age))
# В более широком смысле многие ситуации требуют преобразования строк в списки, словари и другие применимые типы данных.


# 2.2.1. Проверка строк на представление алфавитно-цифровых значений
print('2.2.1. Проверка строк на представление алфавитно-цифровых значений')
# В языке Python строки могут содержать любую последовательность символов, которые вводятся с клавиатуры. Одна из
# типичных задач при работе с ними — проверка того, содержит ли строка только алфавитно-цифровые символы.
# Допустим, таск-менеджер требует, чтобы пользователи вводили свое имя, которое должно состоять из алфавитно-цифровых
# символов. Для реализации этой функциональности можно воспользоваться методом isalnum, проверяющим, что строка состоит
# только из символов a-z, A-Z и 0-9.
bad_username0 = "123!@#"
assert bad_username0.isalnum() is False
bad_username1 = "abc..."
assert bad_username1.isalnum() is False
good_username = "1a2b3c"
assert good_username.isalnum() is True
# Предположим, название создаваемой задачи должно состоять только из букв. Для проверки этого можно воспользоваться
# методом isalpha, который возвращает True или False. Как вы, вероятно, уже заметили, все is-методы возвращают
# логические значения:
assert "Homework".isalpha() is True
assert "Homework123".isalpha() is False
# Аналогичным образом при помощи метода isnumeric можно проверить, являются ли все символы в строке цифровыми символами:
assert "123".isnumeric() is True
assert "a123".isnumeric() is False
# Стоит обсудить несколько подводных камней, на которые можно натолкнуться при использовании метода isnumeric для
# проверки того, представляет ли строка числовое значение:
# - Строки, представляющие числа с плавающей точкой, не проходят проверку isnumeric. Казалось бы, для строк, содержащих
# действительные числовые значения, вызов этого метода должен возвращать True. К сожалению, это не так:
assert "3.5".isnumeric() is False
# - Строки, представляющие отрицательные числа, не проходят проверку isnumeric. Вероятно, это тоже противоречит нашим
# интуитивным представлениям, как в следующем примере:
assert "-2".isnumeric() is False
# - Для пустых строк isnumeric возвращает False. Пожалуй, интерпретация пустых строк как нецифровых значений
# соответствует нашим ожиданиям. При преобразовании строк в целые числа следует понимать, что происходит.
# Чтобы избежать всех этих проблем, запомните, что строка выдает значение True при проверке методом isnumeric только в
# том случае, если все символы непустой строки являются цифровыми. К категории цифровых символов не относятся точка или
# знак «минус». По этой причине метод isnumeric интерпретирует числа с плавающей точкой и отрицательные числа как False.
# Чем различаются isnumeric, isdigit и isdecimal:
# Методы isdigit и isdecimal, родственные с isnumeric, часто используются для проверки того, содержат ли строки только
# цифры или символы десятичных чисел. Казалось бы, их имена означают одно и то же, и в большинстве случаев — например,
# для строки "123" — они возвращают одинаковые логические результаты. Однако существуют нюансы, из-за которых они
# возвращают разные значения для некоторых строк, особенно если числовые строки не содержат арабские цифры.
# По определению эти три метода связаны следующими отношениями в контексте жесткости проверки:
# isdecimal < isdigit < isnumeric.
# Если вы боитесь запутаться в этих методах, лучше использовать наиболее общий метод isnumeric.
# В категории is... присутствует интересный метод isidentifier. Он проверяет, является ли строка допустимым
# идентификатором, который может использоваться в качестве имени переменной, функции или объекта.


# 2.2.2. Преобразование строк в числа
print('2.2.2. Преобразование строк в числа')
# Преобразования строк в числа важны, потому что со строками невозможно выполнять числовые вычисления — например,
# сравнить age с 18. Поэтому во многих случаях для последующей обработки требуется получить числовое значение,
# представляемое строкой.
# В программировании приведением типа называется процесс преобразования типа данных к другому типу данных (например,
# преобразования строки в целое число).
# Для работы с числовыми значениями обычно используются типы float и int.
# Для создания экземпляров этих типов на базе строк используется синтаксис float("string") и int("string"). Python
# вычисляет объекты строк, чтобы преобразовать их в правильный объект float или int, если это возможно.
# Если вы предполагаете, что строка представляет число с плавающей точкой, передайте ее встроенному конструктору float.
print(float('3.25'))
print(float('-2'))
# Конструктором (constructor) называется особая разновидность функций, которые создают экземпляр (объект) класса.
# Если вы ожидаете, что строка содержит целое число, используйте встроенный конструктор int:
print(int('-5'))
print(int('123'))
# Операции преобразования завершаются успешно, если эти строки содержат предполагаемые числовые значения. Но в противном
# случае попытка преобразования приводит к ошибке, а ваша программа аварийно завершается, как показано в следующем
# фрагменте:
# print(float('3.25a'))
# Traceback (most recent call last):
#   File "./Chapter_02.py", line 270, in <module>
#     print(float('3.25a'))
#           ^^^^^^^^^^^^^^
# ValueError: could not convert string to float: '3.25a'
# print(int('one'))
# Traceback (most recent call last):
#   File "./Chapter_02.py", line 270, in <module>
#     print(float('3.25a'))
#           ^^^^^^^^^^^^^^
# ValueError: could not convert string to float: '3.25a'
# Чтобы программа не завершалась из-за этой ошибки, используйте конструкцию try...except... для обработки исключения.
# Листинг 2.4. (test_0004.py) продемонстрирует такое применение.


# 2.2.3. Вычисление строк для получения представляемых данных
print('2.2.3. Вычисление строк для получения представляемых данных')
# Кроме числовых значений, в приложениях также используются текстовые данные, представляющие данные других типов,
# например списки и кортежи.
# Итерируемыми объектами (iterables) называются объекты, предоставляющие возможность последовательного перебора
# элементов. Строки, списки и кортежи — типичные примеры итерируемых объектов.
# Для обхода непредсказуемого поведения в процессе преобразования строки в список, кортеж или словарь, используйте
# встроенную функцию eval. Функция получает строку так, словно она была введена с консоли,и возвращает вычисленный
# результат:
numbers_list_str = '[1, 2]'
numbers_tuple_str = '(1, 2)'
numbers_dict_str = "{1:'one', 2: 'two'}"
assert eval(numbers_list_str) == [1, 2]
assert eval(numbers_tuple_str) == (1, 2)
assert eval(numbers_dict_str) == {1: 'one', 2: 'two'}
# При вычислении этих строк вы получаете данные, представляемые этими строками. Такое преобразование полезно, потому что
# текст часто используется как формат обмена данными. Преимущество eval заключается в том, что результат вычисления
# переданного текста гарантированно будет таким, как если бы вы выполнили тот же текст как код с консоли.
# Будьте осторожны с eval и exec
# Использование eval лучше ограничить доверенными источниками данных, потому что eval вычисляет строку так, как если бы
# код являлся частью программы. Эта проблема продемонстрирована в следующем фрагменте. Вычисление некорректного кода
# приводит к ошибке SyntaxError, которая может вызвать аварийное завершение программы:
# print(eval('[1, 2'))
# Traceback (most recent call last):
#   File "./Chapter_02.py", line 308, in <module>
#     print(eval('[1, 2'))
#           ^^^^^^^^^^^^^
#   File "<string>", line 1
#     [1, 2
#     ^
# SyntaxError: '[' was never closed
# Также существует другая встроенная функция exec, похожая на eval. Функция exec может выполнить строку так, как если бы
# эта строка была частью программы. Самое заметное различие между exec и eval заключается в том, что eval вычисляет и
# возвращает выражение, а exec может принимать выражения и инструкции (например, if...else...), но ничего не возвращает.
# Хотя обе функции наделяют приложение возможностью динамического генерирования кода, их некорректное использование
# создает угрозу для работоспособности приложения и даже компьютера. Например, функции exec можно передать строку
# "os.system('rm -rf *')", что приведет к удалению всех папок и файлов на вашем компьютере.
# Поэтому если ваше приложение должно обрабатывать строки динамически с использованием eval и exec, будьте очень
# внимательны. В качестве альтернативы eval можно рассмотреть модуль ast из стандартной библиотеки; функция literal_eval
# этого модуля выполняет безопасное вычисление строк.
# Применение eval без проверки целостности объекта строки может привести к ошибкам и даже катастрофическим последствиям.
# Будьте очень осторожны, когда вам приходится пользоваться этим способом.


# 2.2.4. Обсуждение
print('2.2.4. Обсуждение')
# При использовании конструктора float или int для получения фактических числовых значений, представляемых строкой,
# рассмотрите возможность применения try...except.... Успех преобразования никогда не гарантирован, а в случае неудачи
# программа завершится аварийно, если исключение не будет обработано.
# Будьте осторожны с применением eval для получения представляемых данных, потому что ненадежные источники опасны для
# программы. Если вы озабочены безопасностью данных, стоит подумать о самостоятельном разборе данных или об
# использовании таких проверенных средств, как модуль ast. Если вы работаете с собственными данными (например, пишете
# сценарий их обработки), для получения данных можно пользоваться eval.


# 2.2.5. Задача
print('2.2.5. Задача')
# В начале этого раздела вы узнали, как получить входные данные от пользователя при помощи функции input.
# Мэри — школьная учительница, которая хочет написать простую демонстрационную программу для своих учеников. Допустим,
# программа должна запрашивать температуру по Цельсию с консоли Python. Как ей написать программу, чтобы та
# удовлетворяла приведенным ниже требованиям? x — значение, введенное пользователем:
# - Если температура < 10 градусов, программа выводит сообщение: «You entered x degrees. It's cold!» (Вы ввели х
# градусов. Холодно!)
# - Если температура лежит в диапазоне от 10 до 25 градусов, программа выводит сообщение «You entered x degrees. It's
# cool!» (Вы ввели х градусов. Прохладно!)
# - Если температура > 25 градусов, программа выводит сообщение «You entered x degrees. It's hot!» (Вы ввели х градусов.
# Жарко!)
# - Значение x должно выводиться с точностью до одного знака в дробной части. Например, если пользователь вводит 15.75,
# значение должно выводиться в виде 15.8.
# ПОДСКАЗКА Введенную строку необходимо преобразовать в число с плавающей точкой, прежде чем сравнивать ее с другими
# числами. Для создания строкового вывода используйте f-строки. И не забывайте о спецификаторах формата!
# x = float(input())
x = 15.75
if x < 10:
    print(f'Вы ввели {x:0.1f} градусов. Холодно!')
elif 10 <= x <= 25:
    print(f'Вы ввели {x:0.1f} градусов. Прохладно!')
elif x > 25:
    print(f'Вы ввели {x:0.1f} градусов. Жарко!')


# 2.3. КАК ОБЪЕДИНЯТЬ И РАЗБИВАТЬ СТРОКИ
print('2.3. КАК ОБЪЕДИНЯТЬ И РАЗБИВАТЬ СТРОКИ')
# Строки не всегда хранятся в том формате, который вам нужен. В ряде случаев отдельные строки представляют разрозненные
# фрагменты взаимосвязанной информации, которые необходимо объединить в одну строку. Допустим, пользователь вводит
# несколько строк с названиями фруктов, которые ему нравятся. Эти строки можно объединить в одну строку со списком
# предпочтений пользователя:
# Исходный ввод
fruit0 = 'apple'
fruit1 = 'banana'
fruit2 = 'orange'
# Нужный вывод
liked_fruits = 'apple, banana, orange'
# В других ситуациях требуется разбить строку и создать несколько строк из ее частей. Скажем, пользователь вводит
# перечень стран, в которых он побывал, в одной строке. Требуется создать список с названиями стран:
# Исходный ввод
visited_countries = 'United States, China, France, Canada'
# Нужный вывод
countries = ['United States', 'China', 'France', 'Canada']


# 2.3.1. Объединение строк с пробельными символами
print('2.3.1. Объединение строк с пробельными символами')
# Для объединения строк используется оператор конкатенации — символ +, представленный в листинге 2.1. При наличии
# нескольких строковых литералов их можно объединять, если они разделяются пробельными символами (whitespaces):
# пробелами, табуляциями и символами новой строки.
# Допустим, в приложении используются разные конфигурации, определяющие стиль отображения информации. Конфигурации
# оформлены в виде строковых литералов, и эти отдельные настройки объединяются автоматически:
style_settings = 'font-size=large, ' 'font=Arial, ' 'color=black, ', 'align=center'
print(style_settings)  # ('font-size=large, font=Arial, color=black, ', 'align=center')
# Автоматическая конкатенация может выполняться только между строковыми литералами. Этот метод не применяется к
# строковым переменным или комбинациям строковых литералов и переменных. F-строки также поддерживают автоматическую
# конкатенацию. Эта возможность особенно полезна при построении длинных f-строк с разбиением строковых литералов на
# отдельные строки кода для ясности:
settings = {'font_size': 'large', 'font': 'Arial', 'color': 'black', 'align': 'center'}
styles = f"font-size={settings['font_size']}, "\
         f"font={settings['font']}, "\
         f"color={settings['color']}, "\
         f"align={settings['align']}"
# Если в программе используется длинная строка, рассмотрите возможность разбиения ее на несколько частей, каждая из
# которых представляет осмысленную подстроку. Если такие подстроки разделяются пробельными символами, они могут
# объединяться автоматически.


# 2.3.2. Объединение строк без ограничителей
print('2.3.2. Объединение строк без ограничителей')
# Объединение строк, разделенных пробелами, может сбивать с толку, потому что границы (пробелы) между строковыми
# литералами несколько усложняют зрительное восприятие отдельных строк. Более того, такие ограничители не могут
# встречаться внутри строковых литералов, что создает дополнительные затруднения. В общем случае идеальным вариантом
# становится объединение строк с произвольными ограничителями.
# Для выполнения конкатенации отдельных строк можно воспользоваться методом join:
style_settings = ['font-size=large', 'font=Arial', 'color=black', 'align=center']
merged_style = ', '.join(style_settings)
print(merged_style)  # font-size=large, font=Arial, color=black, align=center
# Метод join получает список строк. Элементы этого списка соединяются последовательно со строкой-ограничителем,
# использованной при вызове метода. Хотя в данном случае используется объект списка, в более общем варианте это может
# быть произвольный итерируемый объект, например кортеж или множество.
# По сравнению с прямой конкатенацией метод join лучше читается, так как строки-компоненты являются отдельными
# элементами и читателю кода проще увидеть, что именно объединяется. Важным является следующее дополнительное
# преимущество join: вы можете динамически обрабатывать элементы объекта list.
# Допустим, вы хотите создать в таск-менеджере строку с перечнем задач, которые необходимо выполнить за неделю.
# Изначально задачи хранятся в виде строк в элементах списка. Объединяя эти строки, можно сгенерировать список и
# отображать его на рабочем столе как напоминание:
tasks = ['Homework', 'Grocery', 'Laundry', 'Museum Trip', 'Buy Furniture']
note = ', '.join(tasks)
print('Remaining Tasks:', note)  # Remaining Tasks: Homework, Grocery, Laundry, Museum Trip, Buy Furniture
# После того как пользователь выполнит часть задач, эти задачи удаляются из списка:
tasks.remove('Buy Furniture')
tasks.remove('Homework')
# После удаления задач вы все еще можете воспользоваться методом join для создания необходимой строки:
print('Remaining Tasks: ', ', '.join(tasks))  # Remaining Tasks:  Grocery, Laundry, Museum Trip
# В этом примере продемонстрированы сценарии использования со списками строк, которые могут изменяться динамически.
# С появлением дополнительных задач можно включать их в объект list и заново генерировать обновленную строку методом
# join.


# 2.3.3. Разбиение строк для создания списка
print('2.3.3. Разбиение строк для создания списка')
# Для сохранения и передачи данных часто используются текстовые файлы. Например, табличные данные можно сохранить в
# текстовом файле, чтобы каждая строка представляла отдельную запись. При чтении текстового файла каждой записи данных
# соответствует одна строка, содержащая несколько подстрок, а каждая подстрока представляет значение некоторого поля.
# Чтобы обработать данные, необходимо разбить строку и извлечь эти значения в отдельные подстроки.
# Предположим, у нас есть текстовый файл с именем "task_data.txt", в котором хранятся описания задач. Каждая строка
# представляет информацию по отдельной задаче, как показано в следующем фрагменте: идентификатор, название и уровень
# важности. Так как чтение данных из файла рассматривается далее, в главе 11, будем считать, что вы уже прочитали
# текстовые данные и сохранили их в многострочной строке в тройных кавычках:
task_data = """1001,Homework,5
1002,Laundry,3
1003,Grocery,4"""
# Для создания строк в тройных кавычках, охватывающих несколько физических строк, могут использоваться как одинарные,
# так и двойные кавычки. Синтаксис тройных кавычек также поддерживается для многострочных f-строк.
# Для обработки таких строк мы воспользуемся методом split, который ищет заданные ограничители и разбивает по ним
# строку. Возможное решение приведено в листинге 2.5 (test_0005.py).
# У метода split есть ограничение: он позволяет задать только один разделитель, что может привести к проблемам при
# разбиении строк с разными разделителями. Допустим, в текстовом файле в качестве разделителей используются как запятые,
# так и символы подчеркивания. Упрощая задачу, примем, что между словами используется только один разделитель.
# Для демонстрации возьмем следующую строку данных:
messy_data = 'process,messy_data_mixed,separators'
# Рассмотрим альтернативные решения.
# 1 - Последовательное применение разделителей:
#  a) Строки разбиваются по запятым, в результате разбиения создается список.
#  б) Проверяем, содержат ли элементы списка символы подчеркивания. Если их нет, значит, элемент готов к дальнейшей
#  обработке. Если они есть, выполняется второе разбиение по подчеркиваниям:
separated_words0 = []
for word in messy_data.split(","):
    if word.find("_") < 0:  # Если совпадение не найдено, результат будет равен –1
        separated_words0.append(word)
    else:
        separated_words0.extend(word.split("_"))  # Метод extend присоединяет все элементы разделенных строк
print(separated_words0)
# 2 - Консолидация разделителей:
# Так как мы знаем, что существуют всего два возможных разделителя, один разделитель можно преобразовать в другой. Это
# позволит вызвать метод split всего один раз для завершения нужной операции:
# consolidated = messy_data.replace(",", "_")  # Использует метод replace для замены подстроки
# separated_words1 = consolidated.split("_")
# Эти два решения просты и прямолинейны. При хорошем знании базовых операций со строками и списками они окажутся
# идеальными в случае, если быстродействие не критично, потому что они потребуют нескольких проходов для проверки
# разделителей.
# Регулярные выражения — последовательности символов, описывающие условия поиска. Их часто сокращают как regex (от
# regular expressions).


# 2.3.4. Обсуждение
print('2.3.4. Обсуждение')
# Выбор между конкатенацией строк, f-строками или join должен определяться для каждого конкретного случая. Главный
# критерий — удобочитаемость кода. Если вам нужно объединить небольшое количество строк, используйте операторы
# конкатенации. Если строк много, рассмотрите возможность применения f-строк для группировки взаимосвязанных строк.
# Метод join особенно полезен для объединения отдельных строк, сохраненных в итерируемом объекте.
# Кроме split, есть также метод rsplit со сходной функциональностью. Единственное его отличие связано со способом
# задания параметра maxsplit, определяющего максимальное количество элементов, которые могут быть созданы в результате
# разбиения.


# 2.3.5. Задача
print('2.3.5. Задача')
# Ниже приведены сигнатуры методов split и rsplit. Оба метода получают аргументы с разделителем и максимальным
# количеством создаваемых элементов.
# Напишите несколько строк, с которыми эти методы будут работать одинаково или по-разному.
# str.split(separator, maxsplit)
# str.rsplit(separator, maxsplit)
# В общем случае оба метода работают одинаково. Различия проявляются тогда, когда количество элементов, полученных в
# результате разбиения, оказывается выше максимального.


# 2.4. КАКИЕ ВОЗМОЖНОСТИ ПРЕДОСТАВЛЯЮТ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
print('2.4. КАКИЕ ВОЗМОЖНОСТИ ПРЕДОСТАВЛЯЮТ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ')
# Класс str в Python содержит такие полезные методы для поиска подстрок, как find и rfind. Впрочем, во многих
# практических ситуациях их возможности оказываются недостаточными, особенно когда речь заходит о сложном поиске по
# шаблону.
# Решение с помощью регулярных выражений может выглядеть так:
messy_data = 'process,messy_data_mixed,separators'
regex = re.compile(r'[,_]')  # Компилирует регулярное выражение
separated_words2 = regex.split(messy_data)
print(separated_words2)
# Отметим, что строка для завершения разбиения обходится только один раз. С несколькими разделителями регулярные
# выражения работают намного эффективнее двух других решений (раздел 2.3.3), требующих нескольких проходов по строке.
# Регулярные выражения не привязаны к конкретному языку. Они поддерживаются всеми распространенными языками
# программирования, хотя синтаксис их реализации может иметь некоторые различия. Однако сами регулярные выражения
# остаются практически неизменными; можно считать, что в разных языках программирования используются разные диалекты
# регулярных выражений.


# 2.4.1. Работа с регулярными выражениями в Python
print('2.4.1. Работа с регулярными выражениями в Python')
# Стандартная библиотека Python включает модуль re с функциональностью, связанной с регулярными выражениями. Существуют
# два варианта использования этого модуля. Первый вариант относится к аспектам объектно-ориентированного
# программирования (ООП) в Python. Применяя парадигму ООП к регулярным выражениям, вы выполняете операции с объектами
# Pattern. В этом варианте вы сначала создаете объект Pattern, компилируя заданный строковый шаблон. Затем объект
# Pattern используется для поиска частей текста, соответствующих шаблону.
# ООП (объектно-ориентированное программирование) — модель программной архитектуры, в которой центральное место занимают
# данные и объекты (вместо функций и процедур).
# Следующий фрагмент кода показывает, как применить парадигму ООП для поиска по шаблону с применением регулярных
# выражений:
regex = re.compile('do')     # Создает шаблон
regex.pattern                # Обращается к атрибутам
regex.search('do homework')  # Использует методы
print(regex.findall("don't do that"))
# В другом стиле применяется функциональный подход. Вместо того чтобы создавать объект Pattern, мы вызываем функции
# непосредственно из модуля.
# При вызове функции задается шаблон, а также строка, к которой этот шаблон применяется:
# re.search('pattern', 'the string to be searched')
# re.findall('pattern', 'the string to be searched')
# Во внутренней реализации при вызове re.search Python сам создает объект Pattern и вызывает метод search для шаблона.
# Таким образом, использование модуля для вызова функций становится удобным способом работы с регулярными выражениями.
# Однако следует учитывать, что при создании объекта Pattern функцией compile откомпилированный шаблон кэшируется, а
# многократное использование шаблона становится более эффективным, потому что шаблон не нужно компилировать повторно.
# Механизм кэширования используется в программировании (и компьютерных вычислениях вообще) для временного хранения
# данных, чтобы будущие запросы этих данных обслуживались быстрее.
# С другой стороны, с функциональным подходом шаблон создается «на ходу», и преимущества от повышения эффективности за
# счет кэширования теряются. Поэтому если вы собираетесь использовать шаблон однократно, о различиях этих двух подходов
# можно не задумываться.


# 2.4.2. Определение шаблона в виде необработанной строки
print('2.4.2. Определение шаблона в виде необработанной строки')
# Мощь регулярных выражений проявляется прежде всего в компактности шаблона, описывающего широкий диапазон возможностей.
# Для создания шаблона часто приходится использовать необработанные (raw) строки, например строковый литерал с префиксом
# r (r"шаблон"). В этом разделе вы увидите, почему необходимо использовать необработанные строки для построения шаблонов
# регулярных выражений.
# В регулярных выражениях \d обозначает любую цифру, а \w — символ слова в Юникоде. Это примеры специальных символов в
# регулярных выражениях, а префикс \ указывает, что эти символы имеют особый смысл помимо того, чем они кажутся на
# первый взгляд. В строках Python символ \ также используется для обозначения специальных символов, например \t для
# табуляции, \n для новой строки или \\ для обратного слеша.
# Когда эти обозначения объединяются в строках, появляются шаблоны довольно странного вида. Допустим, вы хотите найти
# подстроку \task. Следует заметить, что \t в данном случае является литералом; эти два символа действительно обозначают
# символ обратного слеша и букву t, а не символ табуляции. Чтобы Python мог искать подстроку \task, необходимо
# использовать обозначение \\task. Ситуация дополнительно усложняется тем, что при создании такого шаблона оба символа \
# должны экранироваться, из-за чего при поиске \task необходимо использовать четыре символа обратного слеша (\\\\task).
# Вам это кажется странным? Возьмем следующий код:
task_pattern = re.compile("\\\\task")
texts = ["\task", "\\task", "\\\task", "\\\\task"]
for text in texts:
    print(f"Match {text!r}: {task_pattern.match(text)}")

# Выводимые строки:
# Match '\task': None
# Match '\\task': <re.Match object; span=(0, 5), match='\\task'>
# Match '\\\task': None
# Match '\\\\task': None
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


