#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re  # Импорт модуля re

# Глава 2
print('Глава 2')
# Обработка и формирование строк
print('Обработка и формирование строк')


# 2.1. КАК ИСПОЛЬЗОВАТЬ F-СТРОКИ ДЛЯ ИНТЕРПОЛЯЦИИ И ФОРМАТИРОВАНИЯ
print('2.1. КАК ИСПОЛЬЗОВАТЬ F-СТРОКИ ДЛЯ ИНТЕРПОЛЯЦИИ И ФОРМАТИРОВАНИЯ')


# 2.1.1. Форматирование строк до появления f-строк
print('2.1.1. Форматирование строк до появления f-строк')
# Класс str работает с текстовыми данными через свои экземпляры, которые мы будем называть строковыми переменными.
# Помимо строковых переменных, в текстовую информацию также часто включаются такие типы данных, как целые числа и числа
# с плавающей точкой. Теоретически мы могли бы преобразовать нестроковые данные в строки и соединить их для получения
# нужного текстового вывода, как показано в листинге test_0001.py.
# Методами обычно называются функции, определяемые в классах. В данном случае функция format определяется в классе str,
# поэтому этот метод вызывается для экземпляров str.


# 2.1.2. Использование f-строк для интерполяции переменных
print('2.1.2. Использование f-строк для интерполяции переменных')
# Форматирование строк часто подразумевает объединение строковых литералов и переменных разных типов (например, целых
# чисел и строк). При интеграции переменных в f-строку можно интерполировать эти переменные, чтобы они автоматически
# преобразовывались в строки нужного вида.
# Для начала рассмотрим, как использовать f-строки при создании вывода, представленного в листинге 2.1 (test_0001.py).
name = 'Homework'
urgency = 5
task_f = f'Name: {name}; Urgency Level: {urgency}'
assert task_f == 'Name: Homework; Urgency Level: 5'
# В этом примере переменная task_f создается с применением f-строк. Главное, на что следует обратить внимание, -
# фигурные скобки, в которые заключаются интерполируемые переменные. Так как f-строки интегрируют механизм строковой
# интерполяции, они также называются интерполируемыми строковыми литералами.
# Термин «строковая интерполяция» (string interpolation) не относится к специфике Python, этот механизм присутствует
# в большинстве основных современных языков (таких, как JavaScript, Swift и C#). В общем случае он предоставляет более
# компактный и удобочитаемый синтаксис для создания отформатированных строк, чем конкатенация строк и альтернативные
# способы их форматирования.
# Инструкция assert
# Ключевое слово Python assert используется для проверок (ассертов), которые вычисляют заданное условие. Если результат
# равен True, программа продолжает выполняться. Если же результат равен False, выполнение прерывается, а программа
# выдает ошибку AssertionError.
tasks = ['homework', 'laundry']
assert f'Tasks: {tasks}' == "Tasks: ['homework', 'laundry']"  # Интерполирует объект списка
task_hwk = ('Homework', 'Complete physics work')
assert f'Task: {task_hwk}' == "Task: ('Homework', 'Complete physics work')"  # Интерполирует объект кортежа
task = {'name': 'Laundry', 'urgency': 3}
assert f'Task: {task}' == "Task: {'name': 'Laundry', 'urgency': 3}"  # Интерполирует объект словаря


# 2.1.3. Использование f-строк для интерполяции выражений
print('2.1.3. Использование f-строк для интерполяции выражений')
# На более общем уровне f-строки также могут интерполировать выражения, что избавляет вас от необходимости создания
# промежуточных переменных. Например, при создании строкового вывода можно обратиться к элементу объекта dict или
# использовать результат вызова функции. В таких распространенных ситуациях можно включить эти выражения в f-строки, как
# показывает следующий фрагмент кода:
tasks = ["homework", "laundry", "grocery shopping"]
assert f"First Task: {tasks[0]}" == 'First Task: homework'  # Обращается к элементу списка
task_name = "grocery shopping"
assert f"Task Name: {task_name.title()}" == 'Task Name: Grocery Shopping'  # Вызывает функцию
number = 5
assert f"Square: {number * number}" == 'Square: 25'  # Прямые вычисления
# Эти выражения заключаются в фигурные скобки, чтобы f-строки напрямую вычислили их для получения нужного строкового
# вывода: {tasks[0]} -> "homework";
# {task_name.title()} -> "Grocery Shopping";
# {number * number} -> 25.
# В тексте часто встречается термин «выражение» (expression), относящийся к числу ключевых понятий программирования.
# Начинающие программисты могут путать его со связанным понятием - инструкцией (statement). Выражение обычно
# представляет собой одну строку кода (хотя может занимать несколько строк при заключении в тройные кавычки),
# результатом вычисления которой является значение объекта, например строки или экземпляра нестандартного класса. Из
# этого определения легко выводится, что переменные являются разновидностями выражений.
# С другой стороны, инструкции не создают никакого значения или объекта. Цель инструкции заключается в выполнении
# некоторого действия. Например, ключевое слово assert создает проверочную инструкцию (или команду), которая проверяет
# выполнение некоторого условия, прежде чем процесс продолжится. Мы не пытаемся получить логическое значение True или
# False, а проверяем условие.
# Различия между выражениями и инструкциями. Выражения представляют некие вычисления, в результате которых получается
# значение или объект, тогда как инструкция выполняет конкретные действия и не может вычисляться для получения значения.
# Хотя f-строки поддерживают интерполяцию выражений, эту возможность следует использовать с осторожностью, потому что
# любые сложные выражения в f-строках ухудшают читаемость вашего кода. Следующий пример демонстрирует злоупотребление
# f-строками, использующими сложные выражения:
summary_text = f'Your Average Score: {sum([95, 98, 97, 96, 97, 93]) / len([95, 98, 97, 96, 97, 93])}.'
print(summary_text)
# Существует хороший практический критерий оценки удобочитаемости вашего кода - определите, сколько времени потребуется
# читателю, чтобы разобраться в нем. Чтобы понять, что происходит в приведенном выше фрагменте, читателю понадобятся
# десятки секунд. Сравните со следующей переработанной версией:
scores = [95, 98, 97, 96, 97, 93]
total_score = sum(scores)
subject_count = len(scores)
average_score = total_score / subject_count
summary_text = f'Your Average Score: {average_score}.'
print(summary_text)
# В этой версии заслуживает внимания ряд обстоятельств. Во-первых, оценки сохраняются в объекте list, что позволяет
# избавиться от дублирования данных. Во-вторых, вычисления разбиты на несколько шагов, при этом каждый шаг представляет
# собой более простое вычисление. В-третьих, ключевым фактором для улучшения удобочитаемости становится использование на
# каждом шаге содержательного имени, обозначающего результат вычислений. Такой код хорошо читается без единого
# комментария, все понятно само по себе.
# Создайте необходимые промежуточные переменные с содержательными именами, чтобы наглядно обозначить каждый шаг ваших
# операций. Для простых операций вам даже не придется писать комментарии, потому что содержательные имена описывают
# смысл каждой операции.


# 2.1.4. Применение спецификаторов для форматирования f-строк
print('2.1.4. Применение спецификаторов для форматирования f-строк')
# Так как f-строки проектировались для форматирования строк, они предоставляют возможность задать спецификатор формата
# (начинающийся с двоеточия) для применения дополнительных правил форматирования к выражению в фигурных скобках.
# При интерполяции можно воспользоваться спецификатором формата - необязательным компонентом, который определяет, как
# должна форматироваться интерполированная строка выражения. F-строка может получать разные виды спецификаторов формата.

# Выравнивание строк для формирования визуальной структуры
print('Выравнивание строк для формирования визуальной структуры')
# Для выравнивания текста в f-строках используются три символа: <, > и ^, включающие выравнивание текста по левому краю,
# по правому краю и по центру соответственно.
# Для определения режима выравнивания текста в спецификаторе формата используется синтаксис f"{expr:x<n}", где
# expr - интерполированное выражение, x - символ-заполнитель для выравнивания (если не указан, по умолчанию используется
# пробел), < - признак выравнивания по левому краю и n - целочисленный интервал, до которого расширяется вывод.
# Листинг 2.2 (test_0002.py) показывает, как создать две записи с выровненными полями для получения более наглядного
# вывода. В листинге 2.3 (test_0003.py) приведено возможное решение, в котором выделяется повторяющаяся
# часть - спецификатор формата. Для заполнения в приведенном примере используются пробелы, но можно использовать и
# другие символы.
task = "homework"
print(f'{task:*>10}')  # Выравнивание по правому краю, заполнитель *
print(f'{task:*<10}')  # Выравнивание по левому краю, заполнитель *
print(f'{task:*^10}')  # Выравнивание по центру, заполнитель *
print(f'{task:^10}')  # Выравнивание по центру, заполнитель - пробел

# Форматирование чисел
print('Форматирование чисел')
# Числа - неотъемлемые источники информации, которые часто включаются в текстовый материал. Существуют различные формы
# числовых значений: большие целые числа, числа с плавающей точкой, проценты и т. д.
# Множество простых чисел бесконечно. Обычный поиск в Google показывает, что наименьшее простое число, превышающее 1
# миллиард, равно 1 000 000 007. При выводе такого большого числа желательно разделять группы цифр, и чаще всего после
# каждых трех цифр вставляется запятая. Для назначения разделителей групп разрядов в целых числах в f-строке
# используется спецификатор формата xd, где x - разделитель, а d - спецификатор формата для целых чисел:
large_prime_number = 1000000007
print(f'Use commas: {large_prime_number:,d}')
# Числа с плавающей точкой, как и дробные числа вообще, встречаются почти в каждом научном или инженерном отчете. Как и
# следовало ожидать, у f-строк существуют спецификаторы формата, которые позволяют форматировать дробные числа в
# удобочитаемом виде.
decimal_number = 1.23456
print(f'Two digits: {decimal_number:.2f}')
print(f'Four digits: {decimal_number:.4f}')
# Если для целых чисел использовался спецификатор формата d, то для дробных значений используется спецификатор f. Хотя
# спецификатор f может использоваться автономно, чаще указывается, сколько цифр должно выводиться в дробной части:
# .2 для вывода двух цифр, .4 - для четырех цифр, и т. д.
# По аналогии с использованием f для дробных чисел, можно воспользоваться спецификатором формата e для экспоненциальной
# (научной) записи.
sci_number = 0.00000000412733
print(f'Sci notation: {sci_number:e}')
print(f'Sci notation: {sci_number:.2e}')
# Другая распространенная форма числовых значений - проценты. При выводе процентов используется спецификатор формата %.
# Как и в случае со спецификаторами e и f, мы можем использовать спецификатор % сам по себе или с указанием точности
# (например, .2 для вывода двух знаков в дробной части):
pct_number = 0.179323
print(f'Percentage: {pct_number:%}')
print(f'Percentage two digits: {pct_number:.2%}')
# Популярные спецификаторы при форматировании чисел с использованием f-строк
number = 15
point = 1.2345
# Целые числа:
print(f'{number:b}')  # Двоичный формат (запись по основанию 2)
print(f'{number:c}')  # Представление целого числа в Юникоде
print(f'{number:d}')  # Десятичный формат (запись по основанию 10)
print(f'{number:o}')  # Восьмеричный формат (запись по основанию 8)
print(f'{number:x}')  # Шестнадцатеричный формат (запись по основанию 16)
# Числа с плавающей точкой:
print(f'{point:.2e}')  # Научная запись
print(f'{point:.2f}')  # Запись с фиксированной точкой и двумя цифрами в дробной части
print(f'{point:.2g}')  # Общий формат с автоматическим применением e или f
print(f'{point:.2%}')  # Проценты с точностью 2 знака


# 2.1.5. Обсуждение
print('2.1.5. Обсуждение')
# Хотя с прямой интерполяцией выражений f-строками код становится более чистым, избегайте использования сложных
# выражений в f-строках - они могут запутать читателей вашего кода. Если выражения слишком сложные, создайте
# промежуточные переменные с содержательными именами. В Python все еще поддерживаются традиционные способы в стиле C и
# с использованием format, но реальной необходимости в их изучении нет (впрочем, они могут встретиться вам в старом
# коде). Каждый раз, когда вам потребуется создать строковый вывод, используйте f-строки. И не забывайте о выравнивании
# текста и форматировании числовых значений - это сделает текстовый вывод более понятным.


# 2.1.6. Задача
print('2.1.6. Задача')
# Джеймс работает в IT-отделе компании оптовой торговли и готовит шаблон для ценников. Допустим, данные товара
# сохраняются в объекте dict: {'name': 'Vacuum', 'price': 130.675}. Как Джеймсу записать f-строку, если нужно, чтобы в
# ценнике выводилась строка Vacuum: {130.68}? Обратите внимание: цена должна выводиться с точностью до двух знаков, а
# вывод включает фигурные скобки - символы, используемые для строковой интерполяции в f-строках.
# ПОДСКАЗКА Фигурные скобки являются специальными символами в f-строках. Если строковый литерал включает специальные
# символы, необходимо экранировать их, чтобы они не рассматривались как специальные символы. Для экранирования фигурных
# скобок включите дополнительную фигурную скобку: {{ означает {, а }} означает }.
template = {'name': 'Vacuum', 'price': 130.675}
print(f'{template['name']}: {{{template['price']}}}')


# 2.2. КАК ПРЕОБРАЗОВАТЬ СТРОКИ ДЛЯ ПОЛУЧЕНИЯ ПРЕДСТАВЛЯЕМЫХ ДАННЫХ
print('2.2. КАК ПРЕОБРАЗОВАТЬ СТРОКИ ДЛЯ ПОЛУЧЕНИЯ ПРЕДСТАВЛЯЕМЫХ ДАННЫХ')
# Хотя внешне строки являются текстовыми данными, фактически они могут представлять целые числа, словари и другие типы
# данных. Например, встроенная функция input предоставляет простейший способ получения пользовательского ввода с консоли
# Python:
# age = input('Please enter your age:')
# print(type(age))
# В более широком смысле многие ситуации требуют преобразования строк в списки, словари и другие применимые типы данных.


# 2.2.1. Проверка строк на представление алфавитно-цифровых значений
print('2.2.1. Проверка строк на представление алфавитно-цифровых значений')
# В языке Python строки могут содержать любую последовательность символов, которые вводятся с клавиатуры. Одна из
# типичных задач при работе с ними - проверка того, содержит ли строка только алфавитно-цифровые символы.
# Допустим, таск-менеджер требует, чтобы пользователи вводили свое имя, которое должно состоять из алфавитно-цифровых
# символов. Для реализации этой функциональности можно воспользоваться методом isalnum, проверяющим, что строка состоит
# только из символов a-z, A-Z и 0-9.
bad_username0 = "123!@#"
assert bad_username0.isalnum() is False
bad_username1 = "abc..."
assert bad_username1.isalnum() is False
good_username = "1a2b3c"
assert good_username.isalnum() is True
# Предположим, название создаваемой задачи должно состоять только из букв. Для проверки этого можно воспользоваться
# методом isalpha, который возвращает True или False. Как вы, вероятно, уже заметили, все is-методы возвращают
# логические значения:
assert "Homework".isalpha() is True
assert "Homework123".isalpha() is False
# Аналогичным образом при помощи метода isnumeric можно проверить, являются ли все символы в строке цифровыми символами:
assert "123".isnumeric() is True
assert "a123".isnumeric() is False
# Стоит обсудить несколько подводных камней, на которые можно натолкнуться при использовании метода isnumeric для
# проверки того, представляет ли строка числовое значение:
# - Строки, представляющие числа с плавающей точкой, не проходят проверку isnumeric. Казалось бы, для строк, содержащих
# действительные числовые значения, вызов этого метода должен возвращать True. К сожалению, это не так:
assert "3.5".isnumeric() is False
# - Строки, представляющие отрицательные числа, не проходят проверку isnumeric. Вероятно, это тоже противоречит нашим
# интуитивным представлениям, как в следующем примере:
assert "-2".isnumeric() is False
# - Для пустых строк isnumeric возвращает False. Пожалуй, интерпретация пустых строк как нецифровых значений
# соответствует нашим ожиданиям. При преобразовании строк в целые числа следует понимать, что происходит.
# Чтобы избежать всех этих проблем, запомните, что строка выдает значение True при проверке методом isnumeric только в
# том случае, если все символы непустой строки являются цифровыми. К категории цифровых символов не относятся точка или
# знак «минус». По этой причине метод isnumeric интерпретирует числа с плавающей точкой и отрицательные числа как False.
# Чем различаются isnumeric, isdigit и isdecimal:
# Методы isdigit и isdecimal, родственные с isnumeric, часто используются для проверки того, содержат ли строки только
# цифры или символы десятичных чисел. Казалось бы, их имена означают одно и то же, и в большинстве случаев - например,
# для строки "123" - они возвращают одинаковые логические результаты. Однако существуют нюансы, из-за которых они
# возвращают разные значения для некоторых строк, особенно если числовые строки не содержат арабские цифры.
# По определению эти три метода связаны следующими отношениями в контексте жесткости проверки:
# isdecimal < isdigit < isnumeric.
# Если вы боитесь запутаться в этих методах, лучше использовать наиболее общий метод isnumeric.
# В категории is... присутствует интересный метод isidentifier. Он проверяет, является ли строка допустимым
# идентификатором, который может использоваться в качестве имени переменной, функции или объекта.


# 2.2.2. Преобразование строк в числа
print('2.2.2. Преобразование строк в числа')
# Преобразования строк в числа важны, потому что со строками невозможно выполнять числовые вычисления - например,
# сравнить age с 18. Поэтому во многих случаях для последующей обработки требуется получить числовое значение,
# представляемое строкой.
# В программировании приведением типа называется процесс преобразования типа данных к другому типу данных (например,
# преобразования строки в целое число).
# Для работы с числовыми значениями обычно используются типы float и int.
# Для создания экземпляров этих типов на базе строк используется синтаксис float("string") и int("string"). Python
# вычисляет объекты строк, чтобы преобразовать их в правильный объект float или int, если это возможно.
# Если вы предполагаете, что строка представляет число с плавающей точкой, передайте ее встроенному конструктору float.
print(float('3.25'))
print(float('-2'))
# Конструктором (constructor) называется особая разновидность функций, которые создают экземпляр (объект) класса.
# Если вы ожидаете, что строка содержит целое число, используйте встроенный конструктор int:
print(int('-5'))
print(int('123'))
# Операции преобразования завершаются успешно, если эти строки содержат предполагаемые числовые значения. Но в противном
# случае попытка преобразования приводит к ошибке, а ваша программа аварийно завершается, как показано в следующем
# фрагменте:
# print(float('3.25a'))
# Traceback (most recent call last):
#   File "./Chapter_02.py", line 270, in <module>
#     print(float('3.25a'))
#           ^^^^^^^^^^^^^^
# ValueError: could not convert string to float: '3.25a'
# print(int('one'))
# Traceback (most recent call last):
#   File "./Chapter_02.py", line 270, in <module>
#     print(float('3.25a'))
#           ^^^^^^^^^^^^^^
# ValueError: could not convert string to float: '3.25a'
# Чтобы программа не завершалась из-за этой ошибки, используйте конструкцию try...except... для обработки исключения.
# Листинг 2.4. (test_0004.py) продемонстрирует такое применение.


# 2.2.3. Вычисление строк для получения представляемых данных
print('2.2.3. Вычисление строк для получения представляемых данных')
# Кроме числовых значений, в приложениях также используются текстовые данные, представляющие данные других типов,
# например списки и кортежи.
# Итерируемыми объектами (iterables) называются объекты, предоставляющие возможность последовательного перебора
# элементов. Строки, списки и кортежи - типичные примеры итерируемых объектов.
# Для обхода непредсказуемого поведения в процессе преобразования строки в список, кортеж или словарь, используйте
# встроенную функцию eval. Функция получает строку так, словно она была введена с консоли,и возвращает вычисленный
# результат:
numbers_list_str = '[1, 2]'
numbers_tuple_str = '(1, 2)'
numbers_dict_str = "{1:'one', 2: 'two'}"
assert eval(numbers_list_str) == [1, 2]
assert eval(numbers_tuple_str) == (1, 2)
assert eval(numbers_dict_str) == {1: 'one', 2: 'two'}
# При вычислении этих строк вы получаете данные, представляемые этими строками. Такое преобразование полезно, потому что
# текст часто используется как формат обмена данными. Преимущество eval заключается в том, что результат вычисления
# переданного текста гарантированно будет таким, как если бы вы выполнили тот же текст как код с консоли.
# Будьте осторожны с eval и exec
# Использование eval лучше ограничить доверенными источниками данных, потому что eval вычисляет строку так, как если бы
# код являлся частью программы. Эта проблема продемонстрирована в следующем фрагменте. Вычисление некорректного кода
# приводит к ошибке SyntaxError, которая может вызвать аварийное завершение программы:
# print(eval('[1, 2'))
# Traceback (most recent call last):
#   File "./Chapter_02.py", line 308, in <module>
#     print(eval('[1, 2'))
#           ^^^^^^^^^^^^^
#   File "<string>", line 1
#     [1, 2
#     ^
# SyntaxError: '[' was never closed
# Также существует другая встроенная функция exec, похожая на eval. Функция exec может выполнить строку так, как если бы
# эта строка была частью программы. Самое заметное различие между exec и eval заключается в том, что eval вычисляет и
# возвращает выражение, а exec может принимать выражения и инструкции (например, if...else...), но ничего не возвращает.
# Хотя обе функции наделяют приложение возможностью динамического генерирования кода, их некорректное использование
# создает угрозу для работоспособности приложения и даже компьютера. Например, функции exec можно передать строку
# "os.system('rm -rf *')", что приведет к удалению всех папок и файлов на вашем компьютере.
# Поэтому если ваше приложение должно обрабатывать строки динамически с использованием eval и exec, будьте очень
# внимательны. В качестве альтернативы eval можно рассмотреть модуль ast из стандартной библиотеки; функция literal_eval
# этого модуля выполняет безопасное вычисление строк.
# Применение eval без проверки целостности объекта строки может привести к ошибкам и даже катастрофическим последствиям.
# Будьте очень осторожны, когда вам приходится пользоваться этим способом.


# 2.2.4. Обсуждение
print('2.2.4. Обсуждение')
# При использовании конструктора float или int для получения фактических числовых значений, представляемых строкой,
# рассмотрите возможность применения try...except.... Успех преобразования никогда не гарантирован, а в случае неудачи
# программа завершится аварийно, если исключение не будет обработано.
# Будьте осторожны с применением eval для получения представляемых данных, потому что ненадежные источники опасны для
# программы. Если вы озабочены безопасностью данных, стоит подумать о самостоятельном разборе данных или об
# использовании таких проверенных средств, как модуль ast. Если вы работаете с собственными данными (например, пишете
# сценарий их обработки), для получения данных можно пользоваться eval.


# 2.2.5. Задача
print('2.2.5. Задача')
# В начале этого раздела вы узнали, как получить входные данные от пользователя при помощи функции input.
# Мэри - школьная учительница, которая хочет написать простую демонстрационную программу для своих учеников. Допустим,
# программа должна запрашивать температуру по Цельсию с консоли Python. Как ей написать программу, чтобы та
# удовлетворяла приведенным ниже требованиям? x - значение, введенное пользователем:
# - Если температура < 10 градусов, программа выводит сообщение: «You entered x degrees. It's cold!» (Вы ввели х
# градусов. Холодно!)
# - Если температура лежит в диапазоне от 10 до 25 градусов, программа выводит сообщение «You entered x degrees. It's
# cool!» (Вы ввели х градусов. Прохладно!)
# - Если температура > 25 градусов, программа выводит сообщение «You entered x degrees. It's hot!» (Вы ввели х градусов.
# Жарко!)
# - Значение x должно выводиться с точностью до одного знака в дробной части. Например, если пользователь вводит 15.75,
# значение должно выводиться в виде 15.8.
# ПОДСКАЗКА Введенную строку необходимо преобразовать в число с плавающей точкой, прежде чем сравнивать ее с другими
# числами. Для создания строкового вывода используйте f-строки. И не забывайте о спецификаторах формата!
# x = float(input())
x = 15.75
if x < 10:
    print(f'Вы ввели {x:0.1f} градусов. Холодно!')
elif 10 <= x <= 25:
    print(f'Вы ввели {x:0.1f} градусов. Прохладно!')
elif x > 25:
    print(f'Вы ввели {x:0.1f} градусов. Жарко!')


# 2.3. КАК ОБЪЕДИНЯТЬ И РАЗБИВАТЬ СТРОКИ
print('2.3. КАК ОБЪЕДИНЯТЬ И РАЗБИВАТЬ СТРОКИ')
# Строки не всегда хранятся в том формате, который вам нужен. В ряде случаев отдельные строки представляют разрозненные
# фрагменты взаимосвязанной информации, которые необходимо объединить в одну строку. Допустим, пользователь вводит
# несколько строк с названиями фруктов, которые ему нравятся. Эти строки можно объединить в одну строку со списком
# предпочтений пользователя:
# Исходный ввод
fruit0 = 'apple'
fruit1 = 'banana'
fruit2 = 'orange'
# Нужный вывод
liked_fruits = 'apple, banana, orange'
# В других ситуациях требуется разбить строку и создать несколько строк из ее частей. Скажем, пользователь вводит
# перечень стран, в которых он побывал, в одной строке. Требуется создать список с названиями стран:
# Исходный ввод
visited_countries = 'United States, China, France, Canada'
# Нужный вывод
countries = ['United States', 'China', 'France', 'Canada']


# 2.3.1. Объединение строк с пробельными символами
print('2.3.1. Объединение строк с пробельными символами')
# Для объединения строк используется оператор конкатенации - символ +, представленный в листинге 2.1. При наличии
# нескольких строковых литералов их можно объединять, если они разделяются пробельными символами (whitespaces):
# пробелами, табуляциями и символами новой строки.
# Допустим, в приложении используются разные конфигурации, определяющие стиль отображения информации. Конфигурации
# оформлены в виде строковых литералов, и эти отдельные настройки объединяются автоматически:
style_settings = 'font-size=large, ' 'font=Arial, ' 'color=black, ', 'align=center'
print(style_settings)  # ('font-size=large, font=Arial, color=black, ', 'align=center')
# Автоматическая конкатенация может выполняться только между строковыми литералами. Этот метод не применяется к
# строковым переменным или комбинациям строковых литералов и переменных. F-строки также поддерживают автоматическую
# конкатенацию. Эта возможность особенно полезна при построении длинных f-строк с разбиением строковых литералов на
# отдельные строки кода для ясности:
settings = {'font_size': 'large', 'font': 'Arial', 'color': 'black', 'align': 'center'}
styles = f"font-size={settings['font_size']}, "\
         f"font={settings['font']}, "\
         f"color={settings['color']}, "\
         f"align={settings['align']}"
# Если в программе используется длинная строка, рассмотрите возможность разбиения ее на несколько частей, каждая из
# которых представляет осмысленную подстроку. Если такие подстроки разделяются пробельными символами, они могут
# объединяться автоматически.


# 2.3.2. Объединение строк без ограничителей
print('2.3.2. Объединение строк без ограничителей')
# Объединение строк, разделенных пробелами, может сбивать с толку, потому что границы (пробелы) между строковыми
# литералами несколько усложняют зрительное восприятие отдельных строк. Более того, такие ограничители не могут
# встречаться внутри строковых литералов, что создает дополнительные затруднения. В общем случае идеальным вариантом
# становится объединение строк с произвольными ограничителями.
# Для выполнения конкатенации отдельных строк можно воспользоваться методом join:
style_settings = ['font-size=large', 'font=Arial', 'color=black', 'align=center']
merged_style = ', '.join(style_settings)
print(merged_style)  # font-size=large, font=Arial, color=black, align=center
# Метод join получает список строк. Элементы этого списка соединяются последовательно со строкой-ограничителем,
# использованной при вызове метода. Хотя в данном случае используется объект списка, в более общем варианте это может
# быть произвольный итерируемый объект, например кортеж или множество.
# По сравнению с прямой конкатенацией метод join лучше читается, так как строки-компоненты являются отдельными
# элементами и читателю кода проще увидеть, что именно объединяется. Важным является следующее дополнительное
# преимущество join: вы можете динамически обрабатывать элементы объекта list.
# Допустим, вы хотите создать в таск-менеджере строку с перечнем задач, которые необходимо выполнить за неделю.
# Изначально задачи хранятся в виде строк в элементах списка. Объединяя эти строки, можно сгенерировать список и
# отображать его на рабочем столе как напоминание:
tasks = ['Homework', 'Grocery', 'Laundry', 'Museum Trip', 'Buy Furniture']
note = ', '.join(tasks)
print('Remaining Tasks:', note)  # Remaining Tasks: Homework, Grocery, Laundry, Museum Trip, Buy Furniture
# После того как пользователь выполнит часть задач, эти задачи удаляются из списка:
tasks.remove('Buy Furniture')
tasks.remove('Homework')
# После удаления задач вы все еще можете воспользоваться методом join для создания необходимой строки:
print('Remaining Tasks: ', ', '.join(tasks))  # Remaining Tasks:  Grocery, Laundry, Museum Trip
# В этом примере продемонстрированы сценарии использования со списками строк, которые могут изменяться динамически.
# С появлением дополнительных задач можно включать их в объект list и заново генерировать обновленную строку методом
# join.


# 2.3.3. Разбиение строк для создания списка
print('2.3.3. Разбиение строк для создания списка')
# Для сохранения и передачи данных часто используются текстовые файлы. Например, табличные данные можно сохранить в
# текстовом файле, чтобы каждая строка представляла отдельную запись. При чтении текстового файла каждой записи данных
# соответствует одна строка, содержащая несколько подстрок, а каждая подстрока представляет значение некоторого поля.
# Чтобы обработать данные, необходимо разбить строку и извлечь эти значения в отдельные подстроки.
# Предположим, у нас есть текстовый файл с именем "task_data.txt", в котором хранятся описания задач. Каждая строка
# представляет информацию по отдельной задаче, как показано в следующем фрагменте: идентификатор, название и уровень
# важности. Так как чтение данных из файла рассматривается далее, в главе 11, будем считать, что вы уже прочитали
# текстовые данные и сохранили их в многострочной строке в тройных кавычках:
task_data = """1001,Homework,5
1002,Laundry,3
1003,Grocery,4"""
# Для создания строк в тройных кавычках, охватывающих несколько физических строк, могут использоваться как одинарные,
# так и двойные кавычки. Синтаксис тройных кавычек также поддерживается для многострочных f-строк.
# Для обработки таких строк мы воспользуемся методом split, который ищет заданные ограничители и разбивает по ним
# строку. Возможное решение приведено в листинге 2.5 (test_0005.py).
# У метода split есть ограничение: он позволяет задать только один разделитель, что может привести к проблемам при
# разбиении строк с разными разделителями. Допустим, в текстовом файле в качестве разделителей используются как запятые,
# так и символы подчеркивания. Упрощая задачу, примем, что между словами используется только один разделитель.
# Для демонстрации возьмем следующую строку данных:
messy_data = 'process,messy_data_mixed,separators'
# Рассмотрим альтернативные решения.
# 1 - Последовательное применение разделителей:
#  a) Строки разбиваются по запятым, в результате разбиения создается список.
#  б) Проверяем, содержат ли элементы списка символы подчеркивания. Если их нет, значит, элемент готов к дальнейшей
#  обработке. Если они есть, выполняется второе разбиение по подчеркиваниям:
separated_words0 = []
for word in messy_data.split(","):
    if word.find("_") < 0:  # Если совпадение не найдено, результат будет равен –1
        separated_words0.append(word)
    else:
        separated_words0.extend(word.split("_"))  # Метод extend присоединяет все элементы разделенных строк
print(separated_words0)
# 2 - Консолидация разделителей:
# Так как мы знаем, что существуют всего два возможных разделителя, один разделитель можно преобразовать в другой. Это
# позволит вызвать метод split всего один раз для завершения нужной операции:
# consolidated = messy_data.replace(",", "_")  # Использует метод replace для замены подстроки
# separated_words1 = consolidated.split("_")
# Эти два решения просты и прямолинейны. При хорошем знании базовых операций со строками и списками они окажутся
# идеальными в случае, если быстродействие не критично, потому что они потребуют нескольких проходов для проверки
# разделителей.
# Регулярные выражения - последовательности символов, описывающие условия поиска. Их часто сокращают как regex (от
# regular expressions).


# 2.3.4. Обсуждение
print('2.3.4. Обсуждение')
# Выбор между конкатенацией строк, f-строками или join должен определяться для каждого конкретного случая. Главный
# критерий - удобочитаемость кода. Если вам нужно объединить небольшое количество строк, используйте операторы
# конкатенации. Если строк много, рассмотрите возможность применения f-строк для группировки взаимосвязанных строк.
# Метод join особенно полезен для объединения отдельных строк, сохраненных в итерируемом объекте.
# Кроме split, есть также метод rsplit со сходной функциональностью. Единственное его отличие связано со способом
# задания параметра maxsplit, определяющего максимальное количество элементов, которые могут быть созданы в результате
# разбиения.


# 2.3.5. Задача
print('2.3.5. Задача')
# Ниже приведены сигнатуры методов split и rsplit. Оба метода получают аргументы с разделителем и максимальным
# количеством создаваемых элементов.
# Напишите несколько строк, с которыми эти методы будут работать одинаково или по-разному.
# str.split(separator, maxsplit)
# str.rsplit(separator, maxsplit)
# В общем случае оба метода работают одинаково. Различия проявляются тогда, когда количество элементов, полученных в
# результате разбиения, оказывается выше максимального.


# 2.4. КАКИЕ ВОЗМОЖНОСТИ ПРЕДОСТАВЛЯЮТ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
print('2.4. КАКИЕ ВОЗМОЖНОСТИ ПРЕДОСТАВЛЯЮТ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ')
# Класс str в Python содержит такие полезные методы для поиска подстрок, как find и rfind. Впрочем, во многих
# практических ситуациях их возможности оказываются недостаточными, особенно когда речь заходит о сложном поиске по
# шаблону.
# Решение с помощью регулярных выражений может выглядеть так:
messy_data = 'process,messy_data_mixed,separators'
regex = re.compile(r'[,_]')  # Компилирует регулярное выражение
separated_words2 = regex.split(messy_data)
print(separated_words2)
# Отметим, что строка для завершения разбиения обходится только один раз. С несколькими разделителями регулярные
# выражения работают намного эффективнее двух других решений (раздел 2.3.3), требующих нескольких проходов по строке.
# Регулярные выражения не привязаны к конкретному языку. Они поддерживаются всеми распространенными языками
# программирования, хотя синтаксис их реализации может иметь некоторые различия. Однако сами регулярные выражения
# остаются практически неизменными; можно считать, что в разных языках программирования используются разные диалекты
# регулярных выражений.


# 2.4.1. Работа с регулярными выражениями в Python
print('2.4.1. Работа с регулярными выражениями в Python')
# Стандартная библиотека Python включает модуль re с функциональностью, связанной с регулярными выражениями. Существуют
# два варианта использования этого модуля. Первый вариант относится к аспектам объектно-ориентированного
# программирования (ООП) в Python. Применяя парадигму ООП к регулярным выражениям, вы выполняете операции с объектами
# Pattern. В этом варианте вы сначала создаете объект Pattern, компилируя заданный строковый шаблон. Затем объект
# Pattern используется для поиска частей текста, соответствующих шаблону.
# ООП (объектно-ориентированное программирование) - модель программной архитектуры, в которой центральное место занимают
# данные и объекты (вместо функций и процедур).
# Следующий фрагмент кода показывает, как применить парадигму ООП для поиска по шаблону с применением регулярных
# выражений:
regex = re.compile('do')     # Создает шаблон
regex.pattern                # Обращается к атрибутам
regex.search('do homework')  # Использует методы
print(regex.findall("don't do that"))
# В другом стиле применяется функциональный подход. Вместо того чтобы создавать объект Pattern, мы вызываем функции
# непосредственно из модуля.
# При вызове функции задается шаблон, а также строка, к которой этот шаблон применяется:
# re.search('pattern', 'the string to be searched')
# re.findall('pattern', 'the string to be searched')
# Во внутренней реализации при вызове re.search Python сам создает объект Pattern и вызывает метод search для шаблона.
# Таким образом, использование модуля для вызова функций становится удобным способом работы с регулярными выражениями.
# Однако следует учитывать, что при создании объекта Pattern функцией compile откомпилированный шаблон кэшируется, а
# многократное использование шаблона становится более эффективным, потому что шаблон не нужно компилировать повторно.
# Механизм кэширования используется в программировании (и компьютерных вычислениях вообще) для временного хранения
# данных, чтобы будущие запросы этих данных обслуживались быстрее.
# С другой стороны, с функциональным подходом шаблон создается «на ходу», и преимущества от повышения эффективности за
# счет кэширования теряются. Поэтому если вы собираетесь использовать шаблон однократно, о различиях этих двух подходов
# можно не задумываться.


# 2.4.2. Определение шаблона в виде необработанной строки
print('2.4.2. Определение шаблона в виде необработанной строки')
# Мощь регулярных выражений проявляется прежде всего в компактности шаблона, описывающего широкий диапазон возможностей.
# Для создания шаблона часто приходится использовать необработанные (raw) строки, например строковый литерал с префиксом
# r (r'шаблон'). В этом разделе вы увидите, почему необходимо использовать необработанные строки для построения шаблонов
# регулярных выражений.
# В регулярных выражениях \d обозначает любую цифру, а \w - символ слова в Юникоде. Это примеры специальных символов в
# регулярных выражениях, а префикс \ указывает, что эти символы имеют особый смысл помимо того, чем они кажутся на
# первый взгляд. В строках Python символ \ также используется для обозначения специальных символов, например \t для
# табуляции, \n для новой строки или \\ для обратного слеша.
# Когда эти обозначения объединяются в строках, появляются шаблоны довольно странного вида. Допустим, вы хотите найти
# подстроку \task. Следует заметить, что \t в данном случае является литералом; эти два символа действительно обозначают
# символ обратного слеша и букву t, а не символ табуляции. Чтобы Python мог искать подстроку \task, необходимо
# использовать обозначение \\task. Ситуация дополнительно усложняется тем, что при создании такого шаблона оба символа \
# должны экранироваться, из-за чего при поиске \task необходимо использовать четыре символа обратного слеша (\\\\task).
# Вам это кажется странным? Возьмем следующий код:
task_pattern = re.compile('\\\\task')
texts = ['\task', '\\task', '\\\task', '\\\\task']
for text in texts:
    print(f'Match {text!r}: {task_pattern.match(text)}')

# Выводимые строки:
# Match '\task': None
# Match '\\task': <re.Match object; span=(0, 5), match='\\task'>
# Match '\\\task': None
# Match '\\\\task': None
# Как видно из вывода, шаблон совпадает только с "\\task". Это вполне логично:
# два последовательных обратных слеша \\ интерпретируются как литерал \, и строка фактически превращается в "\task", что
# совпадает с искомым шаблоном.
# Очевидно, лишние символы \ создают путаницу. Для решения этой проблемы мы используем синтаксис необработанных строк,
# чтобы Python не обрабатывал лишние символы \. Как и в случае с f-строками, строка снабжается специальным префиксом r,
# чтобы обычный строковый литерал превратился в необработанную строку. Применяя необработанные строки к шаблону, мы
# получаем следующее решение:
task_pattern_r = re.compile(r'\\task')
texts = ['\task', '\\task', '\\\task', '\\\\task']
for text in texts:
    print(f'Match {text!r}: {task_pattern_r.match(text)}')

# Выводимые строки:
# Match '\task': None
# Match '\\task': <re.Match object; span=(0, 5), match='\\task'>
# Match '\\\task': None
# Match '\\\\task': None
# Как видно из вывода, необработанная строка определяет более понятный шаблон, чем литерал обычной строки с четырьмя
# последовательными символами \. Легко представить, что при построении более сложного шаблона для обозначения
# специальных символов потребуется еще больше символов \. Без необработанных строк ваши шаблоны превратятся в
# головоломку. Таким образом, для создания шаблонов регулярных выражений всегда рекомендуется применять необработанные
# строки.
# УДОБОЧИТАЕМОСТЬ Использование необработанных строк для построения шаблонов избавляет вас от необходимости экранировать
# специальный символ \ и делает шаблон более понятным.


# 2.4.3. Основы синтаксиса регулярных выражений
print('2.4.3. Основы синтаксиса регулярных выражений')
# Границы строк
print('Границы строк')
# При работе со строками иногда имеет значение, что строка начинается или заканчивается определенным шаблоном.
# В подобных ситуациях для обозначения привязки к границам строк используются якорные символы (boundary anchors), как
# показано в следующем фрагменте:
# ^hi        начинается с подстроки hi
# task$      заканчивается подстрокой task
# ^hi task$  начинается и заканчивается подстрокой "hi task" (точное совпадение)
# Символ ^ означает, что совпадение шаблона должно находиться в начале строки, а символ $ - в конце. Ниже приведены
# примеры использования некоторых якорей:
print(re.search(r"^hi", "hi Python"))             # Вывод: <re.Match object; span=(0, 2), match='hi'>
print(re.search(r"task$", "do the task"))         # Вывод: <re.Match object; span=(7, 11), match='task'>
print(re.search(r"^hi task$", "hi task"))         # Вывод: <re.Match object; span=(0, 7), match='hi task'>
print(re.search(r"^hi task$", "hi Python task"))  # Вывод: None (omitted output in an interactive console)
# Возможно, вам известны методы startswith и endswith класса str, которые работают в простых случаях. Но для более
# сложных ситуаций, например если потребуется найти строку, начинающуюся с одного или нескольких вхождений h, за
# которыми следует i, - метод startswith не подходит, потому что приходится учитывать возможности hi, hhi, hhhi и т. д.
# В таких ситуациях регулярные выражения чрезвычайно полезны.
# СОПРОВОЖДАЕМОСТЬ Прежде чем обращаться ко всей мощи регулярных выражений, стоит подумать, не удастся ли обойтись более
# простым решением, например с startswith или endswith. Такие решения получаются более простыми и надежными.

# Квантификаторы
print('Квантификаторы')
# В предыдущем разделе упоминалась проблема поиска переменного количества символов, для чего требуется создавать шаблоны
# с возможностью задания количества вхождений. Для решения этой проблемы в регулярных выражениях существует категория
# так называемых квантификаторов. В эту категорию входят следующие специальные символы:
# hi?      за h следует ноль или одно вхождение i
# hi*      за h следует ноль или несколько вхождений i
# hi+      за h следует одно или несколько вхождений i
# hi{3}    за h следует iii
# hi{1,3}  за h следует i, ii или iii
# hi{2,}   за h следует 2 или более вхождения i
# Как показано в этом фрагменте, существуют четыре общих квантификатора: 
# ? - 0 или 1, 
# * - 0 и более, 
# + - 1 и более, 
# {} - диапазон. 
# Отметим важный момент:
# поиск совпадений для ?, * и + является максимальным («жадным»), то есть при поиске ищется совпадение максимально
# возможной длины. Чтобы изменить это поведение по умолчанию, к квантификаторам можно присоединить суффикс ?:
test_string = 'h hi hii hiii hiiii'
test_patterns = [r'hi?', r'hi*', r'hi+', r'hi{3}', r'hi{2,3}', r'hi{2,}', r'hi??', r'hi*?', r'hi+?', r'hi{2,}?']
for pattern in test_patterns:
    print(f'{pattern: <9}--> {re.findall(pattern, test_string)}')
# Выводимые строки:
# hi?      --> ['h', 'hi', 'hi', 'hi', 'hi']
# hi*      --> ['h', 'hi', 'hii', 'hiii', 'hiiii']
# hi+      --> ['hi', 'hii', 'hiii', 'hiiii']
# hi{3}    --> ['hiii', 'hiii']
# hi{2,3}  --> ['hii', 'hiii', 'hiii']
# hi{2,}   --> ['hii', 'hiii', 'hiiii']
# hi??     --> ['h', 'h', 'h', 'h', 'h']
# hi*?     --> ['h', 'h', 'h', 'h', 'h']
# hi+?     --> ['hi', 'hi', 'hi', 'hi']
# hi{2,}?  --> ['hii', 'hii', 'hii']
# Результаты поиска соответствуют ожидаемым. Обратите внимание на использование в нескольких последних шаблонах суффикса
# ?, при наличии которого шаблон совпадает не с самой длинной, а с самой короткой возможной последовательностью.

# Символьные классы и множества
print('Символьные классы и множества')
# Гибкость регулярных выражений обусловлена простотой использования нескольких символов для обозначения различных
# возможностей. При описании необработанных строк в разделе 2.4.2 я упоминал о том, что последователь ность \d может
# представлять любую цифру. В регулярных выражениях также могут задаваться другие символьные множества.
# \d - любая десятичная цифра
# \D - любой символ, не являющийся десятичной цифрой
# \s - любой пробельный символ, включая пробел, \t, \n, \r, \f, \v
# \S - любой символ, не являющийся пробельным
# \w - любой символ слова: алфавитно-цифровой или символ подчеркивания
# \W - любой символ, не являющийся символом слова
# .  - любой символ, кроме новой строки
# [] - множество перечисленных символов
# Заслуживают особого внимания некоторые моменты, относящиеся к использованию [] с символьными множествами:
# - Во множествах можно перечислять отдельные символы. [abcxyz] совпадает с любым из этих шести символов, а [0z]
#  совпадает с "0" и "z".
# - Допускается включение интервалов символов. Так, [a-z] совпадает с любым символом от "a" до "z", а [A-Z] совпадает с
# любым символом от "A" до "Z".
# - Также допускается перечисление нескольких интервалов. [a-dw-z] совпадает с любым символом от "a" до "d", и от "w"
# до "z".
# Чтобы запомнить, что делает каждый символ, рассмотрим несколько конкретных примеров, как в следующем фрагменте кода:
test_text = '#1$2m_ M\t'
patterns = ['\\d', '\\D', '\\s', '\\S', '\\w', '\\W', '.', '[lmn]']
for pattern in patterns:
    print(f'{pattern: <9}---> {re.findall(pattern, test_text)}')
# Инвертированные классы - своего рода отрицания существующих символьных классов. Например, \d совпадает с любой цифрой,
# а \D совпадает с любым символом, который не является цифрой. Использование тех же букв в верхнем регистре поможет
# запомнить смысл инвертированных классов.

# Логические операторы
print('Логические операторы')
# В регулярных выражениях, как и в других языках программирования, существуют логические операции, которые используются
# для определения шаблонов.
# Самыми популярными из этих операций являются:
# a|b   - a или b
# (abc) - abc как группа
# [^a]  - любой символ, кроме a
# Круглые скобки используются для перечисления символов, которые должны присутствовать для совпадения, а знак ^ создает
# символьное множество инвертированием заданного множества. Например, чтобы найти любой символ, отличный от s,
# используйте запись [^s]. Вот несколько примеров:
print(re.findall(r'a|b', 'a c d d b ab'))    # Вывод: ['a', 'b', 'a', 'b']
print(re.findall(r'a|b', 'c d d b'))         # Вывод: ['b']
print(re.findall(r'(abc)', 'ab bc abc ac'))  # Вывод: ['abc']
print(re.findall(r'(abc)', 'ab bc ac'))      # Вывод: []
print(re.findall(r'[^a]', 'abcde'))          # Вывод: ['b', 'c', 'd', 'e']


# 2.4.4. Анализ совпадений
print('2.4.4. Анализ совпадений')
# После того как вы освоите построение шаблонов, возникает задача поиска всех совпадений, как было сделано с методом
# findall (раздел 2.4.3). Метод findall оказывается наиболее удобным тогда, когда текст имеет небольшую длину и вы
# можете легко определить, где находятся совпадения. В реальных проектах часто приходится иметь дело с большими объемами
# текста, так что простой вывод описания совпадений пользы не принесет. Однако необходимо знать, где находятся
# совпадения, в каком именно тексте. Для таких ситуаций существуют объекты Match. В этом разделе вы научитесь работать с
# совпадениями.

# Создание объектов Match
print('Создание объектов Match')
# Методы match и search часто используются для поиска по шаблону. Различаются они прежде всего тем, где ведется поиск.
# Метод match проверяет, существует ли совпадение в начале строки; метод search сканирует строку, пока не найдет
# совпадение (если оно существует). Несмотря на это различие, оба метода возвращают объект Match при обнаружении
# совпадения. Для знакомства с объектами Match возьмем пример с вызовом метода search:
match = re.search(r"(\w\d)+", "xyza2b1c3dd")
print(match)  # Вывод: <re.Match object; span=(3, 9), match='a2b1c3'>
# Ключевые атрибуты объекта Match - совпадение в строке и диапазон символов.
# Для их получения можно воспользоваться соответствующими методами group, span, start и end, как показано в листинге 2.6
# (test_0006.py).
# При использовании регулярных выражений некоторые операции выполняются только в том случае, если в тексте найдено
# совпадение. Для упрощения программирования объект Match интерпретируется как True в условных инструкциях.
# В общем случае использование Match выглядит так:
match = re.match('pattern', 'string to match')
if match:
    print('do something with the matched')
else:
    print('found no matches')
# УДОБОЧИТАЕМОСТЬ При использовании if...else... с регулярными выражениями можно включить объект Match прямо в условие
# if, так как объект Match интерпретируется как True.

# Работа с группами
print('Работа с группами')
# Вам может показаться странным получение информации вызовом методов вместо атрибутов: match.span() вместо match.span.
# Если вас заинтересовало, почему это так, значит, у вас хорошее чувство принципов ООП. Я согласен с тем, что с позиций
# ООП данные было бы естественно представлять атрибутами. Однако эта функциональность реализована вызовами методов,
# потому что поиск по шаблону может привести к нахождению нескольких групп. Внимательно присмотревшись к листингу 2.6
# (test_0006.py), вы увидите, что для получения строки совпадения используется метод group. Хотите узнать, когда
# совпадение может состоять из нескольких групп?
# Рассмотрим пример:
match = re.match(r'(\w+), (\w+)', 'Homework, urgent; today')
print(match)           # Вывод: <re.Match object; span=(0, 16), match='Homework, urgent'>
print(match.groups())  # Вывод: ('Homework', 'urgent')
print(match.group(0))  # Вывод: 'Homework, urgent'
print(match.group(1))  # Вывод: 'Homework'
print(match.group(2))  # Вывод: 'urgent'
# В этом шаблоне определены две группы (заключенные в круглые скобки), каждая из которых ищет один или несколько
# символов слов, разделенных запятой и пробелом. Как упоминалось ранее, поиск совпадения ведется в максимальном режиме,
# поэтому самым длинным возможным совпадением оказывается 'Homework, urgent'. Это совпадение создает группы,
# соответствующие тем, которые определены в шаблоне.
# По умолчанию группа 0 соответствует полному совпадению. Дальнейшие группы определяются группами внутри шаблона. Так
# как в результате поиска могут присутствовать совпадения для нескольких групп, для получения информации каждой группы
# лучше использовать методы вместо атрибутов, которые не могут получать аргументы. Аналогичная группировка также
# применима к span:
print(match.span(0))  # Вывод: (0, 16)
print(match.span(1))  # Вывод: (0, 8)
print(match.span(2))  # Вывод: (10, 16)


# 2.4.5. Часто используемые методы
print('2.4.5. Часто используемые методы')
# Чтобы эффективно использовать регулярные выражения в проектах, необходимо знать, какая функциональность нам доступна.
# В табл. 2.3 перечислены ключевые методы, для каждого из которых приводится пояснительный пример.
# Таблица 2.3. Часто используемые методы регулярных выражений
# search - возвращает объект Match, если совпадение найдено в любой позиции строки
print(re.search(r'\d+', 'ab12xy'))  # Вывод: <re.Match object; span=(2, 4), match='12'>
print(re.search(r'\d+', 'abxy'))    # Вывод: None
# match - возвращает Match только в том случае, если совпадение находится в начале строки
print(re.match(r'\d+', 'ab12xy'))   # Вывод: None
print(re.match(r'\d+', '12abxy'))   # Вывод: <re.Match object; span=(0, 2), match='12'>
# findall - возвращает список строк, совпадающих с шаблоном. Если шаблон состоит из нескольких групп, то элементы списка
# представляют собой кортежи
print(re.findall(r'h[ie]\w', 'hi hey hello'))  # Вывод: ['hey', 'hel']
print(re.findall(r'(h|H)(i|e)','Hey hello'))   # Вывод: [('H', 'e'), ('h', 'e')]
# finditer - возвращает итератор*, поставляющий объекты Match
# * Итератором называется объект, содержимое которого можно перебирать (например, в цикле for). Итераторы
# рассматриваются в главе 5.
print(re.finditer(r'(h|H)(i|e)','hi Hey hello'))  # Вывод: <callable_iterator object at 0x7feac8375480>
# split - разбивает строку по шаблону
print(re.split(r'\d+', 'a1b2c3d4e'))  # Вывод: ['a', 'b', 'c', 'd', 'e']
# sub - создает строку с заменой совпадений другой строкой
print(re.sub(r'\D', '-', '123,456_789'))  # Вывод: '123-456-789'
# Подчеркну ключевые моменты, касающиеся использования методов из табл. 2.3.
# - Методы search и match определяют один объект Match. Главное различие заключается в том, что match привязывается к
# началу строки, а search сканирует строку, и совпадение в середине строки также считается допустимым.
# - Когда вы пытаетесь найти все совпадения, метод findall возвращает все совпадения без информации об их
# местонахождении. Поэтому обычно используется finditer. Метод возвращает итератор, который генерирует каждый объект
# Match с более содержательной информацией о совпадении (например, его местонахождение).
# - Метод split разбивает строку по всем совпавшим шаблонам. Также можно задать максимальное количество возможных
# разбиений.
#  - Имя метода sub происходит от 'substitute' (подстановка), и этот метод используется для замены любого найденного
#  совпадения заданным заменителем. В нетривиальном варианте можно задать вместо строкового литерала функцию, которая
#  получает в аргументе объект Match для производства требуемой замены.


# 2.4.6. Обсуждение
print('2.4.6. Обсуждение')
# Ключевые этапы использования регулярных выражений: 
# (1) создание шаблона, 
# (2) поиск совпадений, 
# (3) обработка совпадений. 
# Эти этапы должны базироваться на четком понимании конкретных требований к производимой обработке текста. Попробуйте
# взглянуть на шаблон на более высоком уровне обобщения. Должен ли он содержать якоря, квантификаторы или символьные
# множества? Затем перейдите на уровень синтаксиса этих категорий. Будьте готовы к тому, что ваш шаблон не будет
# работать так, как вы ожидаете. Шаблон необходимо протестировать поиском совпадений на подмножестве текстов. Почти
# всегда обнаруживаются какие-нибудь граничные случаи, которые окажутся для вас неожиданными. Убедитесь в том, что эти
# редкие случаи учтены в шаблоне, прежде чем запускать свой код в продакшен.


# 2.4.7. Задача
print('2.4.7. Задача')
# Джерри - студент магистратуры. Один из его проектов требует извлечения данных из текста. Допустим, текстовые данные
# имеют вид 'abc_,abc__,abc,,__abc_,_abc', где abc - искомые значения данных. Иначе говоря, значения данных разделяются
# одним или несколькими разделителями. Как использовать регулярные выражения для извлечения данных?
print(re.split(r'[_,]+', 'abc_,abc__,abc,,__abc_,_abc'))
# ПОДСКАЗКА Если вам понадобится создать шаблон с переменным количеством символов, не забывайте о квантификаторах.


# 2.5. КАК ИСПОЛЬЗОВАТЬ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ ДЛЯ ОБРАБОТКИ ТЕКСТА
print('2.5. КАК ИСПОЛЬЗОВАТЬ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ ДЛЯ ОБРАБОТКИ ТЕКСТА')
# Регулярные выражения - не самая простая для понимания тема, потому что она связана с созданием общих шаблонов, которые
# могут подходить для множества разных ситуаций. В большинстве случаев шаблон выглядит абстрактно и приводит в
# замешательство неопытных программистов. Не огорчайтесь, если что-то покажется вам непонятным; освоение регулярных
# выражений требует времени. Разобравшись в них, вы поймете, насколько это мощный инструмент для обработки текстовых
# данных.
# В качестве примера возьмем приложение для управления задачами (таскменеджер). Допустим, у вас имеется текст,
# приведенный в листинге 2.7 (test_0007.py). Этот текст содержит данные, восстановленные после сбоя базы данных, с
# множеством допустимых записей задач, но к сожалению, в данных местами встречается случайный текст.
# Вам поручено извлечь все действительные записи из текстовых данных, а все недействительные удалить. Предположим, текст
# состоит из нескольких тысяч строк, так что обработать его вручную нереально. Для выполнения работы необходимо
# использовать общее решение с поиском по шаблону - именно для таких целей создавались регулярные выражения. В этом
# разделе будут рассмотрены ключевые этапы решения задачи.


# 2.5.1. Создание шаблона для поиска совпадений
print('2.5.1. Создание шаблона для поиска совпадений')
# Строка, приведенная в листинге 2.7 (test_0007.py), напоминает о важности стандартной операции при работе с текстами -
# очистке данных. Часто нужные данные в тексте чередуются с ненужными. Вам необходимо реализовать программное решение
# с использованием регулярных выражений, которое оставит только нужные данные. В этом разделе рассматривается первый шаг
# - создание шаблона.
# Внимательно изучив необработанные данные, вы замечаете, что действительные записи состоят из трех групп:
# идентификатора задачи из трех цифр, названия задачи и описания задачи. Первые две группы разделяются запятой, а две
# последние - символом ';' (точка с запятой). На основании этой информации можно построить следующий шаблон, в котором
# подробно описывается каждый компонент:
# r"(\d{3}), (\w+); (.+)"
# '(\d{3})' - группа из 3 цифр
# ', '      - строковые литералы, запятая и пробел
# '(\w+)'   - группа из одного или нескольких символов слова
# '; '      - строковые литералы, точка с запятой и пробел
# '(.+)'    - группа из одного или нескольких символов слова
# Применяя этот шаблон к текстовым данным, легко представить, как будет выглядеть результат. На этой стадии не
# беспокойтесь об обработке совпадений, потому что сейчас нужно просто убедиться в том, что шаблон работает как
# предполагалось. После того как вы несколько раз протестируете и измените шаблон, выполните следующий код, прежде чем
# остановиться на окончательной версии шаблона:
# Как упоминалось в разделе 2.4.4, важная особенность объекта Match заключается в том, что при его вычислении
# возвращается значение True; это позволяет нам работать с объектом Match только в том случае, если он был создан при
# вызове метода match. Вывод показывает, что из объектов совпадений можно извлечь нормальные записи. С другой стороны,
# там, где совпадения не найдены, записи действительно некорректны.


# 2.5.2. Извлечение данных из совпадений
print('2.5.2. Извлечение данных из совпадений')
# Поскольку шаблон работает так, как предполагалось, пришло время извлечь данные и подготовить их к дальнейшей
# обработке. Выражаясь конкретнее, требуется сохранить каждую запись (идентификатор, название и описание) в объекте
# кортежа tuple, а затем объединить объекты tuple в объект list.
# При построении шаблона вы определили три разные группы для каждого из трех полей данных задачи. Эти группы позволяют
# обращаться к отдельным совпадениям каждой группы.
# Использование групп продемонстрировано в листинге 2.8 (test_0008.py).
# Как показано в листинге 2.8 (test_0008.py), мы используем метод group и обращаемся к трем найденным группам по
# номерам:
# - группа 1 для идентификатора,
# - группа 2 для названия,
# - группа 3 для описания.
# Попутно заметим, что если параметр метода group не указан, будет получено все совпадение по всем группам
# (раздел 2.4.4).
# В нашем примере шаблон состоит из трех групп, но с усложнением структуры записей приходится иметь дело с большим
# количеством групп. Обращение к группам по номерам повышает риск ошибок; слишком легко ошибиться на единицу, что может
# привести к неожиданным последствиям.
# Нет ли более удобного решения? Этот вопрос подводит нас к обсуждению в разделе 2.5.3.


# 2.5.3. Использование именованных групп для обработки текста
print('2.5.3. Использование именованных групп для обработки текста')
# В общем случае текст предоставляет больше семантической информации, чем числа. Если обращения к группам по номерам
# создают путаницу, нельзя ли использовать текст для ссылок на группы? К счастью, в Python поддерживаются так называемые
# именованные группы. По сути, они позволяют назначить имя группе так, чтобы к ней можно было обращаться по имени при
# последующей обработке.
# Для присвоения имен группам используется синтаксис (?P<имя_группы>шаблон), назначающий группе шаблона имя_группы.
# Имя должно быть действительным идентификатором Python. После этого вы сможете воспользоваться функциональностью
# именованных групп для обновления кода из листинга 2.8 (test_0008.py), как показано в листинге 2.9 (test_0009.py).
# В этом фрагменте кода трем группам присваиваются имена task_id, task_title и task_desc, ясно обозначающие данные
# каждой группы. Далее, вместо того чтобы передавать целое число методу group, мы указываем имя группы. По сравнению
# с реализацией из листинга 2.8 (test_0008.py), именованные группы из листинга 2.9 (test_0009.py) упрощают чтение кода;
# что еще более важно, они снижают риск случайного обращения не к той группе, особенно если шаблон содержит много групп.
# СОПРОВОЖДАЕМОСТЬ Всегда используйте содержательные идентификаторы для назначения имен переменных или любых объектов.
# Такой подход не только упрощает чтение кода, но и снижает количество возможных ошибок: чтобы понять, с какими данными
# вы имеете дело, достаточно взглянуть на их имена.
# Хотя мы используем метод group для обращения к отдельным элементам из найденных групп, именованные группы
# предоставляют другой способ получения данных — метод groupdict. Для первого найденного совпадения результат может
# выглядеть так:
# match.groupdict()
# Вывод: {'task_id': '101', 'task_title': 'Homework', 'task_desc': 'Complete physics and math'}
# Если вы предпочтете использовать этот объект dict для обработки данных, это улучшит удобочитаемость кода.


# 2.5.4. Обсуждение
print('2.5.4. Обсуждение')
# Первым шагом при использовании регулярных выражений является определение того, чего вы хотите добиться, и создание
# соответствующего шаблона. Не стоит с одержимостью пытаться построить правильный шаблон с первой попытки. Шаблон
# необходимо опробовать на тексте; возможно, для нахождения правильного шаблона потребуется несколько циклов проб и
# ошибок.
# Если вы работаете с большим количеством групп, определенных в шаблоне, я рекомендую использовать именованные группы,
# так как при указании имени группы вы однозначно сообщаете читателю кода, какие данные в ней содержатся. Кроме того, в
# дальнейшем и вам будет удобнее обращаться к группам по содержательным именам.


# 2.5.5. Задача
print('2.5.5. Задача')
# При обработке текстовых данных с извлечением записей мы разбиваем текст на отдельные строки. Предположим, каждая
# строка либо содержит одну действительную запись, либо не содержит ни одной. Сможете ли вы найти шаблон, который
# обрабатывает весь текст без разбиения данных на множество строк?
# ПОДСКАЗКА Каждая строка завершается символом новой строки (\n). Включите этот символ в свой шаблон.


# ИТОГИ
print('ИТОГИ')
# - F-строки предоставляют компактные средства интерполяции переменных и выражений.
# - Выравнивание текста в f-строке упрощает восприятие информации за счет создания визуальных границ для разных данных.
# - F-строки хорошо подходят для форматированных чисел, в частности для научной записи и для ограниченного количества
# знаков в дробной части.
# - Для строк Python существуют методы isalnum, isnumeric и много других is-методов. Вы можете использовать их для
# определения природы содержимого строки.
# - Все данные Python, включая целые числа и списки, могут представляться в строковом виде (например, при передаче по
# интернету данных в строковом формате). При преобразовании этих строк к исходному типу данных мы вычисляем их, чтобы в
# дальнейшем применить к результатам методы конкретных типов.
# - Для объединения небольшого количества строк можно воспользоваться знаками конкатенации. Но при работе с множеством
# строк лучше выбрать метод join.
# - Метод split предназначен для разбиения строк. Он является полезным средством обработки данных, а также основой для
# обработки текстовых файлов, содержащих данные с разделителями. Хотя для этих задач существуют встроенные модули
# (например, csv), хорошее знание основ сыграет важную роль при самостоятельном написании сценариев.
# - Ключом к использованию регулярных выражений становится построение шаблона, соответствующего вашим потребностям. При
# построении шаблона следует мыслить на высоком уровне обобщения. Вот некоторые важные вопросы, на которые следует
# ответить: нужно ли использовать группы? А как насчет якорей, символьных множеств или квантификаторов?
# - Именованные группы упрощают обращение к конкретной информации, когда регулярные выражения используются для обработки
# сложных текстовых данных.
