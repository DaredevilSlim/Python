#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Глава 2
# Обработка и формирование строк
print('Обработка и формирование строк')


# 2.1. КАК ИСПОЛЬЗОВАТЬ F-СТРОКИ ДЛЯ ИНТЕРПОЛЯЦИИ И ФОРМАТИРОВАНИЯ
print('2.1. КАК ИСПОЛЬЗОВАТЬ F-СТРОКИ ДЛЯ ИНТЕРПОЛЯЦИИ И ФОРМАТИРОВАНИЯ')


# 2.1.1. Форматирование строк до появления f-строк
print('2.1.1. Форматирование строк до появления f-строк')
# Класс str работает с текстовыми данными через свои экземпляры, которые мы будем называть строковыми переменными.
# Помимо строковых переменных, в текстовую информацию также часто включаются такие типы данных, как целые числа и числа
# с плавающей точкой. Теоретически мы могли бы преобразовать нестроковые данные в строки и соединить их для получения
# нужного текстового вывода, как показано в листинге test_0001.py.
# Методами обычно называются функции, определяемые в классах. В данном случае функция format определяется в классе str,
# поэтому этот метод вызывается для экземпляров str.


# 2.1.2. Использование f-строк для интерполяции переменных
print('2.1.2. Использование f-строк для интерполяции переменных')
# Форматирование строк часто подразумевает объединение строковых литералов и переменных разных типов (например, целых
# чисел и строк). При интеграции переменных в f-строку можно интерполировать эти переменные, чтобы они автоматически
# преобразовывались в строки нужного вида.
# Для начала рассмотрим, как использовать f-строки при создании вывода, представленного в листинге 2.1.
name = 'Homework'
urgency = 5
task_f = f'Name: {name}; Urgency Level: {urgency}'
assert task_f == 'Name: Homework; Urgency Level: 5'
# В этом примере переменная task_f создается с применением f-строк. Главное, на что следует обратить внимание, —
# фигурные скобки, в которые заключаются интерполируемые переменные. Так как f-строки интегрируют механизм строковой
# интерполяции, они также называются интерполируемыми строковыми литералами.
# Термин «строковая интерполяция» (string interpolation) не относится к специфике Python, этот механизм присутствует
# в большинстве основных современных языков (таких, как JavaScript, Swift и C#). В общем случае он предоставляет более
# компактный и удобочитаемый синтаксис для создания отформатированных строк, чем конкатенация строк и альтернативные
# способы их форматирования.
# Инструкция assert
# Ключевое слово Python assert используется для проверок (ассертов), которые вычисляют заданное условие. Если результат
# равен True, программа продолжает выполняться. Если же результат равен False, выполнение прерывается, а программа
# выдает ошибку AssertionError.
tasks = ['homework', 'laundry']
assert f'Tasks: {tasks}' == "Tasks: ['homework', 'laundry']"  # Интерполирует объект списка
task_hwk = ('Homework', 'Complete physics work')
assert f'Task: {task_hwk}' == "Task: ('Homework', 'Complete physics work')"  # Интерполирует объект кортежа
task = {'name': 'Laundry', 'urgency': 3}
assert f'Task: {task}' == "Task: {'name': 'Laundry', 'urgency': 3}"  # Интерполирует объект словаря


# 2.1.3. Использование f-строк для интерполяции выражений
print('2.1.3. Использование f-строк для интерполяции выражений')
# На более общем уровне f-строки также могут интерполировать выражения, что избавляет вас от необходимости создания
# промежуточных переменных. Например, при создании строкового вывода можно обратиться к элементу объекта dict или
# использовать результат вызова функции. В таких распространенных ситуациях можно включить эти выражения в f-строки, как
# показывает следующий фрагмент кода:
tasks = ["homework", "laundry", "grocery shopping"]
assert f"First Task: {tasks[0]}" == 'First Task: homework'  # Обращается к элементу списка
task_name = "grocery shopping"
assert f"Task Name: {task_name.title()}" == 'Task Name: Grocery Shopping'  # Вызывает функцию
number = 5
assert f"Square: {number * number}" == 'Square: 25'  # Прямые вычисления
# Эти выражения заключаются в фигурные скобки, чтобы f-строки напрямую вычислили их для получения нужного строкового
# вывода: {tasks[0]} -> "homework";
# {task_name.title()} -> "Grocery Shopping";
# {number * number} -> 25.
# В тексте часто встречается термин «выражение» (expression), относящийся к числу ключевых понятий программирования.
# Начинающие программисты могут путать его со связанным понятием — инструкцией (statement). Выражение обычно
# представляет собой одну строку кода (хотя может занимать несколько строк при заключении в тройные кавычки),
# результатом вычисления которой является значение объекта, например строки или экземпляра нестандартного класса. Из
# этого определения легко выводится, что переменные являются разновидностями выражений.
# С другой стороны, инструкции не создают никакого значения или объекта. Цель инструкции заключается в выполнении
# некоторого действия. Например, ключевое слово assert создает проверочную инструкцию (или команду), которая проверяет
# выполнение некоторого условия, прежде чем процесс продолжится. Мы не пытаемся получить логическое значение True или
# False, а проверяем условие.
# Различия между выражениями и инструкциями. Выражения представляют некие вычисления, в результате которых получается
# значение или объект, тогда как инструкция выполняет конкретные действия и не может вычисляться для получения значения.
# Хотя f-строки поддерживают интерполяцию выражений, эту возможность следует использовать с осторожностью, потому что
# любые сложные выражения в f-строках ухудшают читаемость вашего кода. Следующий пример демонстрирует злоупотребление
# f-строками, использующими сложные выражения:
summary_text = f'Your Average Score: {sum([95, 98, 97, 96, 97, 93]) / len([95, 98, 97, 96, 97, 93])}.'
print(summary_text)
# Существует хороший практический критерий оценки удобочитаемости вашего кода — определите, сколько времени потребуется
# читателю, чтобы разобраться в нем. Чтобы понять, что происходит в приведенном выше фрагменте, читателю понадобятся
# десятки секунд. Сравните со следующей переработанной версией:
scores = [95, 98, 97, 96, 97, 93]
total_score = sum(scores)
subject_count = len(scores)
average_score = total_score / subject_count
summary_text = f'Your Average Score: {average_score}.'
print(summary_text)
# В этой версии заслуживает внимания ряд обстоятельств. Во-первых, оценки сохраняются в объекте list, что позволяет
# избавиться от дублирования данных. Во-вторых, вычисления разбиты на несколько шагов, при этом каждый шаг представляет
# собой более простое вычисление. В-третьих, ключевым фактором для улучшения удобочитаемости становится использование на
# каждом шаге содержательного имени, обозначающего результат вычислений. Такой код хорошо читается без единого
# комментария, все понятно само по себе.
# Создайте необходимые промежуточные переменные с содержательными именами, чтобы наглядно обозначить каждый шаг ваших
# операций. Для простых операций вам даже не придется писать комментарии, потому что содержательные имена описывают
# смысл каждой операции.


# 2.1.4. Применение спецификаторов для форматирования f-строк
print('2.1.4. Применение спецификаторов для форматирования f-строк')
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#


