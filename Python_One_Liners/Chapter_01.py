#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Глава 1
print('Глава 1')
# Краткая памятка по Python
print('Краткая памятка по Python')


# Числовые типы данных и структуры
print('Числовые типы данных и структуры')
# Два важнейших числовых типа данных - integer (целое число) и float (число с плавающей точкой). Integer - положительное
# или отрицательное число без плавающей точки (например, 3). Float - положительное или отрицательное число, для которого
# задана определенная точность вычислений с плавающей точкой (например, 3.14159265359). Python предоставляет широкий
# выбор встроенных числовых операций, а также функциональность для преобразования между этими числовыми типами данных.
# Большинство этих операторов очевидны. Обратите внимание, что оператор // служит для целочисленного деления и
# возвращает округленное вниз целочисленное значение (например, 3 // 2 == 1).
# Арифметические операции:
x, y = 3, 2
print(x + y)     # 5
print(x - y)     # 1
print(x * y)     # 6
print(x / y)     # 1.5
print(x // y)    # 1
print(x % y)     # 1
print(-x)        # -3
print(abs(-x))   # 3
print(int(3.9))  # 3
print(float(x))  # 3.0
print(x ** y)    # 9


# Булевы значения
print('Булевы значения')
# Переменная типа Boolean может принимать только одно из двух значений - False и True.
# В языке Python типы данных Boolean и integer тесно связаны: «под капотом» типа данных Boolean используются значения
# типа integer (по умолчанию булево значение False представлено целочисленным значением 0, а булево значение
# True - целочисленным значением 1).
# Булевы значения False и True:
x = 1 > 2
print(x)  # False
y = 2 > 1
print(y)  # True
# После вычисления значений указанных выражений переменная x будет ссылаться на булево значение False, а переменная
# y - на булево значение True.


# Ключевые слова: and, or, not
print('Ключевые слова: and, or, not')
# Булевы выражения соответствуют основным логическим операторам. Сочетание их всего с тремя следующими ключевыми словами
# позволяет создавать обширный спектр потенциально весьма сложных выражений:
# - and - выражение x and y равно True, если x равно True и y равно True. Если же хотя бы одно из них равно False, то и
# все выражение в целом будет равно False;
# - or - выражение x or y равно True, если x равно True или y равно True. Если же хотя бы одно из них равно True, то и все
# выражение в целом будет равно True;
# - not - выражение not x равно True, если x равно False. В противном случае это выражение равно False.
# Ключевые слова and, or и not:
x, y = True, False
print((x or y) == True)    # True
print((x and y) == False)  # True
print((not y) == True)     # True


# Приоритет булевых операторов
print('Приоритет булевых операторов')
# Для понимания булевой логики очень важен порядок применения булевых операторов. Например, рассмотрим выражение на
# естественном языке "идет дождь и холодно или ветрено". Его можно интерпретировать двояко:
# - "(идет дождь и холодно) или ветрено" - в этом случае выражение будет истинным, если ветрено, - даже если дождь не
# идет;
# - "идет дождь и (холодно или ветрено)" - в этом же случае выражение будет ложным, если дождь не идет, - неважно,
# холодно или дует ветер.
# Порядок булевых операторов важен. Правильной будет первая интерпретация выражения, поскольку оператор логического
# И (and) обладает приоритетом перед оператором логического ИЛИ (or).
# Тип данных Boolean:
# 1. Булевы операции
x, y = True, False
print(x and not y)       # True
print(not x and y or x)  # True
# 2. Если вычисление значения условия дает False
if None or 0 or 0.0 or '' or [] or {} or set():
    print('Dead code')  # Не достигается
# Этот код демонстрирует два важных нюанса. Во-первых, булевы операторы подчиняются правилам приоритета: наивысший
# приоритет у оператора not, далее следует оператор and, а затем оператор or. Во-вторых, следующие значения
# автоматически вычисляются как равные False: ключевое слово None, целочисленное значение 0, значение с плавающей
# точкой 0.0, пустые строки и пустые объекты контейнерных типов.


# Строковые значения
print('Строковые значения')
# Строки Python представляют собой последовательности символов. Они неизменяемы, а после создания не могут быть
# модифицированы. Хотя существуют и другие способы создания строковых значений, чаще всего применяются следующие пять:
# - одинарные кавычки: 'Yes';
# - двойные кавычки: "Yes";
# - тройные кавычки для многострочных строковых значений: '''Yes''' или """Yes""";
# - методы для работы со строками: str(5) == '5' равно True;
# - конкатенация: 'Py' + 'thon' равно 'Python'.
# Нередко в строковых значениях приходится использовать пробельные символы. В число чаще всего применяемых пробельных
# символов входит символ новой строки \n, символ пробела \s и символ табуляции \t.
# Строковые типы данных:
# Важнейшие методы для работы со строками
y = "   This is lazy\t\n    "
print(y.strip())  # Удаляем пробелы: 'This is lazy'
print("DrDre".lower())  # В нижнем регистре: 'drdre'
print("attention".upper())  # В верхнем регистре: 'ATTENTION'
print("smartphone".startswith("smart"))  # Сопоставляет префикс строки с аргументом: True
print("smartphone".endswith("phone"))  # Сопоставляет суффикс строки с аргументом: True
print("another".find("other"))  # Индекс найденного вхождения: 2
print("cheat".replace("ch", "m"))  # Заменяет все вхождения первого аргумента на второй: meat
print(','.join(["F", "B", "I"]))  # Склеивает все элементы списка, используя строку-разделитель: F,B,I
print(len("Rumpelstiltskin"))  # Длина строки: 15
print("ear" in "earth")  # Содержится: True
# Boolean, integer, float и string - важнейшие основные типы данных в языке Python. Но нередко приходится не просто
# создавать элементы данных, а и структурировать их. В подобных случаях вам пригодятся контейнерные типы данных.
# Но прежде чем рассмотреть их подробно, коротко обсудим важный специальный тип данных: None.


# Ключевое слово None
print('Ключевое слово None')
# Ключевое слово None представляет собой константу языка Python и означает отсутствие значения. В других языках
# программирования, например Java, вместо него используется значение null. Однако null часто вызывает путаницу, особенно
# у начинающих программистов, считающих, что оно равно целочисленному значению 0. Поэтому в языке Python используется
# ключевое слово None, чтобы четко обозначить его отличие от числового значения 0, пустого
# списка и пустой строки. Любопытно, что значение None - единственное значение в типе данных NoneType.
# В этом коде приведено несколько примеров типа данных None (а также показано, чем он не является). Если не описать для
# функции возвращаемое значение, то по умолчанию будет возвращаться None.
# Ключевое слово None
def f():
    x = 2
# С ключевым словом 'is' я познакомлю вас ниже
print(f() is None)  # True
print('' == None)   # False
print(0 == None)    # False


# Контейнерные структуры данных
print('Контейнерные структуры данных')
# Python включает контейнерные типы данных, позволяющие легко и эффективно осуществлять сложные операции.

# Списки
print('Списки')
# Список (list) - это контейнерный тип данных, предназначенный для хранения последовательности элементов. В отличие от
# строк, списки изменяемые (mutable), их можно модифицировать во время выполнения. Что такое тип данных список, удобнее
# всего показать на примерах:
l = [1, 2, 2]
print(len(l))  # 3
# Этот фрагмент кода демонстрирует создание списка и заполнение его тремя целочисленными элементами с помощью квадратных
# скобок. Как видите, в списке могут быть повторяющиеся элементы. Функция len() возвращает количество элементов в
# списке.

# Ключевое слово: is
print('Ключевое слово: is')
# Ключевое слово is просто проверяет, ссылаются ли две переменные на один объект в памяти. Новичков, у которых нет опыта
# работы с Python, оно может привести в замешательство. Проверяем, ссылаются ли два целых числа и два списка на одни и
# те же объекты в памяти.
# Ключевое слово is
y = x = 3
print(x is y)      # True
print([3] is [3])  # False
# Если создать два списка (даже состоящих из одних и тех же элементов), то они будут ссылаться на два различных
# объекта-списка в памяти. Модификация одного из этих объектов никак не повлияет на второй. Списки - изменяемые,
# поскольку их можно модифицировать после создания. Следовательно, если проверить, ссылаются ли два списка на один
# объект в памяти, результат будет равен False. А целочисленные значения - неизменяемые, так что нет риска случайно
# изменить через объект одной переменной значения всех остальных переменных. Объект 3 типа integer нельзя изменить,
# поскольку такая попытка просто приведет к созданию нового объекта integer, а старый останется неизменным.

# Добавление элементов
print('Добавление элементов')
# Язык Python предлагает три основных способа добавления элементов в уже существующий список: добавление в конец списка,
# вставка и конкатенация списков.
# 1. Добавление в конец списка
l = [1, 2, 2]
l.append(4)
print(l)  # [1, 2, 2, 4]
# 2. Вставка
l = [1, 2, 4]
l.insert(2, 3)
print(l)  # [1, 2, 3, 4]
# 3. Конкатенация списков
print([1, 2, 2] + [4])  # [1, 2, 2, 4]
# В результате всех трех операций получается один и тот же список [1, 2, 2, 4]. Но операция append выполняется быстрее
# всего, поскольку не требует ни обхода списка для вставки элементов в нужное место (как в случае insert), ни создания
# нового списка на основе двух подсписков (как в случае конкатенации списков). Если не вдаваться в подробности, то
# операцию insert имеет смысл использовать только для добавления элемента в конкретное место списка, причем не в конце,
# а конкатенацию - для конкатенации двух списков произвольной длины. Обратите внимание, что существует и четвертый
# метод, extend(). Он служит для добавления в конец списка нескольких элементов сразу наиболее эффективным способом.

# Удаление элементов
print('Удаление элементов')
# Элемент x можно легко удалить из списка с помощью метода remove(x) списка:
l = [1, 2, 2, 4]
l.remove(1)
print(l)  # [2, 2, 4]
# Этот метод работает с самим объектом списка, а не создает новый, измененный список. В предыдущем примере кода мы
# создали объект списка l и удалили из него элемент. Такой подход не требует избыточных копий данных списка, позволяя
# экономить память.

# Инвертирование списков
print('Инвертирование списков')
# Порядок элементов списка можно инвертировать с помощью метода list.reverse():
l = [1, 2, 2, 4]
l.reverse()
print(l)  # [4, 2, 2, 1]
# Инвертирование списка приводит к модификации исходного объекта списка, а не просто создает новый объект списка.

# Сортировка списков
print('Сортировка списков')
# Отсортировать элементы списка можно с помощью метода list.sort():
l = [2, 1, 4, 2]
l.sort()
print(l)  # [1, 2, 2, 4]
# Опять же, сортировка списка приводит к модификации исходного объекта списка. Полученный в результате список
# отсортирован в порядке возрастания. Содержащие строковые объекты списки сортируются в порядке лексикографического
# возрастания (от 'a' до 'z'). В общем случае функция сортировки предполагает, что объекты сравнимы. В общих чертах,
# если для объектов a и b произвольного типа данных можно вычислить a > b, то Python может отсортировать список [a, b].

# Индексация элементов списков
print('Индексация элементов списков')
# Узнать индекс заданного элемента списка x можно с помощью метода list.index(x):
print([2, 2, 4].index(2))                   # 0
print([2, 2, 4].index(2,1))  # 1
# Метод index(x) ищет первое вхождение элемента x в списке и возвращает его индекс. Как и другие основные языки
# программирования, Python присваивает индекс 0 первому элементу, а индекс i – 1 - i-му элементу.

# Стеки
print('Стеки')
# Структура данных стек (stack) работает по интуитивно понятному принципу «последним поступил, первым обслуживается»
# (last in, first out, LIFO). Стек аналогичен стопке документов: новые помещаются сверху старых, и по мере работы с этой
# стопкой первым обрабатывается самый верхний документ.
# Стек - по-прежнему одна из базовых структур данных в computer science, используемая при управлении операционными
# системами в алгоритмах, при синтаксическом разборе и поиске с возвратом.
# Списки Python могут вполне интуитивным образом играть роль стеков: при использовании операции append() для добавления
# элемента в стек, а pop() - для удаления последнего добавленного элемента.
stack = [3]
stack.append(42) # [3, 42]
stack.pop()      # 42 (stack: [3])
stack.pop()      # 3 (stack: [])
# Благодаря эффективности реализации списков обычно можно обойтись без импорта внешних библиотек стеков.

# Множества
print('Множества')
# Структура данных множество (set) - простейший тип коллекций в Python и многих других языках программирования. Многие
# популярные языки, предназначенные для распределенных вычислений (например, MapReduce и Apache Spark), практически
# исключительно сосредоточиваются на операциях с множествами как простыми типами данных. Что же такое множество?
# Множество - неупорядоченная коллекция уникальных элементов. Разобьем это определение на составные части.

# Коллекция
print('Коллекция')
# Множество - коллекция элементов подобно спискам и кортежам. Коллекция состоит либо из элементов простых типов данных
# (целочисленных значений, значений с плавающей точкой, строковых значений), либо из более сложных элементов (объектов,
# кортежей). Однако все типы данных в множестве должны быть хешируемыми, то есть обладать соответствующим хеш-значением.
# Хеш-значение объекта никогда не меняется и используется для его сравнения с другими объектами. Рассмотрим пример, где
# множество создается на основе трех строковых значений, после проверки их хеш-значений. Далее пробуем создать множество
# списков, но это нам не удается, поскольку списки нехешируемые.
# Множество требует хешируемых элементов
hero = 'Harry'
guide = 'Dumbledore'
enemy = 'Lord V.'
print(hash(hero))   # 6175908009919104006
print(hash(guide))  # -5197671124693729851
# Можно ли создать множество строковых значений?
characters = {hero, guide, enemy}
print(characters)  # {'Lord V.', 'Dumbledore', 'Harry'}
# Можно ли создать множество списков?
# team_1 = [hero, guide]
# team_2 = [enemy]
# teams = {team_1, team_2}  # TypeError: unhashable type: 'list'
# Traceback (most recent call last):
#   File "/media/Samsung/Programming/Python/Scripts/Python_One_Liners/Chapter_01.py", line 266, in <module>
#     teams = {team_1, team_2}  # TypeError: unhashable type: 'list'
#             ^^^^^^^^^^^^^^^^
# TypeError: unhashable type: 'list'
# Множество строковых значений можно создать, поскольку строковые значения - хешируемые. А создать множество списков
# нельзя, поскольку списки нехешируемые. Дело в том, что хеш-значение зависит от содержимого элемента коллекции, а
# списки - изменяемые; если модифицировать данные в списке, то хеширование тоже должно измениться. А поскольку
# изменяемые типы данных нехешируемы, использовать их в множествах нельзя.

# Неупорядоченность
print('Неупорядоченность')
# В отличие от списков, у элементов множества нет четко заданного порядка. Вне зависимости от очередности помещения
# данных в множество, никогда нельзя быть уверенным, в каком порядке они будут храниться в множестве. Вот пример:
characters = {hero, guide, enemy}
print(characters)  # {'Lord V.', 'Dumbledore', 'Harry'}
# Я вставил в множество сначала героя, но мой интерпретатор вывел первым антагониста (интерпретатор Python - явно на
# стороне зла). Учтите, что ваш интерпретатор может вывести элементы множества в отличном порядке от моего.

# Уникальность
print('Уникальность')
# Все элементы множества должны быть уникальными. Строгое определение выглядит следующим образом: для всех пар значений
# x, y из множества при x!=y хеш-значения также отличаются: hash(x)!=hash(y). А поскольку все значения в множестве
# различны, создать армию Гарри Поттеров для войны с лордом В не получится:
clone_army = {hero, hero, hero, hero, hero, enemy}
print(clone_army)  # {'Lord V.', 'Harry'}
# Неважно, сколько раз вставляется одно значение в одно и то же множество, все равно в нем будет сохранен только один
# экземпляр этого значения. Дело в том, что у всех этих героев одно хеш-значение, а множество может содержать не более
# одного элемента с одинаковым хеш-значением. Существует расширение такой структуры данных, как множество,
# - мультимножество, в котором можно хранить несколько экземпляров одного значения. На практике, впрочем, оно
# используется редко. А обычные множества, напротив, встречаются практически в коде любого нетривиального проекта
# - например, для пересечения множества заказчиков и множества посетителей магазина, в результате чего будет возвращено
# новое множество заказчиков, которые также заходили в магазин.


# Ассоциативные массивы
print('Ассоциативные массивы')
# Ассоциативный массив - удобная структура данных для хранения пар (ключ, значение):
calories = {'apple' : 52, 'banana' : 89, 'choco' : 546}
# Читать и записывать элементы можно путем указания ключа в квадратных скобках:
print(calories['apple'] < calories['choco'])  # True
calories['cappu'] = 74
print(calories['banana'] < calories['cappu'])  # False
# Для доступа ко всем ключам и значениям ассоциативного массива служат функции keys() и values() соответственно:
print('apple' in calories.keys())  # True
print(52 in calories.values())     # True
# Для доступа к парам (ключ, значение) ассоциативного массива служит метод items():
for k, v in calories.items():
    print(k) if v > 500 else None  # 'choco'
# Таким образом, можно легко проходить в цикле по всем ключам и значениям массива, не обращаясь к ним по отдельности.


# Принадлежность
print('Принадлежность')
# Для проверки, содержит ли множество, список или ассоциативный массив определенный элемент, служит ключевое слово in.
# Ключевое слово in
print(42 in [2, 39, 42])  # True
print("21" in {"2", "39", "42"})  # False
print("list" in {"list" : [1, 2, 3], "set" : {1,2,3}})  # True
# С помощью ключевого слова in можно выяснить, содержится ли целочисленное значение 42 в списке целочисленных значений,
# или проверить принадлежность строкового значения "21" множеству строковых значений. Если x встречается в коллекции y,
# то мы будем говорить, что x - элемент коллекции y.
# Проверка принадлежности элемента множеству выполняется быстрее, чем проверка принадлежности элемента списку:
# чтобы проверить наличие элемента x в списке y, необходимо обходить весь список до тех пор, пока не будет найден
# элемент x или не будут проверены все элементы.
# Множества же реализованы аналогично ассоциативным массивам:
# для проверки наличия элемента x в множестве y Python «под капотом» выполняет одну операцию y[hash(x)] и проверяет, не
# равно ли None возвращаемое значение.


# Списковые включения и включения множеств
print('Списковые включения и включения множеств')
# Списковое включение - популярная возможность Python, с помощью которой можно быстро создавать и модифицировать списки.
# Оно описывается простой формулой [выражение + контекст]:
# - выражение указывает Python, что делать с каждым из элементов списка;
# - контекст указывает Python, какие элементы списка брать. Контекст состоит из произвольного количества операторов for
# и if.
# Например, в операторе спискового включения [x for x in range(3)] первая часть x - это выражение (идентификатор), а
# вторая часть for x in range(3) - контекст. Данный оператор создает список [0, 1, 2]. Функция range() при использовании
# с одним аргументом, как в нашем примере, возвращает диапазон последовательных целочисленных значений 0, 1 и 2.
# Ниже представлен еще один пример кода для спискового включения:
# (имя, $-доход)
customers = [("John", 240000), ("Alice", 120000), ("Ann", 1100000), ("Zach", 44000)]
# Ценные клиенты, зарабатывающие более $1 млн
whales = [x for x, y in customers if y > 1000000]
print(whales)  # ['Ann']
# Включения для множеств аналогичны списковым включениям, только создается множество, а не список.


# Управляющие конструкции
print('Управляющие конструкции')
# Управляющие конструкции позволяют принимать в коде различные решения.
# Алгоритмы часто сравнивают с кулинарными рецептами, состоящими из последовательного списка команд: положить в кастрюлю
# рис, залить холодной водой, посолить, отварить, подать рис на стол. Без условных операторов выполнение
# последовательности команд заняло бы лишь несколько секунд, и рис, конечно, не сварился бы, поскольку вы бы, например,
# налили воду, посолили, положили рис, а потом сразу же подали его, не дожидаясь, пока вода закипит, а рис сварится.
# В различных ситуациях необходимо реагировать по-разному: рис необходимо класть в кастрюлю, только если вода уже
# нагрелась, а подавать его, только если он уже мягкий. Практически невозможно писать программы так, чтобы предусмотреть
# все детерминированные события реального мира. Вместо этого необходимо писать программы, по-разному реагирующие на
# различные условия.


# Ключевые слова if, else и elif
print('Ключевые слова if, else и elif')
# С помощью ключевых слов if, else и elif можно производить условное выполнение различных ветвей кода.
# Использование ключевых слов if, else и elif
# x = int(input("your value: "))
if x > 3:
    print("Big")
elif x == 3:
    print("Medium")
else:
    print("Small")
# Получаем сначала вводимые пользователем данные, преобразуем их в целое число и сохраняем их в переменной x.
# Затем проверяем, не превышает ли, не равно ли или меньше значение переменной. Другими словами, код различным образом
# реагирует на непредсказуемые реалистичные входные данные.


# Циклы
print('Циклы')
# Для повтора выполнения фрагментов кода в Python существует два типа циклов: цикл for и цикл while. С их помощью можно
# легко написать занимающую всего две строки кода программу, которая будет выполняться бесконечно. Реализовать подобный
# повтор выполнения иным способом будет непросто (в качестве альтернативы можно воспользоваться рекурсией).
# Ключевые слова for и while
# Объявление цикла for
for i in [0, 1, 2]:
    print(i)
# Цикл while - аналогичная семантика
j = 0
while j < 3:
    print(j)
    j = j + 1
# Оба варианта циклов выводят целые числа 0, 1 и 2 в командную оболочку, но делают это по-разному.
# Цикл for объявляет переменную цикла i, принимающую последовательно все значения из списка [0, 1, 2]. Его выполнение
# продолжается, пока значения не закончатся.
# При использовании цикла while тело цикла выполняется до тех пор, пока не будет выполнено заданное условие - в данном
# случае, пока j < 3.
# Существуют два основных способа выхода из цикла: можно задать условие цикла, которое рано или поздно станет равно
# False, либо воспользоваться ключевым словом break в конкретном месте тела цикла.
# Ключевое слово break
while True:
    break  # цикл не бесконечный
print("hello world")  # hello world
# Мы создали цикл while с условием, тождественно равным True. Так что, на первый взгляд, кажется, будто он будет
# выполняться бесконечно. Бесконечный цикл while - распространенная практика при, например, разработке веб-серверов,
# бесконечно повторяющих процедуру ожидания нового вебзапроса и его обработки.
# Однако в некоторых случаях бывает нужно досрочно прервать выполнение цикла. В примере с веб-сервером имеет смысл
# приостановить выдачу файлов из соображений безопасности, если сервер подвергается атаке.
# В подобных случаях можно воспользоваться ключевым словом break для выхода из цикла и выполнения следующего за ним
# кода. В приведенном выше коде после досрочного завершения цикла выполняется print("hello world").
# Можно также приказать интерпретатору Python пропустить определенные части цикла, не прибегая к досрочному выходу из
# него. Например, вместо полного останова веб-сервера пропустить вредоносные веб-запросы. Реализовать это можно с
# помощью оператора continue, завершающего выполнение текущей итерации цикла и возвращающего выполнение обратно к
# условию цикла.
# Использование ключевого слова continue
# while True:
#     continue
#     print("43")  # недостижимый код
# Данный код выполняется бесконечно, но оператор print не выполняется никогда. Дело в том, что оператор continue
# завершает текущую итерацию цикла и возвращает поток выполнения в его начало, поэтому print никогда не достигается.
# Подобный никогда не выполняемый код называется недостижимым (dead code). Поэтому оператор continue (как и оператор
# break) часто применяется при определенных условиях в среде условного выполнения if-else.


# Функции
print('Функции')
# Функции позволяют при необходимости повторно использовать фрагменты кода:
# писать их один раз, а задействовать многократно.
# При описании функции указывается ключевое слово def, название функции и набор аргументов для параметризации выполнения
# ее тела. Различные наборы аргументов могут резко менять возвращаемые функцией результаты. Допустим, вы описали функцию
# square(x), возвращающую квадрат входного аргумента x.
# Вызов square(10) возвращает 10 × 10 = 100, а вызов square(100) возвращает 100 × 100 = 10000.
# Ключевое слово return завершает выполнение функции и передает поток выполнения вызывающей стороне. Можно также указать
# необязательное значение после ключевого слова return, содержащее возвращаемый функцией результат.
# Ключевое слово return
def appreciate(x, percentage):
    return x + x * percentage / 100


print(appreciate(10000, 5))  # 10500.0
# Мы создали функцию appreciate() для вычисления роста вклада при заданной доходности. В приведенном коде мы вычисляем,
# насколько растет вклад 10 000 долларов за один год при ставке 5 %. В результате получается 10 500 долларов. С помощью
# ключевого слова return указываем, что результат функции должен равняться сумме исходного вклада и номинальной
# процентной ставки. Тип возвращаемого значения функции appreciate() - float.


# Лямбда-функции
print('Лямбда-функции')
# С помощью ключевого слова lambda в языке Python можно задавать лямбда-функции - анонимные функции, не описанные в
# пространстве имен. Если не вдаваться в подробности, то это функции без названия, предназначенные для однократного
# использования. Синтаксис их выглядит так:
# lambda <аргументы> : <возвращаемое выражение>
# У лямбда-функции может быть один или несколько аргументов, разделенных запятыми. После двоеточия (:) описывается
# возвращаемое выражение, в котором может использоваться (или не использоваться) описанный ранее аргумент.
# Роль возвращаемого выражения может играть любое выражение или даже другая функция.
# Лямбда-функции играют важнейшую роль в Python. В коде реальных проектов они встречаются повсеместно: например, для
# сокращения кода или создания аргументов различных функций Python (например, map() или reduce()).
# Использование ключевого слова lambda
print((lambda x: x + 3)(3))  # 6
# Сначала мы создаем лямбда-функцию, принимающую на входе значение x и возвращающую результат выражения x + 3. Результат
# представляет собой объект-функцию, которую можно вызывать точно так же, как любую другую. В соответствии с ее
# семантикой эту функцию можно назвать функцией-инкрементором. Результат ее вызова с аргументом x = 3 - суффикс (3)
# в операторе print - целочисленное значение 6. В книге мы будем постоянно использовать лямбда-функции, поэтому
# убедитесь, что хорошо понимаете, как они работают (хотя у вас еще будет возможность тщательнее разобраться в них).


# Итоги главы
print('Итоги главы')
# В этой главе вы освежили свои знания Python благодаря приведенному краткому экспресс-курсу. Вы посмотрели на важнейшие
# структуры данных Python и их использование в примерах кода. Научились управлять потоком выполнения программы с помощью
# операторов if-elif-else, а также циклов for и while. Вы повторили основные типы данных Python - Boolean, integer,
# float и string - и узнали, какие встраиваемые операции и функции часто применяются для работы с ними. В основе
# большинства фрагментов кода и нетривиальных алгоритмов на практике лежат обладающие большими возможностями
# контейнерные типы данных, такие как списки, стеки, множества и ассоциативные массивы. Из приведенных примеров вы
# научились добавлять, удалять, вставлять и переупорядочивать элементы. Вы также узнали об операторах принадлежности и
# списковом включении: эффективном и обладающем большими возможностями методе программного создания списков в Python.
# Наконец, вы узнали о функциях и научились их описывать (включая анонимные лямбда-функции). Теперь вы готовы
# рассмотреть первые десять простейших однострочников Python.
