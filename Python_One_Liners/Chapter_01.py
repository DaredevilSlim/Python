#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Глава 1
print('Глава 1')
# Краткая памятка по Python
print('Краткая памятка по Python')


# Числовые типы данных и структуры
print('Числовые типы данных и структуры')
# Два важнейших числовых типа данных — integer (целое число) и float (число с плавающей точкой). Integer — положительное
# или отрицательное число без плавающей точки (например, 3). Float — положительное или отрицательное число, для которого
# задана определенная точность вычислений с плавающей точкой (например, 3.14159265359). Python предоставляет широкий
# выбор встроенных числовых операций, а также функциональность для преобразования между этими числовыми типами данных.
# Большинство этих операторов очевидны. Обратите внимание, что оператор // служит для целочисленного деления и
# возвращает округленное вниз целочисленное значение (например, 3 // 2 == 1).
# Арифметические операции:
x, y = 3, 2
print(x + y)     # 5
print(x - y)     # 1
print(x * y)     # 6
print(x / y)     # 1.5
print(x // y)    # 1
print(x % y)     # 1
print(-x)        # -3
print(abs(-x))   # 3
print(int(3.9))  # 3
print(float(x))  # 3.0
print(x ** y)    # 9


# Булевы значения
print('Булевы значения')
# Переменная типа Boolean может принимать только одно из двух значений — False и True.
# В языке Python типы данных Boolean и integer тесно связаны: «под капотом» типа данных Boolean используются значения
# типа integer (по умолчанию булево значение False представлено целочисленным значением 0, а булево значение
# True — целочисленным значением 1).
# Булевы значения False и True:
x = 1 > 2
print(x)  # False
y = 2 > 1
print(y)  # True
# После вычисления значений указанных выражений переменная x будет ссылаться на булево значение False, а переменная
# y — на булево значение True.


# Ключевые слова: and, or, not
print('Ключевые слова: and, or, not')
# Булевы выражения соответствуют основным логическим операторам. Сочетание их всего с тремя следующими ключевыми словами
# позволяет создавать обширный спектр потенциально весьма сложных выражений:
# - and — выражение x and y равно True, если x равно True и y равно True. Если же хотя бы одно из них равно False, то и
# все выражение в целом будет равно False;
# - or — выражение x or y равно True, если x равно True или y равно True. Если же хотя бы одно из них равно True, то и все
# выражение в целом будет равно True;
# - not — выражение not x равно True, если x равно False. В противном случае это выражение равно False.
# Ключевые слова and, or и not:
x, y = True, False
print((x or y) == True)    # True
print((x and y) == False)  # True
print((not y) == True)     # True


# Приоритет булевых операторов
print('Приоритет булевых операторов')
# Для понимания булевой логики очень важен порядок применения булевых операторов. Например, рассмотрим выражение на
# естественном языке "идет дождь и холодно или ветрено". Его можно интерпретировать двояко:
# - "(идет дождь и холодно) или ветрено" — в этом случае выражение будет истинным, если ветрено, — даже если дождь не
# идет;
# - "идет дождь и (холодно или ветрено)" — в этом же случае выражение будет ложным, если дождь не идет, — неважно,
# холодно или дует ветер.
# Порядок булевых операторов важен. Правильной будет первая интерпретация выражения, поскольку оператор логического
# И (and) обладает приоритетом перед оператором логического ИЛИ (or).
# Тип данных Boolean:
# 1. Булевы операции
x, y = True, False
print(x and not y)       # True
print(not x and y or x)  # True
# 2. Если вычисление значения условия дает False
if None or 0 or 0.0 or '' or [] or {} or set():
    print('Dead code')  # Не достигается
# Этот код демонстрирует два важных нюанса. Во-первых, булевы операторы подчиняются правилам приоритета: наивысший
# приоритет у оператора not, далее следует оператор and, а затем оператор or. Во-вторых, следующие значения
# автоматически вычисляются как равные False: ключевое слово None, целочисленное значение 0, значение с плавающей
# точкой 0.0, пустые строки и пустые объекты контейнерных типов.


# Строковые значения
print('Строковые значения')
# Строки Python представляют собой последовательности символов. Они неизменяемы, а после создания не могут быть
# модифицированы. Хотя существуют и другие способы создания строковых значений, чаще всего применяются следующие пять:
# - одинарные кавычки: 'Yes';
# - двойные кавычки: "Yes";
# - тройные кавычки для многострочных строковых значений: '''Yes''' или """Yes""";
# - методы для работы со строками: str(5) == '5' равно True;
# - конкатенация: 'Py' + 'thon' равно 'Python'.
# Нередко в строковых значениях приходится использовать пробельные символы. В число чаще всего применяемых пробельных
# символов входит символ новой строки \n, символ пробела \s и символ табуляции \t.
# Строковые типы данных:
# Важнейшие методы для работы со строками
y = "   This is lazy\t\n    "
print(y.strip())  # Удаляем пробелы: 'This is lazy'
print("DrDre".lower())  # В нижнем регистре: 'drdre'
print("attention".upper())  # В верхнем регистре: 'ATTENTION'
print("smartphone".startswith("smart"))  # Сопоставляет префикс строки с аргументом: True
print("smartphone".endswith("phone"))  # Сопоставляет суффикс строки с аргументом: True
print("another".find("other"))  # Индекс найденного вхождения: 2
print("cheat".replace("ch", "m"))  # Заменяет все вхождения первого аргумента на второй: meat
print(','.join(["F", "B", "I"]))  # Склеивает все элементы списка, используя строку-разделитель: F,B,I
print(len("Rumpelstiltskin"))  # Длина строки: 15
print("ear" in "earth")  # Содержится: True
# Boolean, integer, float и string — важнейшие основные типы данных в языке Python. Но нередко приходится не просто
# создавать элементы данных, а и структурировать их. В подобных случаях вам пригодятся контейнерные типы данных.
# Но прежде чем рассмотреть их подробно, коротко обсудим важный специальный тип данных: None.


# Ключевое слово None
print('Ключевое слово None')
# Ключевое слово None представляет собой константу языка Python и означает отсутствие значения. В других языках
# программирования, например Java, вместо него используется значение null. Однако null часто вызывает путаницу, особенно
# у начинающих программистов, считающих, что оно равно целочисленному значению 0. Поэтому в языке Python используется
# ключевое слово None, чтобы четко обозначить его отличие от числового значения 0, пустого
# списка и пустой строки. Любопытно, что значение None — единственное значение в типе данных NoneType.
# В этом коде приведено несколько примеров типа данных None (а также показано, чем он не является). Если не описать для
# функции возвращаемое значение, то по умолчанию будет возвращаться None.
# Ключевое слово None
def f():
    x = 2
# С ключевым словом 'is' я познакомлю вас ниже
print(f() is None)  # True
print('' == None)   # False
print(0 == None)    # False


# Контейнерные структуры данных
print('Контейнерные структуры данных')
# Python включает контейнерные типы данных, позволяющие легко и эффективно осуществлять сложные операции.

# Списки
print('Списки')
# Список (list) — это контейнерный тип данных, предназначенный для хранения последовательности элементов. В отличие от
# строк, списки изменяемые (mutable), их можно модифицировать во время выполнения. Что такое тип данных список, удобнее
# всего показать на примерах:
l = [1, 2, 2]
print(len(l))  # 3
# Этот фрагмент кода демонстрирует создание списка и заполнение его тремя целочисленными элементами с помощью квадратных
# скобок. Как видите, в списке могут быть повторяющиеся элементы. Функция len() возвращает количество элементов в
# списке.

# Ключевое слово: is
print('Ключевое слово: is')
# Ключевое слово is просто проверяет, ссылаются ли две переменные на один объект в памяти. Новичков, у которых нет опыта
# работы с Python, оно может привести в замешательство. Проверяем, ссылаются ли два целых числа и два списка на одни и
# те же объекты в памяти.
# Ключевое слово is
y = x = 3
print(x is y)      # True
print([3] is [3])  # False
# Если создать два списка (даже состоящих из одних и тех же элементов), то они будут ссылаться на два различных
# объекта-списка в памяти. Модификация одного из этих объектов никак не повлияет на второй. Списки — изменяемые,
# поскольку их можно модифицировать после создания. Следовательно, если проверить, ссылаются ли два списка на один
# объект в памяти, результат будет равен False. А целочисленные значения — неизменяемые, так что нет риска случайно
# изменить через объект одной переменной значения всех остальных переменных. Объект 3 типа integer нельзя изменить,
# поскольку такая попытка просто приведет к созданию нового объекта integer, а старый останется неизменным.

# Добавление элементов
print('Добавление элементов')
# Язык Python предлагает три основных способа добавления элементов в уже существующий список: добавление в конец списка,
# вставка и конкатенация списков.
# 1. Добавление в конец списка
l = [1, 2, 2]
l.append(4)
print(l)  # [1, 2, 2, 4]
# 2. Вставка
l = [1, 2, 4]
l.insert(2, 3)
print(l)  # [1, 2, 3, 4]
# 3. Конкатенация списков
print([1, 2, 2] + [4])  # [1, 2, 2, 4]
# В результате всех трех операций получается один и тот же список [1, 2, 2, 4]. Но операция append выполняется быстрее
# всего, поскольку не требует ни обхода списка для вставки элементов в нужное место (как в случае insert), ни создания
# нового списка на основе двух подсписков (как в случае конкатенации списков). Если не вдаваться в подробности, то
# операцию insert имеет смысл использовать только для добавления элемента в конкретное место списка, причем не в конце,
# а конкатенацию — для конкатенации двух списков произвольной длины. Обратите внимание, что существует и четвертый
# метод, extend(). Он служит для добавления в конец списка нескольких элементов сразу наиболее эффективным способом.

# Удаление элементов
print('Удаление элементов')
# Элемент x можно легко удалить из списка с помощью метода remove(x) списка:
l = [1, 2, 2, 4]
l.remove(1)
print(l)  # [2, 2, 4]
# Этот метод работает с самим объектом списка, а не создает новый, измененный список. В предыдущем примере кода мы
# создали объект списка l и удалили из него элемент. Такой подход не требует избыточных копий данных списка, позволяя
# экономить память.

# Инвертирование списков
print('Инвертирование списков')
# Порядок элементов списка можно инвертировать с помощью метода list.reverse():
l = [1, 2, 2, 4]
l.reverse()
print(l)  # [4, 2, 2, 1]
# Инвертирование списка приводит к модификации исходного объекта списка, а не просто создает новый объект списка.

# Сортировка списков
print('Сортировка списков')
# Отсортировать элементы списка можно с помощью метода list.sort():
l = [2, 1, 4, 2]
l.sort()
print(l)  # [1, 2, 2, 4]
# Опять же, сортировка списка приводит к модификации исходного объекта списка. Полученный в результате список
# отсортирован в порядке возрастания. Содержащие строковые объекты списки сортируются в порядке лексикографического
# возрастания (от 'a' до 'z'). В общем случае функция сортировки предполагает, что объекты сравнимы. В общих чертах,
# если для объектов a и b произвольного типа данных можно вычислить a > b, то Python может отсортировать список [a, b].

# Индексация элементов списков
print('Индексация элементов списков')
# Узнать индекс заданного элемента списка x можно с помощью метода list.index(x):
print([2, 2, 4].index(2))                   # 0
print([2, 2, 4].index(2,1))  # 1
# Метод index(x) ищет первое вхождение элемента x в списке и возвращает его индекс. Как и другие основные языки
# программирования, Python присваивает индекс 0 первому элементу, а индекс i – 1 — i-му элементу.

# Стеки
print('Стеки')
# Структура данных стек (stack) работает по интуитивно понятному принципу «последним поступил, первым обслуживается»
# (last in, first out, LIFO). Стек аналогичен стопке документов: новые помещаются сверху старых, и по мере работы с этой
# стопкой первым обрабатывается самый верхний документ.
# Стек — по-прежнему одна из базовых структур данных в computer science, используемая при управлении операционными
# системами в алгоритмах, при синтаксическом разборе и поиске с возвратом.
# Списки Python могут вполне интуитивным образом играть роль стеков: при использовании операции append() для добавления
# элемента в стек, а pop() — для удаления последнего добавленного элемента.
stack = [3]
stack.append(42) # [3, 42]
stack.pop()      # 42 (stack: [3])
stack.pop()      # 3 (stack: [])
# Благодаря эффективности реализации списков обычно можно обойтись без импорта внешних библиотек стеков.

# Множества
print('Множества')
# Структура данных множество (set) — простейший тип коллекций в Python и многих других языках программирования. Многие
# популярные языки, предназначенные для распределенных вычислений (например, MapReduce и Apache Spark), практически
# исключительно сосредоточиваются на операциях с множествами как простыми типами данных. Что же такое множество?
# Множество — неупорядоченная коллекция уникальных элементов. Разобьем это определение на составные части.

# Коллекция
print('Коллекция')
# Множество — коллекция элементов подобно спискам и кортежам. Коллекция состоит либо из элементов простых типов данных
# (целочисленных значений, значений с плавающей точкой, строковых значений), либо из более сложных элементов (объектов,
# кортежей). Однако все типы данных в множестве должны быть хешируемыми, то есть обладать соответствующим хеш-значением.
# Хеш-значение объекта никогда не меняется и используется для его сравнения с другими объектами. Рассмотрим пример, где
# множество создается на основе трех строковых значений, после проверки их хеш-значений. Далее пробуем создать множество
# списков, но это нам не удается, поскольку списки нехешируемые.
# Множество требует хешируемых элементов
hero = 'Harry'
guide = 'Dumbledore'
enemy = 'Lord V.'
print(hash(hero))   # 6175908009919104006
print(hash(guide))  # -5197671124693729851
# Можно ли создать множество строковых значений?
characters = {hero, guide, enemy}
print(characters)  # {'Lord V.', 'Dumbledore', 'Harry'}
# Можно ли создать множество списков?
team_1 = [hero, guide]
team_2 = [enemy]
teams = {team_1, team_2}
# TypeError: unhashable type: 'list'
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
