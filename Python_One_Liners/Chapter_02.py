#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Глава 2
print('Глава 2')
# Трюки Python
print('Трюки Python')

# Поиск самых высокооплачиваемых работников с помощью спискового включения
print('Поиск самых высокооплачиваемых работников с помощью спискового включения')
# В данном разделе вы познакомитесь с прекрасной, очень эффективной и полезной возможностью Python для создания списков:
# списковым включением (list comprehension). Оно пригодится нам во множестве однострочников далее в книге.

# Общее описание
print('Общее описание')
# Представьте, что вы работаете в отделе кадров большой компании и вам нужно найти всех сотрудников, зарабатывающих по
# крайней мере 100 000 долларов в год. Выходные результаты должны представлять собой список кортежей, каждый из которых
# состоит из двух значений: имени сотрудника и его годовой зарплаты. Ниже представлен соответствующий код:
employees = {'Alice': 100000, 'Bob': 99817, 'Carol': 122908, 'Frank': 88123, 'Eve': 93121}
top_earners = []
for key, val in employees.items():
    if val >= 100000:
        top_earners.append((key,val))
print(top_earners)  # [('Alice', 100000), ('Carol', 122908)]
# И хотя код работает правильно, существует более простой и намного более лаконичный, а значит, и удобочитаемый способ
# получить тот же результат. При прочих равных условиях решение, занимающее меньше строк, будет понятнее для читающего
# код. В Python существует замечательный способ создания новых списков: списковое включение.
# Оно описывается простой формулой:
# [выражение + контекст]
# Внешние квадратные скобки указывают, что результат представляет собой новый список. Контекст указывает, какие элементы
# списка необходимо взять. Выражение описывает способ модификации элементов списка перед добавлением результата в
# список. Пример выглядит так:
# [x * 2 for x in range(3)]
# Выделенная жирным шрифтом часть, for x in range(3), представляет собой контекст, а остальная часть, x * 2,
# - выражение. Выражение удваивает значения 0, 1, 2, сгенерированные контекстом. Таким образом, результат спискового
# включения представляет собой следующий список:
# [0, 2, 4]
# Как выражение, так и контекст могут быть произвольной степени сложности. Выражение может представлять собой функцию от
# любой описанной в контексте переменной и выполнять любые вычисления - и даже вызывать внешние функции. Задача
# выражения - модифицировать каждый из элементов списка перед добавлением его в новый список. Контекст может состоять из
# одной или нескольких переменных, описанных с помощью одного или нескольких вложенных циклов for. Можно также
# ограничить контекст, задействовав операторы if. В данном случае новое значение добавляется в список только при
# соблюдении заданного пользователем условия.
# Списковое включение лучше всего пояснить на примере. Внимательно изучите следующие примеры, и вы поймете, что оно
# собой представляет:
print([x for x in range(5)])  # [0, 1, 2, 3, 4]
# Выражение: тождественная функция (не меняет контекст переменной x).
# Контекст: переменная контекста x принимает все значения, возвращаемые функцией range: 0, 1, 2, 3, 4.
print([(x, y) for x in range(3) for y in range(3)])
# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
# Выражение: создает новый кортеж из переменных контекста x и y.
# Контекст: переменная контекста x проходит в цикле по всем значениям, возвращаемым функцией range (0, 1, 2);
# то же делает и переменная контекста y. Эти два цикла for - вложенные, вследствие чего переменная контекста y повторяет
# итерации своего цикла для каждого из значений переменной контекста x. Таким образом, получается 3 × 3 = 9 сочетаний
# переменных контекста.
print([x ** 2 for x in range(10) if x % 2 > 0])  # [1, 9, 25, 49, 81]
# Выражение: функция возведения в квадрат переменной контекста x.
# Контекст: переменная контекста x проходит в цикле по всем значениям, возвращаемым функцией range - 0, 1, 2, 3, 4, 5,
# 6, 7, 8, 9, - но только нечетным, то есть когда x % 2 > 0.
print([x.lower() for x in ['I', 'AM', 'NOT', 'SHOUTING']])  # ['i', 'am', 'not', 'shouting']
# Выражение: строковая функция приведения к нижнему регистру переменной контекста x.
# Контекст: переменная контекста x проходит в цикле по всем строковым значениям в списке: 'I', 'AM', 'NOT', 'SHOUTING'.
# Теперь вы сможете понять, что происходит во фрагменте кода, который будет показан ниже.

# Код
print('Код')
# Рассмотрим уже обсуждавшуюся ранее задачу с зарплатами сотрудников:
# по ассоциативному массиву со строковыми ключами и целочисленными значениями создать новый список из кортежей (ключ,
# значение), таких, что соответствующее ключу значение больше или равно 100 000.
# Однострочное решение для спискового включения
# Данные
employees = {'Alice': 100000, 'Bob': 99817, 'Carol': 122908, 'Frank': 88123, 'Eve': 93121}
# Однострочник
top_earners = [(k, v) for k, v in employees.items() if v >= 100000]
# Результат
print(top_earners)
# Каковы же будут результаты выполнения этого фрагмента кода?

# Принцип работы
print('Принцип работы')
# Рассмотрим этот однострочник подробнее.
top_earners = [(k, v) for k, v in employees.items() if v >= 100000]
# Выражение: создает простой кортеж (ключ, значение) для переменных контекста k и v.
# Контекст: метод ассоциативного массива dict.items() обеспечивает проход переменной контекста k в цикле по всем ключам
# ассоциативного массива, а переменной контекста v - в цикле по соответствующим переменной контекста k значениям, но
# только если значение переменной контекста v равно или больше 100 000, в соответствии с условием if.
# Результат выполнения этого однострочника выглядит следующим образом:
print(top_earners)  # [('Alice', 100000), ('Carol', 122908)]
# В этой простой однострочной программе мы познакомились с важным понятием спискового включения. Такие включения
# используются во многих местах данной книги, поэтому хорошо разберитесь с примерами в текущем разделе, прежде чем
# читать дальше.

# Поиск информативных слов с помощью спискового включения
print('Поиск информативных слов с помощью спискового включения')
# В этом однострочнике мы еще более углубимся в изучение обладающей большими возможностями функциональности списковых
# включений.

# Общее описание
print('Общее описание')
# Поисковые системы ранжируют текстовую информацию по степени соответствия запросу пользователя. Для этого поисковые
# системы анализируют содержимое текста, в котором необходимо произвести поиск. Любой текст состоит из слов. В одних
# содержится немало информации о содержимом текста, а в других - нет. Примеры первых слов - white, whale, Captain, Ahab
# (узнали, откуда это?). Примеры слов второго типа - is, to, as, the, a и how, поскольку они содержатся в большинстве
# текстов. При реализации поисковых систем часто отфильтровывают слова, не несущие особого значения.
# Простейший эвристический подход - отфильтровывать все слова из трех или менее букв.

# Код
print('Код')
# Наша цель - решить следующую задачу: создать на основе многострочного строкового значения список списков, каждый из
# которых состоит из всех слов одной из строк, причем слова эти длиной три символа и более.
# Однострочное решение для поиска информативных слов
# Данные
text = '''Call me Ishmael. Some years ago - never mind how long precisely - having
little or no money in my purse, and nothing particular to interest me
on shore, I thought I would sail about a little and see the watery part
of the world. It is a way I have of driving off the spleen, and regulating
the circulation. - Moby Dick'''
# Однострочник
w = [[x for x in line.split() if len(x) > 3] for line in text.split('\n')]
# Результат
print(w)
# Какими же будут результаты выполнения этого фрагмента кода?

# Принцип работы
print('Принцип работы')
# Данный однострочник создает список списков с помощью двух вложенных выражений для спискового включения:
# - во внутреннем выражении для спискового включения [x for x in line.split() if len(x) > 3] используется строковая
# функция split() для разбиения заданной строки на последовательность слов. Мы проходим по всем словам x и добавляем в
# список те из них, длина которых не менее трех символов;
# - во внешнем выражении для спискового включения создается строковое значение line, используемое в предыдущем
# операторе. Опять же, для разбиения текста по символам новой строки '\n' применяется функция split().
# Конечно, необходимо научиться думать на языке списковых включений, поэтому в первое время они могут показаться
# сложными. Но когда вы закончите читать данную книгу, списковые включения станут для вас обыденными и вы будете быстро
# писать код на языке Python в подобном стиле.


# Чтение файла
print('Чтение файла')
# В этом разделе мы прочитаем данные из файла и сохраним результат в виде списка строковых значений (по одному на
# строку). Мы также удалим из прочитанных строк все ведущие и хвостовые пробельные символы.

# Общее описание
print('Общее описание')
# В Python чтение файла не представляет трудности, но требует обычно нескольких строк кода. Ниже представлен один из
# стандартных способов чтения данных из файла в языке Python:
filename = './Files/readFileDefault.py' # этот код
f = open(filename)
lines = []
for line in f:
    lines.append(line.strip())
    print(lines)
# Предполагается, что этот фрагмент кода сохранен в файле readFileDefault.py в текущем каталоге. Код открывает данный
# файл, создает пустой список, lines, и заполняет его строковыми значениями с помощью операции append() в теле цикла
# for, в котором проходит по всем строкам файла. Мы также воспользовались строковым методом strip() для удаления всех
# ведущих и хвостовых пробельных символов (в противном случае в строках бы оказались и символы новой строки '\n').
# Для доступа к файлам на компьютере необходимо знать, как их открывать и закрывать. Получить доступ к файлу данных
# можно только после его открытия. Если файл был закрыт, значит, все данные уже в него записаны. Python может создавать
# буфер и ожидать некоторое время, пока не запишет весь буфер в файл. Причина этого проста:
# доступ к файлам осуществляется довольно медленно. Из соображений эффективности Python не записывает биты по
# отдельности, а ждет, пока буфер наполнится достаточным количеством байтов, после чего сбрасывает весь буфер в файл
# целиком. Именно поэтому рекомендуется с помощью команды f.close() закрывать файл после записи в него данных, чтобы
# гарантировать, что все данные записаны должным образом, а не остались во временной памяти. Однако существует несколько
# исключений, когда Python закрывает файл автоматически, в частности, когда счетчик ссылок уменьшается до нуля, как вы
# увидите в следующем коде.

# Код
print('Код')
# Наша задача: открыть файл, прочитать все строки, удалить ведущие и хвостовые пробельные символы и сохранить результаты
# в списке.
# Однострочное решение для построчного чтения файла
print([line.strip() for line in open('./Files/readFile.py')])

# Принцип работы
print('Принцип работы')
# Для вывода полученного списка в командную оболочку мы применили оператор print(). Этот список был создан с помощью
# спискового включения. В части выражение спискового включения используется метод strip() строковых объектов. Контекст
# спискового включения проходит в цикле по всем строкам файла. В результате выполнения этого однострочника будет выведен
# просто он сам (поскольку он предназначен для чтения своего файла исходного кода на Python - readFile.py), обернутый в
# строковый объект и вставленный в список:
# print([line.strip() for line in open("readFile.py")])
# Этот подраздел демонстрирует, что повышение лаконичности кода делает его более удобочитаемым, не нанося какого-либо
# ущерба эффективности.


# Лямбда-функции и функция map
print('Лямбда-функции и функция map')
# В этом разделе я познакомлю вас с двумя важными возможностями Python:
# лямбда-функциями и функцией map() - ценными инструментами в наборе Python-разработчика. Мы воспользуемся ими для
# поиска конкретного значения в списке строковых значений.

# Общее описание
print('Общее описание')
# Из главы 1 вы узнали, как описать новую функцию с помощью выражения def x, за которым следует тело функции. Однако это
# не единственный способ описания функции в языке Python. Можно также воспользоваться лямбда-функциями для описания
# простой функции с возвращаемым значением (которое может быть любым объектом, в том числе кортежем, списком или
# множеством). Другими словами, лямбда-функция обязательно возвращает вызывающей стороне значение-объект. Учтите, что на
# практике это ограничивает сферу применения лямбда-функций, ведь в отличие от обычных функций они не предназначены для
# выполнения кода без возвращения объекта в вызывающую среду.
# ПРИМЕЧАНИЕ: Мы уже рассматривали лямбда-функции в главе 1, но поскольку это очень важное понятие, используемое
# повсеместно в данной книге, мы рассмотрим его подробнее в этом разделе.
# Благодаря лямбда-функциям можно описать новую функцию с помощью одной строки кода, указав ключевое слово lambda. Это
# удобно, если нужно быстро создать функцию для однократного использования и последующего немедленного сбора мусора.
# Посмотрим сначала на точный синтаксис лямбда-функций:
# lambda аргументы : возвращаемое выражение
# Описание такой функции начинается с ключевого слова lambda, за ним следует последовательность ее аргументов, которые
# необходимо будет указать при ее вызове. Далее указывается двоеточие (:) и возвращаемое выражение, в котором
# вычисляется возвращаемое значение на основе аргументов лямбда-функции. Возвращаемое выражение, в котором вычисляются
# выводимые функцией результаты, может быть любым выражением Python. В качестве примера рассмотрим следующее описание
# функции:
# lambda x, y: x + y
# У данной лямбда-функции два аргумента, x и y. Возвращаемое значение представляет собой просто их сумму, то есть x + y.
# Лямбда-функции обычно задействуют, когда функцию нужно вызвать только один раз и ее можно легко описать с помощью
# одной строки кода. Распространенный пример: использование лямбда-функций с функцией map, принимающей в качестве
# входных аргументов функциональный объект f и последовательность s. Далее функция map применяет функцию f к каждому из
# элементов последовательности s. Конечно, можно описать для функционального аргумента f полноценную поименованную
# функцию. Но зачастую это снижает удобочитаемость, особенно если функция короткая и понадобится только один раз, так
# что лучше воспользоваться лямбда функцией. Прежде чем показать вам однострочник, продемонстрирую еще один трюк Python,
# который сильно облегчит вам жизнь: проверку того, включает ли строковое значение x подстроку y, с помощью выражения
# y in x. Этот оператор возвращает True при наличии хотя бы одного вхождения строки символов y в строке x. Например,
# значение выражения '42' in 'The answer is 42' равно True, а выражения '21' in 'The answer is 42' равно False.
# Теперь посмотрим на наш однострочник.

# Код
print('Код')
# Получая на входе список строковых значений, наш следующий однострочник создает новый список кортежей, каждый из
# которых состоит из булева значения и исходной строки. Булево значение указывает, встречается ли в исходном строковом
# значении строка символов 'anonymous'! Мы назвали полученный в результате список mark, поскольку булевы значения
# отмечают (mark) строковые элементы в списке, содержащие строку символов 'anonymous'.
# Однострочное решение, помечающее строковые значения, содержащие строку символов 'anonymous'
# Данные
txt = ['lambda functions are anonymous functions.',
       'anonymous functions dont have a name.',
       'functions are objects in Python.']
# Однострочник
mark = map(lambda s: (True, s) if 'anonymous' in s else (False, s), txt)
# Результаты
print(list(mark))
# Какими же будут результаты выполнения этого фрагмента кода?

# Принцип работы
print('Принцип работы')
# Функция map() добавляет к каждому строковому элементу исходного списка txt булево значение, равное True, если этот
# строковый элемент содержит слово anonymous. Первый аргумент представляет собой анонимную лямбда-функцию, а второй -
# список строковых значений, которые мы хотим проверить на вхождение желаемой подстроки.
# Для поиска подстроки 'anonymous' используется возвращаемое выражение лямбда-функции
# (True, s) if 'anonymous' in s else (False, s). Значение s представляет собой входной аргумент лямбда-функции, в этом
# примере — строковое значение. Если в данной строке встречается последовательность символов 'anonymous', то выражение
# возвращает кортеж (True, s). В противном случае возвращается кортеж (False, s).
# Булевы значения демонстрируют, что только первые два строковых значения в списке содержат подстроку 'anonymous'.
# Лямбда-функции очень пригодятся нам в следующих однострочниках. Кроме того, вы приблизитесь к достижению своей цели:
# пониманию всех строк кода Python, которые только встретятся вам на практике.

# УПРАЖНЕНИЕ 2.1
print('УПРАЖНЕНИЕ 2.1')
# Попробуйте получить те же результаты с помощью спискового включения вместо функции map().
txt = ['lambda functions are anonymous functions.',
       'anonymous functions dont have a name.',
       'functions are objects in Python.']
result = [(True, s) if 'anonymous' in s else (False, s) for s in txt]
print(result)


# Извлечение окружения вхождений подстрок с помощью срезов
print('Извлечение окружения вхождений подстрок с помощью срезов')
# В этом разделе вы узнаете о важности понятия среза (slicing) — процесса «вырезания» подпоследовательности из исходной
# полной последовательности — для обработки простых текстовых запросов. Мы поищем в какомнибудь тексте конкретную строку
# символов, а затем выделим ее из текста вместе с некоторым количеством окружающих ее символов в качестве контекста.

# Общее описание
print('Общее описание')
# Срезы играют очень важную роль во множестве понятий и навыков, связанных с Python, как простых, так и продвинутых,
# например, при использовании любых встроенных структур данных Python — списков, кортежей и строк. Срезы также лежат в
# основе большого количества продвинутых библиотек Python, например NumPy, Pandas, TensorFlow и scikit-learn.
# Доскональное изучение срезов окажет эффект домино (в положительном смысле) на вашей карьере как Python-разработчика.
# Срезы позволяют извлекать из последовательностей подпоследовательности, например части символьных строк. Синтаксис
# очевиден. Пусть дана переменная x, ссылающаяся на строковое значение, список или кортеж. Извлечь из нее
# подпоследовательность можно с помощью следующей нотации:
# x[начало:конец:шаг]
# Полученная в результате подпоследовательность начинается на индексе начало (включительно) и заканчивается на индексе
# конец (не включая его). При желании можно включить необязательный третий аргумент шаг, определяющий, какие элементы
# извлекаются, позволяя выбрать только расположенные через шаг элементы последовательности. Например, применение к
# переменной x = 'hello world' операции среза x[1:4:1] дает в результате строку 'ell'. А операция среза x[1:4:2] для той
# же переменной дает строку 'el', поскольку в итоговый срез выбирается только каждый второй элемент. Как вы помните из
# главы 1, первому элементу последовательности любого типа, например, строки или списка, в языке Python соответствует
# индекс 0. Если не включить аргумент шаг, то Python по умолчанию считает его равным 1. Например, срез x[1:4] дает в
# результате строку 'ell'. Если опустить аргументы начало или конец, то Python предполагает, что вы хотите начать с
# начала или закончить в конце последовательности. Например, срез x[:4] дает строку 'hell', а срез x[4:] — строку
# 'o world'. Внимательно посмотрите на следующие примеры, чтобы лучше разобраться в этой функциональности.
s = 'Eat more fruits!'
print(s[0:3])     # Eat
print(s[3:0])     # (empty string '')
print(s[:5])      # Eat m
print(s[5:])      # ore fruits!
print(s[:100])    # Eat more fruits!
print(s[4:8:2])   # mr
print(s[::3])     # E rfi!
print(s[::-1])    # !stiurf erom taE
print(s[6:1:-1])  # rom t
# Эти варианты простейшего шаблона срезов Python x[начало:конец:шаг] демонстрируют множество интересных свойств данной
# методики:
# - если начало>=конец с положительным значением шаг, то срез будет пустым;
# - если аргумент конец больше длины последовательности, то Python вырезает все элементы последовательности вплоть до
# крайнего справа элемента включительно;
# - если шаг больше нуля, то по умолчанию начало среза — крайний слева элемент, а конец — крайний справа (включительно);
# - если шаг меньше нуля, то срез обходит последовательность в обратном порядке. При незаданных аргументах начало и
# конец срез начинается с крайнего справа элемента (включительно) и заканчивается крайним слева элементом
# (включительно). Обратите внимание, что если аргумент конец задан, то соответствующая позиция не включается в срез.
# Далее мы воспользуемся срезами и методом string.find(значение) для поиска индекса строкового аргумента значение в
# заданной строке.

# Код
print('Код')
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#

