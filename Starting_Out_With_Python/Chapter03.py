#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 3 Структуры принятия решения и булева логика
print('3 Структуры принятия решения и булева логика')
# 3.1 Инструкция if
print('3.1 Инструкция if')
# Инструкция if применяется для создания управляющей структуры, которая позволяет иметь в программе более одного пути
# исполнения. Инструкция if исполняет одну или несколько инструкций, только когда булево выражение является истинным.
# Управляющая структура - это логическая схема, управляющая порядком, в котором исполняется набор инструкций.
# Последовательная структура представляет собой набор инструкций, которые исполняются в том порядке, в котором они
# появляются.
# В Python для написания структуры принятия решения с единственным вариантом используется инструкция if. Вот общий
# формат инструкции if:
# if условие:
#   инструкция
#   инструкция
#   ...
# Для простоты мы будем называть первую строку условным выражением, или выражением if. Условное выражение начинается со
# слова if, за которым следует условие, т.е. выражение, которое будет вычислено, как истина либо ложь. После условия
# стоит двоеточие. Со следующей строки начинается блок инструкций. Блок - это просто набор инструкций, которые
# составляют одну группу. Обратите внимание, что в приведенном выше общем формате все инструкции блока выделены
# отступом. Такое оформление кода обязательно, потому что интерпретатор Python использует отступы для определения начала
# и конца блока. Во время исполнения инструкции if осуществляется проверка условия. Если условие истинное, то
# исполняются инструкции, которые появляются в блоке после условного выражения. Если условие ложное, то инструкции в
# этом блоке пропускаются.

# Булевы выражения и операторы сравнения.
# Как упоминалось ранее, инструкция if осуществляет проверку выражения, чтобы определить, является ли оно истинным или
# ложным. Выражения, которые проверяются инструкцией if, называются булевыми выражениями в честь английского математика
# Джорджа Буля.
# Как правило, булево выражение, которое проверяется инструкцией if, формируется оператором сравнения (реляционным
# оператором). Оператор сравнения определяет, существует ли между двумя значениями определенное отношение. Например,
# оператор больше (>) определяет, является ли одно значение больше другого. Оператор равно (==) - равны ли два значения
# друг другу.
# Операторы сравнения:
# Оператор  Значение
# >         Больше
# <         Меньше
# >=        Больше или равно
# <=        Меньше или равно
# ==        Равно
# !=        Не равно
# Булевы выражения с использованием операторов сравнения:
# Выражение Значение
# x > y     x больше y?
# x < y     x меньше y?
# x >= y    x больше или равно y?
# x <= y    x меньше или равно y?
# x == y    x равно y?
# x != y    x не равно y?

# Операторы >= и <=.
# Два следующих оператора, >= и <=, выполняют проверку более одного отношения. Оператор >= определяет, является ли
# операнд с левой стороны больше или равняется операнду с правой стороны. Оператор <= определяет, является ли операнд с
# левой стороны меньше или равняется операнду с правой стороны.

# Оператор ==.
# Оператор == определяет, равняется ли операнд с левой стороны операнду с правой стороны. Если значения, на которые
# ссылаются оба операнда, одинаковые, то выражение является истинным.

# Оператор !=.
# Оператор != является оператором неравенства. Он определяет, не равняется ли операнд с левой стороны операнду с правой
# стороны, т.е. противоположен оператору ==.


# 3.2 Инструкция if-else
print('3.2 Инструкция if-else')
# Инструкция if-else исполняет один блок инструкций, если ее условие является истинным, либо другой блок, если ее
# условие является ложным.
# Общий формат инструкции if-else:
# if условие:
#   инструкция
#   инструкция
#   ...
# else:
#   инструкция
#   инструкция
#   ...
# Когда эта инструкция исполняется, осуществляется проверка условия. Если оно истинное, то исполняется блок инструкций с
# отступом, расположенный после условного выражения, затем поток управления программы перескакивает к инструкции,
# которая следует за инструкцией if-else. Если условие ложное, то исполняется блок инструкций с отступом, расположенный
# после выражения else, затем поток управления программы перескакивает к инструкции, которая следует за инструкцией
# if-else.

# Выделение отступом в инструкции if-else.
# Когда вы пишете инструкцию if-else, при выделении отступами следует руководствоваться следующими принципами:
# - убедитесь, что выражение if и выражение else выровнены относительно друг друга;
# - выражение if и выражение else сопровождаются блоком инструкций. Убедитесь, что инструкции в блоках расположены с
# одинаковым отступом.


# 3.3 Сравнение строковых значений
print('3.3 Сравнение строковых значений')
# Python предоставляет возможность сравнивать строковые значения. Это позволяет создавать структуры принятия решения,
# которые выполняют их проверку.
name1 = 'Mary'
name2 = 'Mark'
if name1 == name2:
    print('Имена одинаковые.')
else:
    print('Имена НЕ одинаковые.')
# В программе в файле password.py представлен законченный код, демонстрирующий, как могут сравниваться два строковых
# значения. Здесь пользователю предлагается ввести пароль, затем программа пытается определить, равно ли введенное
# строковое значение слову 'prospero'.
# Операции сравнения строковых значений имеют одну особенность - они чувствительны к регистру. Например, строковые
# значения 'суббота' и 'Суббота' не равны, потому что в первом значении буква "с" написана в нижнем регистре, а во
# втором значении - в верхнем регистре.
# Помимо выяснения, являются ли строковые значения равными или не равными друг другу, можно также определить, является
# ли одно строковое значение больше или меньше другого строкового значения. Это полезно, потому что программистам очень
# часто приходится проектировать программы, которые сортируют строковые значения в каком-то определенном порядке.
# Наряду с введением набора числовых кодов, которые представляют символы в оперативной памяти, схема кодирования ASCII
# также предусматривает упорядоченность символов. Когда программа сравнивает символы, она фактически сравнивает коды
# символов.
if 'a' < 'b':
    print('Буква a меньше буквы b.')
# Программа в файле sort_names.py является простой демонстрацией того, как два строковых значения могут сравниваться
# оператором <.


# 3.4 Вложенные структуры принятия решения и инструкция if-elif-else
print('3.4 Вложенные структуры принятия решения и инструкция if-elif-else')
# Для проверки более одного условия структура принятия решения может быть вложена внутрь другой структуры принятия
# решения.

# Многочисленные вложенные структуры принятия решения.

# Инструкция if-elif-else.
# Python предоставляет специальный вариант структуры принятия решения, именуемый инструкцией if-elif-else, которая
# упрощает написание логической конструкции такого типа. Вот общий формат инструкции if-elif-else:
# if условие_1:
#   инструкция
#   инструкция
#   ...
# elif условие_2:
#   инструкция
#   инструкция
#   ...
# Вставить столько выражений elif, сколько нужно:
# else:
#   инструкция
#   инструкция
#   ...
# Инструкция if-elif-else не является обязательной, потому что ее логика может быть запрограммирована вложенными
# инструкциями if-else. Однако длинная серия вложенных инструкций if-else имеет два характерных недостатка при
# выполнении отладки программного кода.
# - Программный код может стать сложным и трудным для восприятия.
# - Из-за необходимого выделения отступом продолжительная серия вложенных инструкций if-else может стать слишком
# длинной, чтобы целиком уместиться на экране монитора без горизонтальной прокрутки. Длинные инструкции имеют тенденцию
# "переходить" на новую строку при распечатке на бумаге, что еще больше затрудняет чтение программного кода.
# Логика инструкции if-elif-else обычно прослеживается легче, чем длинная серия вложенных инструкций if-else.
# И поскольку в инструкции if-elif-else все выражения выровнены, длина строк в данной инструкции, как правило, короче.


# 3.5 Логические операторы
print('3.5 Логические операторы')
# Логический оператор and и логический оператор or позволяют соединять многочисленные булевы выражения для создания
# составного выражения. Логический оператор not изменяет значение булева выражения на противоположное.
# Python предоставляет ряд операторов, именуемых логическими операторами, которые можно использовать для создания
# составных булевых выражений.
# Логические операторы
# Оператор  Значение
# and       Оператор соединяет два булева выражения в одно составное выражение. Для того чтобы составное выражение было
#           истинным, оба подвыражения должны быть истинными
# or        Оператор соединяет два булева выражения в одно составное выражение. Для того чтобы составное выражение было
#           истинным, одно либо оба подвыражения должны быть истинными. Достаточно, чтобы только одно из выражений было
#           истинным, и не имеет значения какое из них
# not       Оператор является унарным оператором, т. е. он работает только с одним операндом. Операнд должен быть
#           булевым выражением. Оператор not инвертирует истинность своего операнда. Если он применен к выражению,
#           которое является истинным, то этот оператор возвращает ложь. Если он применен к выражению, которое является
#           ложным, то этот оператор возвращает истину

# Оператор and.
# Оператор and принимает два булевых выражения в качестве операндов и создает составное булево выражение, которое
# является истинным, только когда оба подвыражения являются истинными.
# Таблица истинности для оператора and
# Выражение             Значение выражения
# Истина and ложь       Ложь
# Ложь and истина       Ложь
# Ложь and ложь         Ложь
# Истина and истина     Истина
# Как показывает таблица, для того чтобы оператор вернул истинное значение, должны быть истинными оба выражения в
# операторе and.

# Оператор or.
# Оператор or принимает два булевых выражения в качестве операндов и создает составное булево выражение, которое
# является истинным, когда любое из подвыражений истинно.
# Для того чтобы выражение or было истинным, требуется, чтобы хотя бы один операнд оператора or был истинным. При этом
# не имеет значения, истинным или ложным будет второй операнд.
# Таблица истинности для оператора or
# Выражение             Значение выражения
# Истина or ложь        Истина
# Ложь or истина        Истина
# Ложь or ложь          Ложь
# Истина or истина      Истина

# Вычисление по укороченной схеме.
# Оба оператора, and и or, вычисляются по укороченной схеме. Вот как это работает с оператором and. Если выражение слева
# от оператора and ложное, то выражение справа от него не проверяется. Поскольку составное выражение является ложным,
# если является ложным всего одно подвыражение, то проверка оставшегося выражения будет пустой тратой процессорного
# времени. Поэтому, когда оператор and обнаруживает, что выражение слева от него является ложным, он следует по
# укороченной схеме и выражение справа от него не вычисляет.
# Вот как работает вычисление по укороченной схеме с оператором or. Если выражение слева от оператора or является
# истинным, то выражение справа от него не проверяется. Поскольку требуется, чтобы всего одно выражение было истинным,
# проверка оставшегося выражения будет пустой тратой процессорного времени.

# Оператор not.
# Оператор not - это унарный оператор, который в качестве своего операнда принимает булево выражение и инвертирует его
# логическое значение. Другими словами, если выражение является истинным, то оператор not возвращает ложь, и если
# выражение является ложным, то оператор not возвращает истину.
# Таблица истинности для оператора not
# Выражение     Значение выражения
# not истина    Ложь
# not ложь      Истина


# 3.6 Булевы переменные
print('3.6 Булевы переменные')
# Булева, или логическая, переменная может ссылаться на одно из двух значений: True (Истина) или False (Ложь). Булевы
# переменные обычно применяются в качестве флагов, которые указывают на наличие каких-то конкретных условий.
# Булевы переменные обычно применяются в качестве флагов. Флаг - это переменная, которая сигнализирует о возникновении в
# программе некоего условия. Когда флаговая переменная получает значение False, она указывает на то, что условия не
# существует. Когда флаговая переменная получает значение True, она означает, что условие возникло.

# 3.7 Черепашья графика: определение состояния черепахи
print('3.7 Черепашья графика: определение состояния черепахи')
# Библиотека черепашьей графики предоставляет многочисленные функции, которые можно использовать в структурах принятия
# решения для определения состояния черепахи и выполнения действия по условию.

# Определение позиции черепахи.
# Из главы 2 известно, что функции turtle.xcor() и turtle.ycor() применяются для получения текущих координат X и Y
# черепахи. Приведенный ниже фрагмент кода использует инструкцию if для определения, действительно ли координата X
# больше 249 или координата Y больше 349. Если это так, то черепаха перемещается в позицию (0, 0):
# if turtle.xcor() > 249 or turtle.ycor() > 349:
#   turtle.goto(0, 0)

# Определение углового направления черепахи.
# Функция turtle.heading() возвращает угловое направление черепахи. По умолчанию направление возвращается в градусах.
# Приведенный далее фрагмент кода использует инструкцию if для определения, направлена ли черепаха под углом между 90 и
# 270 градусами. Если это так, то направление черепахи устанавливается в 180°:
# if turtle.heading() >= 90 and turtle.heading() <= 270:
#   turtle.setheading(180)

# Определение положения пера над холстом.
# Функция turtle.isdown() возвращает True, если перо черепахи опущено, либо False в противном случае.
# Приведенный ниже фрагмент кода использует инструкцию if для определения, опущено ли перо черепахи. Если перо опущено,
# то этот фрагмент кода его поднимает:
# if turtle.isdown():
#   turtle.penup()
# Для того чтобы определить, поднято ли перо, применяется оператор not вместе с функцией turtle.isdown(). Приведенный
# ниже фрагмент кода это демонстрирует:
# if not(turtle.isdown()):
#   turtle.pendown()

# Определение видимости черепахи.
# Функция turtle.isvisible() возвращает True, если черепаха видима, либо False в противном случае.
# Приведенный ниже фрагмент кода использует инструкцию if для определения, видима ли черепаха. Если черепаха видима, то
# этот фрагмент кода ее прячет:
# if turtle.isvisible():
#   turtle.hideturtle()

# Определение текущего цвета.
# При выполнении функции turtle.pencolor() без передачи ей аргумента она возвращает текущий цвет пера в качестве
# строкового значения.
# Приведенный ниже фрагмент кода использует инструкцию if для определения, является ли текущий цвет пера красным. Если
# цвет красный, то этот фрагмент кода его меняет на синий:
# if turtle.pencolor() == 'red':
#   turtle.pencolor('blue')
# При выполнении функции turtle.fillcolor() без передачи ей аргумента она возвращает текущий цвет заливки в качестве
# строкового значения.
# Приведенный ниже фрагмент кода использует инструкцию if для определения, является ли текущий цвет заливки синим. Если
# цвет заливки синий, то этот фрагмент кода его меняет на белый:
# if turtle.fillcolor() == 'blue':
#   turtle.fillcolor('white')
# При выполнении функции turtle.bgcolor() без передачи ей аргумента она возвращает текущий фоновый цвет графического
# окна черепахи в качестве строкового значения.
# Приведенный ниже фрагмент кода использует инструкцию if для определения, является ли текущий цвет фона белым. Если
# цвет фона белый, то этот фрагмент кода меняет его на серый:
# f turtle.bgcolor() == 'white':
#   turtle.fillcolor('gray')

# Определение размера пера.
# При выполнении функции turtle.pensize() без передачи ей аргумента она возвращает текущий размер пера.
# Приведенный ниже фрагмент кода использует инструкцию if для определения, меньше ли 3 текущий размер пера. Если это
# так, фрагмент кода меняет его на 3:
# if turtle.pensize() < 3:
#   turtle.pensize(3)

# Определение скорости анимации черепахи.
# При выполнении функции turtle.speed() без передачи ей аргумента она возвращает скорость текущей анимации черепахи.
# Из главы 2 известно, что скорость анимации черепахи представляет собой значение в диапазоне от 0 до 10. Если скорость
# равна 0, то анимация отключена, и черепаха выполняет все свои перемещения мгновенно. Если скорость находится в
# диапазоне от 1 до 10, то 1 представляет самую низкую скорость, а 10 - самую высокую скорость.
# Приведенный ниже фрагмент кода определяет, больше 0 ли скорость черепахи. Если это так, ее скорость устанавливается
# в 0:
# if turtle.speed() > 0:
#   turtle.speed(0)
# Приведенный ниже фрагмент кода демонстрирует еще один пример. В нем применена инструкция if-elif-else для определения
# скорости черепахи и задания цвета пера. Если скорость равна 0, то цвет пера устанавливается в красный. В противном
# случае, если скорость больше 5, цвет пера устанавливается в синий. Иначе цвет пера устанавливается в зеленый:
# if turtle.speed() == 0:
#   turtle.pencolor('red')
# elif turtle.speed() > 5:
#   turtle.pencolor('blue')
# else:
#   turtle.pencolor('green')

# Игра "Порази цель".
# В этой рубрике мы обратимся к программе Python, в которой черепашья графика используется для простой игры. Когда
# программа запускается, она выводит графический экран. Небольшой квадрат, который нарисован в правой верхней области
# окна, является целью. Нужно запустить черепаху как снаряд, чтобы она попала по намеченной цели. Это делается путем
# ввода в окне оболочки угла и величины силы. Затем программа устанавливает угловое направление черепахи в заданный угол
# и применяет заданную величину силы в простой формуле расчета расстояния, на которое черепаха переместится. Чем больше
# величина силы, тем дальше черепаха переместится. Если черепаха останавливается в квадрате, значит, она попала в цель.
# В программе в файле hit_the_target.py представлен соответствующий код.
