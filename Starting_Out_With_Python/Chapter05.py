#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 5 Функции
print('5 Функции')
# 5.1 Введение в функции
print('5.1 Введение в функции')
# Функция - это группа инструкций, которая существует внутри программы с целью выполнения определенной задачи.
# Вместо того чтобы писать большую программу как одну длинную последовательность инструкций, программист создает
# несколько небольших функций, каждая из которых выполняет определенную часть задачи. Эти небольшие функции затем могут
# быть исполнены в нужном порядке для выполнения общей задачи.

# Преимущества модуляризации программы на основе функций.
# В результате разбиения программы на функции она получает следующие преимущества.
# - Более простой код. Когда код программы разбит на функции, он проще и легче для понимания. Несколько небольших
# функций намного легче читать, чем одну длинную последовательность инструкций.
# - Повторное использование кода. Функции также уменьшают дублирование программного кода в программе. Если определенная
# операция в программе выполняется в нескольких местах, то для выполнения этой операции можно один раз написать функцию
# и затем ее исполнять в любое время, когда она понадобится. Это преимущество функций называется повторным
# использованием кода.
# - Более простое тестирование. Когда каждая задача в программе содержится в собственной функции, процессы тестирования
# и отладки становятся проще. Программисты могут индивидуально протестировать каждую функцию в программе и определить,
# выполняет ли она свою задачу правильно. Это упрощает процесс изолирования и исправления ошибок.
# - Более быстрая разработка. Предположим, что программист или команда программистов разрабатывают многочисленные
# программы. Они обнаруживают, что каждая программа выполняет несколько общих задач, таких как выяснение имени
# пользователя и пароля, вывод текущего времени и т. д. Многократно писать программный код для всех этих задач не имеет
# никакого смысла. Вместо этого для часто встречающихся задач пишут функции, и эти функции могут быть включены в состав
# любой программы, которая в них нуждается.
# - Упрощение командной работы. Функции также упрощают программистам работу в командах. Когда программа разрабатывается
# как набор функций, каждая из которых выполняет отдельную задачу, в этом случае разным программистам может быть
# поручено написание различных функций.

# Функции без возврата значения и с возвратом значения.
# В этой главе вы научитесь писать два типа функций: функции без возврата значения, или пустые функции (void function),
# и функции с возвратом значения. Когда вызывается функция без возврата значения, она просто исполняет содержащиеся в
# ней инструкции и затем завершается. Когда вызывается функция с возвратом значения, она исполняет содержащиеся в ней
# инструкции и возвращает значение в ту инструкцию, которая ее вызвала. Функция input является примером функции с
# возвратом значения. При вызове функции input она получает данные, которые пользователь вводит на клавиатуре, и
# возвращает эти данные в качестве строкового значения. Функции int() и float() - тоже примеры функций с возвратом
# значения. Вы передаете аргумент функции int(), и она возвращает значение этого аргумента, преобразованное в целое
# число. Аналогичным образом вы передаете аргумент функции float(), и она возвращает значение этого аргумента,
# преобразованное в число с плавающей точкой.
# Функция без возврата значения - это первый тип функции, которую вы научитесь писать.


# 5.2 Определение и вызов функции без возврата значения
print('5.2 Определение и вызов функции без возврата значения')
# Программный код функции называется определением функции. Для исполнения функции пишется инструкция, которая ее
# вызывает.
# Имена функциям назначаются точно так же, как назначаются имена используемым в программе переменным. Имя функции должно
# быть достаточно описательным, чтобы любой читающий ваш код мог обоснованно догадаться, что именно функция делает.
# Python требует, чтобы вы соблюдали такие же правила, которые вы соблюдаете при именовании переменных:
# - в качестве имени функции нельзя использовать одно из ключевых слов;
# - имя функции не может содержать пробелы;
# - первый символ должен быть одной из букв от a до z, от A до Z либо символом подчеркивания (_);
# - после первого символа можно использовать буквы от a до z или от A до Z, цифры от 0 до 9 либо символы подчеркивания;
# - символы в верхнем и нижнем регистрах различаются.

# Определение и вызов функции.
# Для того чтобы создать функцию, пишут ее определение. Вот общий формат определения функции в Python:
# def имя_функции():
#   инструкция
#   инструкция
#   ...
# Первая строка называется заголовком функции. Он отмечает начало определения функции. Заголовок функции начинается с
# ключевого слова def, после которого идет имя_функции, затем круглые скобки и потом двоеточие. Начиная со следующей
# строки, идет набор инструкций, который называется блоком. Блок - это просто набор инструкций, которые составляют одно
# целое. Эти инструкции исполняются всякий раз, когда функция вызывается. Обратите внимание, что в приведенном выше
# общем формате все инструкции в блоке выделены отступом для того, чтобы интерпретатор Python использовал их для
# определения начала и конца блока.

# Вызов функции.
# Определение функции говорит о том, что именно функция делает, но оно не исполняет функцию. Для того чтобы функцию
# исполнить, ее необходимо вызвать.
# Когда функция вызвана, интерпретатор перескакивает к этой функции и исполняет инструкции в ее блоке. Затем, когда
# достигнут конец блока, интерпретатор перескакивает назад к той части программы, которая вызвала эту функцию, и
# программа возобновляет исполнение в этой точке. Когда это происходит, мы говорим, что функция вернулась. Для того
# чтобы полностью продемонстрировать, как работает вызов функции, обратимся к программе в файле function_demo.py.
# Нередко программа имеет главную функцию main, которая вызывается, когда программа запускается. Функция main по мере
# надобности вызывает другие функции. Часто говорится, что функция main содержит стержневую логику программы, т.е. общую
# логику программы. В программе в файле two_functions.py приведен пример кода с двумя функциями: main и message.
# Когда программа вызывает функцию, программисты обычно говорят, что поток управления программы передается в эту
# функцию. Это просто означает, что функция берет исполнение программы под свой контроль.

# Выделение отступом в Python.
# В Python каждая строка в блоке должна быть выделена отступом. Последняя выделенная отступом строка после заголовка
# функции является последней строкой в блоке функции. Когда строки выделяются отступом, следует убедиться, что каждая
# строка начинается с одинакового количества пробелов. В противном случае произойдет ошибка.
# В редакторе существует два способа выделить строку отступом: во-первых, нажатием клавиши <Tab> в начале строки либо,
# во-вторых, при помощи клавиши <Пробел> для вставки пробелов в начале строки. При выделении строк отступом в блоке
# можно использовать либо табуляцию, либо пробелы, но не оба способа одновременно. В противном случае это может запутать
# интерпретатор Python и вызвать ошибку.
# Среда IDLE, а также большинство других редакторов Python автоматически выделяют строки блока отступом. При наборе
# двоеточия в конце заголовка функции все строки, набираемые позже, будут автоматически выделяться отступом. Для того
# чтобы выйти из автоматического выделения отступом, следует после набора последней строки блока нажать клавишу
# <Backspace>.
# Для выделения строк блока отступом программисты Python обычно используют четыре пробела. Вы можете использовать любое
# количество пробелов по вашему выбору, коль скоро все строки в блоке расположены с соразмерным отступом.
# Пустые строки, которые появляются в блоке, игнорируются.


# 5.3 Проектирование программы с использованием функций
print('5.3 Проектирование программы с использованием функций')
# Для разбиения алгоритма на функции программисты обычно пользуются приемом, который называется нисходящей разработкой
# алгоритма.

# Составление блок-схемы программы с использованием функций

# Нисходящая разработка алгоритма.
# Мы рассмотрели и продемонстрировали работу функций. Вы увидели, как при вызове функции поток управления программы
# передается в функцию и затем при завершении функции возвращается в ту часть программы, которая вызвала функцию. В этих
# механических аспектах функций очень важно хорошо разобраться.
# Не меньшее значение, чем понимание того, как работают функции, имеет понимание того, как разрабатывать программу,
# которая использует функции. Программисты чаще всего применяют метод под названием нисходящей разработки, который
# позволяет разбивать алгоритм на функции. Процесс нисходящей разработки алгоритма выполняется следующим образом:
# 1. Полная задача, которую должна выполнить программа, разбивается на серию подзадач.
# 2. Каждая подзадача исследуется с целью установления, можно ли ее разложить дальше на другие подзадачи. Этот шаг
# повторяется до тех пор, пока больше ни одной подзадачи невозможно идентифицировать.
# 3. После того как все подзадачи были идентифицированы, их пишут в программном коде.
# Этот процесс называется нисходящей разработкой, потому что программист начинает с того, что обращается к самому
# верхнему уровню выполняемых задач и затем разбивает эти задачи на подзадачи более низкого уровня.

# Иерархические схемы.

# Определение и вызов функций.

# Приостановка исполнения до тех пор, пока пользователь не нажмет клавишу <Enter>.

# Использование ключевого слова pass.
# Приступая к написанию программы, вы знаете имена функций, которые планируете использовать, но еще не представляете
# всех деталей кода, который будет в этих функциях. В этом случае вы можете использовать ключевое слово pass для
# создания пустых функций. Позже, когда детали кода будут известны, вы можете вернуться к пустым функциям и заменить
# ключевое слово pass содержательным кодом.
# Например, когда мы писали код для программы в файле acme_dryer.py, мы могли бы вначале написать определения пустых
# функций для функций step1, step2, step3 и step4, как показано ниже:
# def step1():
#   pass
# def step2():
#   pass
# def step3():
#   pass
# def step4():
#   pass
# Интерпретатор Python игнорирует ключевое слово pass, и в результате этот код создаст четыре функции, которые ничего не
# делают.
# Ключевое слово pass можно использовать в качестве местозаполнителя в любом месте программного кода Python. Например,
# его можно использовать в инструкции if, как показано ниже:
# if x > y:
#   pass
# else:
#   pass
# Вот пример цикла while, в котором используется ключевое слово pass:
# while x < 100:
#   pass


# 5.4 Локальные переменные
print('5.4 Локальные переменные')
# Локальная переменная создается внутри функции. Инструкции, которые находятся за пределами функции, к ней доступа не
# имеют. Разные функции могут иметь локальные переменные с одинаковыми именами, потому что функции не видят локальные
# переменные друг друга.
# Всякий раз, когда переменной внутри функции присваивается значение, в результате создается локальная переменная. Она
# принадлежит функции, в которой создается, и к такой переменной могут получать доступ только инструкции в этой функции.
# (Термин "локальный" указывает на то обстоятельство, что переменная может использоваться лишь локально внутри функции,
# в которой она создается.)
# Если инструкция в одной функции попытается обратиться к локальной переменной, которая принадлежит другой функции, то
# произойдет ошибка код такой программы описан в файле bad_local.py.

# Область действия и локальные переменные.
# Область действия переменной - это часть программы, в которой можно обращаться к переменной. Переменная видима только
# инструкциям в области действия переменной. Областью действия переменной является функция, в которой переменная
# создается. К локальной переменной не может обращаться программный код, который появляется внутри функции в точке до
# того, как переменная была создана.
# Поскольку локальные переменные функции скрыты от других функций, другие функции могут иметь собственные локальные
# переменные с одинаковым именем. Например, взгляните на программу в файле birds.py. Помимо функции main эта программа
# имеет две другие функции: texas и california. В каждой из этих двух функций есть локальная переменная с именем birds.
# Несмотря на то что в этой программе есть две отдельные переменные с именами birds, только одна из них видима
# одномоментно, потому что они находятся в разных функциях.


# 5.5 Передача аргументов в функцию
print('5.5 Передача аргументов в функцию')
# Аргумент - это любая порция данных, которая передается в функцию, когда функция вызывается. Параметр - это переменная,
# которая получает аргумент, переданный в функцию.
# Если требуется, чтобы функция получала аргументы, когда она вызывается, то необходимо оборудовать эту функцию одной
# или несколькими параметрическими переменными. Параметрическая переменная, часто именуемая просто параметром, - это
# специальная переменная, которой присваивается значение аргумента, когда функция вызывается.

# Область действия параметрической переменной.
# Областью действия параметрической переменной является функция, в которой этот параметр используется. К параметрической
# переменной могут получать доступ все инструкции внутри функции, и ни одна инструкция за пределами этой функции к ней
# доступ получить не может.

# Передача аргумента в функцию.

# Передача нескольких аргументов.
# Часто имеет смысл писать функции, которые могут принимать много аргументов. Программа в файле multiple_args.py
# содержит функцию show_sum, которая принимает два аргумента, складывает их и показывает сумму.
# В программе в файле string_args.py приведен еще один пример. В качестве аргументов функции эта программа передает два
# строковых значения.

# Внесение изменений в параметры.
# Когда аргумент передается в функцию Python, параметрическая переменная функции будет ссылаться на значение этого
# аргумента. Однако любые изменения, которые вносятся в параметрическую переменную, не будут влиять на аргумент. Для
# того чтобы это продемонстрировать, взгляните на программу в файле change_me.py.
# Используемая в Python форма передачи аргументов, в которой функция не может изменять значение переданного ей
# аргумента, обычно называется передачей по значению. Эта форма показывает, как одна функция может связываться с другой
# функцией. Между тем канал связи работает только в одном направлении: вызывающая функция может связываться с вызванной
# функцией, но вызванная функция не может использовать аргумент для связи с вызывающей функцией.


# Именованные аргументы.
# Python позволяет писать аргумент в приведенном ниже формате, чтобы указывать, какой параметрической переменной
# аргумент должен быть передан:
# имя_параметра = значение
# В таком формате имя_параметра - это имя параметрической переменной, а значение - значение, передаваемое в этот
# параметр. Аргумент, написанный в соответствии с этой синтаксической конструкцией, называется именованным аргументом.
# Программа в файле keyword_args.py демонстрирует именованные аргументы. Здесь используется функция с именем
# show_interest, которая показывает сумму простого процентного дохода, накопленного банковским счетом в течение ряда
# периодов. Функция принимает аргументы principal (основная сумма на счете), rate (процентная ставка за период) и
# periods (количество периодов). Когда функция вызывается в строке 7, аргументы передаются как именованные аргументы.
# Поскольку именованный аргумент определяет, в какой параметр этот аргумент должен быть передан, его позиция в вызове
# функции не имеет значения.
# В программе в файле keyword_string_args.py приведен еще один пример. Это видоизмененная версия программы string_args в
# файле string_args.py. Эта версия использует именованные аргументы для вызова функции reverse_name (переставить имя и
# фамилию).

# Смешивание именованных и позиционных аргументов.
# В вызове функции имеется возможность смешивать позиционные и именованные аргументы, но при этом позиционные аргументы
# должны стоять первыми, после которых идут именованные аргументы. В противном случае произойдет ошибка.


# 5.6 Глобальные переменные и глобальные константы
print('5.6 Глобальные переменные и глобальные константы')
# Глобальная переменная доступна для всех функций в программном файле.
# Когда переменная создается инструкцией присваивания, написанной за пределами всех функций в программном файле, эта
# переменная является глобальной переменной. К глобальной переменной может обращаться любая инструкция в программном
# файле, включая инструкции в любой функции. Например, взгляните на программу в файле global1.py.
# Если нужно, чтобы инструкция внутри функции присваивала значение глобальной переменной, то требуется дополнительный
# шаг. В этом случае, как показано в программе в файле global2.py, глобальная переменная должна быть объявлена внутри
# функции.
# Большинство программистов соглашаются, что следует ограничить использование глобальных переменных либо не использовать
# их вообще. Причины следующие.
# - Глобальные переменные затрудняют отладку программы. Значение глобальной переменной может быть изменено любой
# инструкцией в программном файле. Если обнаружится, что в глобальной переменной хранится неверное значение, то придется
# отыскать все инструкции, которые к ней обращаются, чтобы определить, откуда поступает плохое значение. В программе с
# тысячами строк программного кода такая работа может быть сопряжена с большими трудностями.
# - Функции, которые используют глобальные переменные, обычно зависят от этих переменных. Если возникнет необходимость
# применить такую функцию в другой программе, то скорее всего придется эту функцию перепроектировать, чтобы она не
# опиралась на глобальную переменную.
# - Глобальные переменные затрудняют понимание программы. Глобальная переменная может быть модифицирована любой
# инструкцией в программе. Если возникнет необходимость разобраться в какой-то части программы, которая использует
# глобальную переменную, то придется узнать обо всех других частях программы, которые обращаются к этой глобальной
# переменной.
# В большинстве случаев следует создавать переменные локально и передавать их в качестве аргументов в функции, которым
# нужно к ним обратиться.

# Глобальные константы.
# Хотя вам следует стараться избегать использования глобальных переменных, в программе допускается применение глобальных
# констант. Глобальная константа - это глобальное имя, ссылающееся на значение, которое нельзя изменить. Поскольку
# значение глобальной константы не может быть изменено во время исполнения программы, вам не придется беспокоиться о
# многих потенциальных опасностях, которые обычно связаны с использованием глобальных переменных.
# Несмотря на то что язык Python не позволяет создавать настоящие глобальные константы, их можно имитировать при помощи
# глобальных переменных. Если глобальная переменная не объявляется с использованием ключевого слова global внутри
# функции, то присвоенное ей значение невозможно изменить внутри этой функции.

# Использование глобальных констант.


# 5.7 Введение в функции с возвратом значения: генерирование случайных чисел
print('5.7 Введение в функции с возвратом значения: генерирование случайных чисел')
# Функция с возвратом значения - это функция, которая возвращает значение обратно в ту часть программы, которая ее
# вызвала. Python, а также большинство других языков программирования предоставляют библиотеку заранее написанных
# функций, которые выполняют частые задачи. Эти библиотеки, как правило, содержат функцию, которая генерирует случайные
# числа.
# Функция без возврата значения - это группа инструкций, которая присутствует в программе с целью выполнения
# определенной задачи. Когда нужно, чтобы функция выполнила свою задачу, эта функция вызывается.
# В результате внутри функции исполняются инструкции. Когда функция завершается, поток управления программы возвращается
# к инструкции, которая располагается сразу после вызова функции.
# Функция с возвратом значения - это особый тип функций. Она похожа на функцию без возврата значения следующим образом:
# - это группа инструкций, которая выполняет определенную задачу;
# - когда нужно выполнить функцию, ее вызывают.
# Однако когда функция с возвратом значения завершается, она возвращает значение назад в ту часть программы, которая ее
# вызвала. Возвращаемое из функции значение используется как любое другое значение: оно может быть присвоено переменной,
# выведено на экран, использовано в математическом выражении (если оно является числом) и т. д.

# Функции стандартной библиотеки и инструкция import.
# Python, а также большинство языков программирования поставляются вместе со стандартной библиотекой функций, которые
# были уже написаны за вас. Эти функции, так называемые библиотечные функции, упрощают работу программиста, потому что с
# их помощью решаются многие задачи. На самом деле, вы уже применяли несколько библиотечных функций Python. Вот
# некоторые из них: print, input и range. В Python имеется множество других библиотечных функций.
# Некоторые библиотечные функции Python встроены в интерпретатор Python. Если требуется применить в программе одну из
# таких встроенных функций, нужно просто вызвать эту функцию. Это относится, например, к функциям print, input, range и
# другим, с которыми вы уже познакомились. Однако многие функции стандартной библиотеки хранятся в файлах, которые
# называются модулями. Эти модули копируются на ваш компьютер при установке языка Python и помогают систематизировать
# функции стандартной библиотеки. Например, все функции для выполнения математических операций хранятся вместе в одном
# модуле, функции для работы с файлами - в другом модуле и т. д.
# Для того чтобы вызвать функцию, которая хранится в модуле, нужно вверху программы написать инструкцию импорта import.
# Она сообщает интерпретатору имя модуля, который содержит функцию. Например, один из стандартных модулей Python
# называется math. В нем содержатся различные математические функции, которые работают с числами с плавающей точкой.
# Если требуется применить в программе какую-либо функцию из модуля math, необходимо в начале программы написать
# инструкцию импорта:
# import math
# Эта инструкция приводит к загрузке интерпретатором содержимого математического модуля math в оперативную память и в
# результате все функции модуля math становятся доступными в программе.
# Поскольку внутреннее устройство библиотечных функций невидимо, многие программисты их рассматривают как черные ящики.
# Термин "черный ящик" используется для описания любого механизма, который принимает нечто на входе, выполняет с
# полученным на входе некоторую работу (которую невозможно наблюдать) и производит результат на выходе.

# Генерирование случайных чисел.
# Случайные числа широко используются в большом количестве различных задач программирования. Далее перечислено всего
# несколько таких примеров.
# - Случайные числа обычно используются в играх. Например, компьютерным играм, которые позволяют игроку подбрасывать
# игральный кубик, нужны случайные числа для представления значений кубика. Программы, которые раскрывают игральные
# карты, вынимаемые из перетасованной колоды, используют случайные числа для представления достоинства карт.
# - Случайные числа широко применяются в программах имитационного моделирования. В некоторых симуляциях компьютер должен
# случайным образом решить, как будет вести себя человек, животное, насекомое или другое живое существо. Нередко
# конструируются формулы, в которых случайное число используется для определения различных действий и событий,
# происходящих в программе.
# - Случайные числа распространены в статистических программах, которые должны случайным образом отбирать данные для
# анализа.
# - Случайные числа обычно используются в компьютерной безопасности для шифрования уязвимых данных.
# Python предлагает несколько библиотечных функций для работы со случайными числами.
# Эти функции хранятся в модуле random в стандартной библиотеке. Для того чтобы применить любую из этих функций, сначала
# вверху программы нужно написать вот эту инструкцию импорта:
# import random
# Данная инструкция приводит к загрузке интерпретатором содержимого модуля random в оперативную память. В результате все
# функции модуля random становятся доступными в вашей программе.
# Первая функция генерации случайного числа, которую мы обсудим, называется randint. Поскольку функция randint находится
# в модуле random, для обращения к ней в нашей программе потребуется применить специальную форму записи через точку.
# В форме записи через точку именем функции будет random.randint. С левой стороны от точки (.) расположено имя модуля, с
# правой стороны - имя функции.
# Вот пример вызова функции randint:
# number = random.randint(1, 100)
# Обратите внимание, что вызов к функции randint появляется на правой стороне от оператора =. Когда функция будет
# вызвана, она сгенерирует случайное число в диапазоне от 1 до 100 и затем вернет его. Возвращенное число будет
# присвоено переменной number.
# В программе в файле random_numbers.py представлен законченный код, в котором применяется функция randint.
# Инструкция в строке 2 генерирует случайное число в диапазоне от 1 до 10 и присваивает его переменной number. (Вывод
# программы показывает, что было сгенерировано число 7, но это значение случайное. Если бы это была действующая
# программа, то она могла бы показать любое число от 1 до 10.)
# В программе в файле random_numbers2.py показан еще один пример. Здесь используется цикл for, выполняющий пять
# итераций. Внутри цикла инструкция в строке 8 вызывает функцию randint для генерации случайного числа из диапазона
# от 1 до 100.
# Программа в файле random_numbers3.py демонстрирует, каким образом можно упростить программу в файле
# random_numbers2.py. Здесь тоже выводятся пять случайных чисел, но они не сохраняются в переменной.
# В строке 7 возвращаемое из функции randint значение отправляется непосредственно в функцию print.

# Вызов функций из f-строки.
# Вызов функции можно использовать в качестве местозаполнителя в f-строке. Вот пример:
# print(f'Число равняется {random.randint(1, 100)}.')
# Эта инструкция выведет на экран сообщение:
# Число равняется 58.
# F-строки особенно полезны, когда необходимо отформатировать результат вызова функции.
# Например, приведенная ниже инструкция выводит случайное число, выровненное по центру в поле шириной 10 символов:
# print(f'{random.randint(0, 1000):^10d}')

# Эксперименты со случайными числами в интерактивном режиме.

# Использование случайных чисел.

# Использование случайных чисел для представления других значений.

# Функции randrange, random и uniform.
# Модуль random стандартной библиотеки содержит многочисленные функции для работы со случайными числами. Помимо функции
# randint, возможно, окажутся полезными функции randrange, random и uniform. (Для того чтобы применить любую из этих
# функций, необходимо в начале программы написать инструкцию import random.)
# Если вы помните, как применять функцию range (которую мы рассмотрели в главе 4), то почувствуете себя непринужденно с
# функцией randrange. Функция randrange принимает такие же аргументы, что и функция range. Различие состоит в том, что
# функция randrange не возвращает список значений. Вместо этого она возвращает случайно отобранное значение из
# последовательности значений. Например, приведенная ниже инструкция присваивает переменной number случайное число в
# диапазоне от 0 до 9:
# number = random.randrange(10)
# Аргумент 10 задает конечный предел последовательности значений. Функция возвратит случайно отобранное число из
# последовательности значений от 0 до конечного предела, но исключая сам предел. Приведенная ниже инструкция задает
# начальное значение и конечный предел последовательности:
# number = random.randrange(5,10)
# Во время исполнения этой инструкции случайное число в диапазоне от 5 до 9 будет присвоено переменной number.
# Приведенная ниже инструкция задает начальное значение, конечный предел и величину шага:
# number = random.randrange(0, 101, 10)
# В этой инструкции функция randrange возвращает случайно отобранное значение из приведенной ниже последовательности
# чисел:
# [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
# Функции randint и randrange возвращают целое число. А вот функция random возвращает случайное число с плавающей
# точкой. В функцию random никаких аргументов не передается. Во время ее вызова она возвращает случайное число с
# плавающей точкой в диапазоне от 0.0 до 1.0 (но исключая 1.0). Вот пример:
# number = random.random()
# Функция uniform тоже возвращает случайное число с плавающей точкой, но при этом она позволяет задавать диапазон
# значений, из которого следует отбирать значения. Вот пример:
# number = random.uniform(1.0, 10.0)
# В этой инструкции функция uniform возвращает случайное число с плавающей точкой в диапазоне от 1.0 до 10.0 и
# присваивает его переменной number.

# Начальные значения случайного числа.
# Числа, которые генерируются функциями модуля random, не являются подлинно случайными. Несмотря на то что мы обычно
# называем числа случайными, они являются псевдослучайными числами, которые вычисляются на основе формулы. Формула,
# которая генерирует случайные числа, должна быть инициализирована начальным значением. Оно используется в вычислении,
# которое возвращает следующее случайное число в ряду. Когда модуль random импортируется, он получает системное время из
# внутреннего генератора тактовых импульсов компьютера и использует его как начальное значение. Системное время является
# целым числом, которое представляет текущую дату и время вплоть до одной сотой секунды.
# Если бы всегда использовалось одно и то же начальное значение, то функции генерации случайных чисел всегда бы
# возвращали один и тот же ряд псевдослучайных чисел. Поскольку системное время меняется каждую сотую долю секунды,
# можно без опасений утверждать, что всякий раз, когда импортируется модуль random, будет сгенерирована отличающаяся
# последовательность случайных чисел. Вместе с тем могут иметься некоторые приложения, в которых потребуется всегда
# генерировать одну и ту же последовательность случайных чисел. При необходимости для этого можно вызвать функцию
# random.seed, задав начальное значение. Вот пример:
# random.seed(10)
# В этом примере в качестве начального значения задано 10. Если при каждом выполнении программы она вызывает функцию
# random.seed, передавая одинаковое значение в качестве аргумента, то она всегда будет порождать одинаковую
# последовательность псевдослучайных чисел.


# 5.8 Написание функций с возвратом значения
print('5.8 Написание функций с возвратом значения')
# Функция с возвратом значения имеет инструкцию return, которая возвращает значение в ту часть программы, которая ее
# вызвала.
# Функцию с возвратом значения пишут точно так же, как и функцию без возврата значения, но с одним исключением: функция
# с возвратом значения должна иметь инструкцию return.
# Вот общий формат определения функции с возвратом значения в Python:
# def имя_функции():
#   инструкция
#   инструкция
#   ...
#   return выражение
# Одной из инструкций в функции должна быть инструкция return, которая принимает приведенную ниже форму:
# return выражение
# Значение выражения, которое следует за ключевым словом return, будет отправлено в ту часть программы, которая вызвала
# функцию. Это может быть любое значение, переменная либо выражение, которые имеют значение (к примеру, математическое
# выражение).

# Использование инструкции return по максимуму.

# Как использовать функции с возвратом значения?
# Функции с возвратом значения предоставляют многие из тех же преимуществ, что имеются у функций без возврата значения:
# они упрощают программный код, уменьшают дублирование кода, улучшают ваши возможности по тестированию кода, увеличивают
# скорость разработки и способствуют совместной работе в команде.

# Использование таблиц "ввод-обработка-вывод".
# Таблица "ввод-обработка-вывод" является простым, но эффективным инструментом, который программисты иногда используют
# для разработки и документирования функций. Такая таблица описывает ввод, обработку и вывод функции.

# Модуляризация функций.

# Возвращение строковых значений.
# До сих пор вы видели примеры функций, которые возвращали только числовые значения.
# Помимо этого имеется возможность писать функции, которые возвращают строковые значения. Функция также может возвращать
# f-строку. В этом случае интерпретатор Python вычислит любые заполнители и спецификаторы формата, содержащиеся в
# f-строке, и вернет отформатированный результат.

# Возвращение булевых значений.
# Python позволяет писать булевы функции, которые возвращают либо истину (True), либо ложь (False). Булеву функцию можно
# применять для проверки условия и затем возвращения значения True либо False, которые будут сигнализировать о наличии
# либо отсутствии условия. Булевы функции широко применяются для упрощения сложных условий, которые проверяются в
# структурах принятия решения и структурах с повторением.

# Использование булевых функций в программном коде валидации входных данных.
# Булевы функции можно также использовать для упрощения сложного кода валидации входных данных.

# Возвращение нескольких значений.
# Примеры функций с возвратом значения, которые мы до сих пор рассматривали, возвращают единственное значение. Однако в
# Python вы не ограничены таким вариантом. Как показано в приведенном ниже общем формате, после инструкции return можно
# определять несколько выражений, разделенных запятыми:
# return выражение1, выражение2, ...

# Возвращение встроенного значения None.
# Python имеет специальное встроенное значение None, которое используется для указания, что значение отсутствует. Бывает
# полезно возвращать из функции значение None, чтобы просигнализировать о произошедшей ошибке.
# Программа в файле none_demo.py демонстрирует вызов функции divide и использование возвращаемого ею значения для
# проверки на наличие ошибки.


# 5.9 Математический модуль math
print('5.9 Математический модуль math')
# Математический модуль math стандартной библиотеки Python содержит многочисленные функции для использования в
# математических расчетах.
# Математический модуль math стандартной библиотеки Python содержит многочисленные функции, которые широко применяются
# для выполнения математических операций.
# В приведен ряд функций из модуля math. Эти функции, как правило, в качестве аргументов принимают одно или несколько
# значений, выполняют математическую операцию с использованием этих аргументов и возвращают результат.
# (Все перечисленные функции возвращают вещественное значение float, за исключением функций ceil и floor, которые
# возвращают целочисленные значения int.) Например, одна из функций называется sqrt. Она принимает аргумент и возвращает
# квадратный корень из аргумента.
# Функции из модуля math
# Функция модуля math   Описание
# acos(x)               Возвращает арккосинус числа x, заданного в радианах
# asin(x)               Возвращает арксинус числа x, заданного в радианах
# atan(x)               Возвращает арктангенс числа x, заданного в радианах
# ceil(x)               Возвращает самое малое целое, которое больше или равно x
# cos(x)                Возвращает косинус числа x в радианах
# degrees(x)            Допустим, что x - это угол в радианах, тогда данная функция возвращает угол, преобразованный в
#                       градусы
# exp(x)                Возвращает e ** x
# floor(x)              Возвращает самое большое целое число, которое меньше или равно x
# hypot(x, y)           Возвращает длину гипотенузы, которая проходит из (0, 0) в (x, y)
# log(x)                Возвращает натуральный логарифм числа x
# log10(x)              Возвращает логарифм по основанию 10 числа x
# radians(x)            Допустим, что x - это угол в градусах, тогда данная функция возвращает угол, преобразованный в
#                       радианы
# sin(x)                Возвращает синус x в радианах
# sqrt(x)               Возвращает квадратный корень из x
# tan(x)                Возвращает тангенс x в радианах
# В программе в файле hypotenuse.py показан еще один пример, который использует математический модуль math. Здесь
# применяется функция hypot для вычисления длины гипотенузы прямоугольного треугольника.
# Значения math.pi и math.e
# Математический модуль math также определяет две переменные, pi и e, которым присвоены математические значения констант
# π (3.14159265) и e (2.71828). Эти переменные можно применять в уравнениях, которые требуют их значений.


# 5.10 Хранение функций в модулях
print('5.10 Хранение функций в модулях')
# Модуль - это файл, который содержит программный код Python. Большие программы проще отлаживать и поддерживать, когда
# они подразделены на модули.
# По мере того как ваши программы становятся все больше и сложнее, потребность в упорядочении программного кода
# возрастает. Вы уже узнали, что большая и сложная программа должна быть разделена на функции, каждая из которых
# выполняет определенную задачу. По мере того как вы пишете в программе все больше и больше функций, вам следует
# рассмотреть возможность упорядочения функций путем их сохранения в модулях.
# Модуль - это всего лишь файл, который содержит программный код Python. Когда вы разбиваете программу на модули, каждый
# модуль должен содержать функции, которые выполняют взаимосвязанные задачи. Предположим, что вы разрабатываете систему
# бухгалтерского учета. Вы будете хранить все функции дебиторской задолженности в отдельном модуле, все функции
# кредиторской задолженности в их собственном модуле и все функции расчета заработной платы в другом модуле.
# Этот подход, именуемый модуляризацией, облегчает понимание, тестирование и поддержку программы.
# Модули также позволяют повторно использовать одинаковый программный код в более чем одной программе. Если вы написали
# набор функций, которые требуются в нескольких разных программах, то можно поместить эти функции в модуль, а затем
# импортировать модуль в любую программу, в которой требуется вызов одной из таких функций.
# В программе в файле circle.py представлен модуль circle. Он содержит два определения функций: area (возвращает площадь
# круга) и circumference (возвращает длину окружности).
# В программе в файле rectangle.py представлен модуль rectangle. Он содержит два определения функций:
# area (возвращает площадь прямоугольника) и perimeter (возвращает периметр прямоугольника).
# Прежде чем продолжить, следует сделать замечание об именах модулей:
# - имя файла модуля должно заканчиваться на .py, иначе его не получится импортировать в другие программы;
# - имя модуля не должно совпадать с ключевым словом Python. Например, если дать модулю имя for, то произойдет ошибка.
# Для того чтобы применить эти модули в программе, их импортируют при помощи инструкции import. Например, вот как надо
# импортировать модуль circle:
# import circle
# Когда интерпретатор Python прочитает эту инструкцию, он будет искать файл circle.py в той же папке, что и программа,
# которая пытается его импортировать. Если он этот файл найдет, то загрузит его в оперативную память. Если не найдет, то
# произойдет ошибка.
# После импортирования модуля можно вызывать его функции. Допустим, что radius - это переменная, которой присвоен радиус
# круга; тогда вызов функций area и circumference будет следующим:
# my_area = circle.area(radius)
# my_circum = circle.circumference(radius)
# В программе в файле geometry.py показан законченный код, в котором используются эти модули.

# Исполнение функции main по условию в модуле.
# При импорте модуля интерпретатор Python исполняет инструкции в модуле так же, как если бы модуль был автономной
# программой.
# Когда программисты создают модули, они обычно не предполагают, что эти модули будут исполняться как автономные
# программы. Модули, как правило, предназначены для импортирования в другие программы. По этой причине в большинстве
# модулей определяются только функции.
# Однако существует возможность создать модуль Python, который способен исполняться как отдельная программа либо
# импортироваться в другую программу. Например, предположим, что в программе A определено несколько полезных функций,
# которые вы хотели бы использовать в программе B. Поэтому вы хотели бы импортировать программу A в программу B.
# Однако вы не желаете, чтобы программа A начинала исполнять свою главную функцию при импортировании. Вам просто нужно,
# чтобы она определяла свои функции, не выполняя ни одной из них. Для этого вам следует в программе А написать исходный
# код, который задает то, каким образом файл используется. Запускается ли он как отдельная программа? Или же он
# импортируется в другую программу? Ответ определит, будет ли исполняться главная функция в программе А.
# К счастью, Python предоставляет способ делать такое определение. Когда интерпретатор Python обрабатывает файл
# исходного кода, он создает специальную переменную с именем __name__. (Имя переменной начинается с двух символов
# подчеркивания и заканчивается двумя символами подчеркивания.) Если файл импортируется как модуль, то переменная
# __name__ будет установлена равной имени модуля. В противном случае если файл исполняется как отдельная программа, то
# переменная __name__ будет установлена равной строковому значению '__main__'. Вы можете использовать значение
# переменной __name__, чтобы определять, должна ли исполняться главная функция или нет. Если переменная __name__ равна
# '__main__', то вы должны исполнить главную функцию, поскольку файл исполняется как отдельная программа. В противном
# случае вы не должны исполнять главную функцию, поскольку файл импортируется как модуль.
# Давайте рассмотрим приведенный в программе в файле модуль rectangle2.py.
# В программе rectangle2.py определены функция area, функция perimeter и главная функция main. Инструкция if в строке 23
# проверяет значение переменной __name__. Если переменная равна '__main__', то инструкция строке 24 вызывает функцию
# main. В противном случае если переменная __name__ имеет любое другое значение, то функция main не исполняется.
# Показанная в программе rectangle2.py техника является хорошим практическим приемом для использования в любое время,
# когда у вас в исходном файле Python есть главная функция. За счет него обеспечивается контроль: при импортировании
# файла он будет вести себя как модуль, а при непосредственном исполнении файла он будет вести себя как автономная
# программа.


# 5.11 Черепашья графика: модуляризация кода при помощи функций
print('5.11 Черепашья графика: модуляризация кода при помощи функций')
# Часто используемые операции черепашьей графики могут храниться в функциях и затем вызываться всякий раз, когда
# возникает такая необходимость.
# В программе в файле draw_squares.py демонстрируется такая функция. Функция square имеет следующие параметры:
# - x и y - координаты X, Y левого нижнего угла квадрата;
# - width - ширина сторон квадрата в пикселах;
# - color - название цвета заливки в виде строкового значения.
# В функции main функция square вызывается три раза.
# - В строке 5 чертится квадрат, его левый нижний угол располагается в позиции (100, 0). Квадрат имеет ширину 50
# пикселов и заполнен красным цветом.
# - В строке 6 чертится квадрат, его левый нижний угол располагается в позиции (–150, –100). Квадрат имеет ширину 200
# пикселов и заполнен синим цветом.
# - В строке 7 чертится квадрат, его левый нижний угол располагается в позиции (–200, 150). Квадрат имеет ширину 75
# пикселов и заполнен зеленым цветом.
# В программе в файле draw_circles.py представлен еще один пример, в котором функция применяется с целью модуляризации
# кода рисования круга. Функция circle имеет следующие параметры:
# - x и y - координаты X, Y центральной точки круга;
# - radius - радиус круга в пикселах;
# - color - название цвета заливки в виде строкового значения.
# В функции main мы вызываем функцию circle три раза.
# - В строке 5 чертится круг, его центральная точка располагается в позиции (0, 0). Радиус круга составляет 100
# пикселов, круг заполнен красным цветом.
# - В строке 6 чертится круг, его центральная точка располагается в позиции (–150, –75). Радиус круга равен 50 пикселам,
# круг заполнен синим цветом.
# - В строке 7 чертится круг, его центральная точка располагается в позиции (–200, 150). Радиус круга равен 75 пикселам,
# круг заполнен зеленым цветом.
# В программе в файле draw_lines.py функция применяется с целью модуляризации кода рисования отрезка прямой. Функция
# line имеет следующие параметры:
# - startX и startY - координаты X, Y начальной точки отрезка;
# - endX и endY - координаты X, Y конечной точки отрезка;
# - color - название цвета отрезка в виде строкового значения.
# В функции main функция line вызывается трижды для рисования треугольника.
# - В строке 13 чертится отрезок от верхней точки треугольника (0, 100) в ее левую отмеченную точку (–100, –100). Цвет
# отрезка - красный.
# - В строке 14 чертится отрезок от верхней точки треугольника (0, 100) в ее правую отмеченную точку (100, 100). Цвет
# отрезка - синий.
# - В строке 15 чертится отрезок от левой отмеченной точки треугольника (–100, –100) в ее правую отмеченную точку (100,
# 100). Цвет отрезка - зеленый.

# Хранение собственных графических функций в модуле.
# По мере написания все большего количества функций черепашьей графики следует рассмотреть возможность их хранения в
# модуле. Потом этот модуль можно импортировать в любую программу, в которой потребуется их применить. Например, в
# программе в файле my_graphics.py имеется модуль my_graphics.py, который содержит представленные ранее функции square,
# circle и line. Программа в файле graphics_mod_demo.py демонстрирует импортирование данного модуля и вызовы функций,
# которые он содержит.
