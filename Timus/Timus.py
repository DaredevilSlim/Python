#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# http://acm.timus.ru
# JUDGE_ID: 248595WS

# 1000 - A+B Problem
# Вычислите a+b
# Исходные данные - a и b
# Результат - a + b
print(sum(map(int, input().split())))


# 1197. Один в поле воин
# Условие этой задачи очень простое: вам всего лишь надо определить, сколько клеток находится под боем шахматного коня,
# одиноко стоящего на шахматной доске. На всякий случай напомним, что конь ходит буквой «Г» — на две клетки по
# горизонтали или вертикали в любом направлении, и потом на одну клетку в направлении, перпендикулярном
# первоначальному.
# Исходные данные - В первой строке находится единственное число N, 1 ≤ N ≤ 100 — количество тестов. В каждой из
# последующих N строк содержится очередной тест: два символа (маленькая латинская буква от 'a' до 'h' и цифра от 1 до
# 8) — стандартное шахматное обозначение клетки, на которой стоит конь. При этом буква обозначает вертикаль, а цифра
# — горизонталь.
# Результат - Выведите N строк: в каждой из них должно находиться единственное число — количество клеток шахматной
# доски, находящихся под боем коня.
n = int(input())
r = 0
a = ['1', '8']
b = ['2', '7']
while n > 0:
    m = input()
    v = m[0]
    h = m[1]
    if v in ['a', 'h']:
        r = 2 if h in a else 3 if h in b else 4
    elif v in ['b', 'g']:
        r = 3 if h in a else 4 if h in b else 6
    else:
        r = 4 if h in a else 6 if h in b else 8
    print(r)
    n -= 1


# 1209. 1, 10, 100, 1000...
# Представим себе бесконечную последовательность цифр, составленную из записанных друг за другом возрастающих степеней
# десятки. Вот начало этой последовательности: 110100100010000… Всё, что надо — определить, какая цифра находится в
# такой последовательности на определённом месте.
# Исходные данные - В первой строке находится целое число N (1 ≤ N ≤ 65535). В i-й из N последующих строк записано
# целое число Ki — номер позиции в последовательности (1 ≤ Ki ≤ 231 − 1).
# Результат - Выведите через пробел N цифр. i-я цифра должна равняться цифре, которая находится в описанной выше
# последовательности на позиции с номером Ki.


# 1264. Трудовые будни
# После успеха предыдущей программы Васечкина, позволившей подвести итоги выборов всего за два дня, Васечкин был
# назначен начальником отдела. Не правда ли, успех? В данный момент Артемий Сидорович готовит техническое задание для
# своего подчиненного — программиста Петечкина. Задание заключается в написании крайне полезной функции, которая
# намного облегчит жизнь всем программистам отдела. Для каждого числа от 0 до M функция будет подсчитывать число раз,
# которое число встречается в N-элементном массиве. Артемий Сидорович полагает, что функция должна работать следующим
# образом (пример кода для N = 3, M = 1):
# C	                            # Pascal
# if (arr[0]==0) ++count[0];    # if arr[0]=0 then count[0] := count[0] + 1;
# if (arr[0]==1) ++count[1];    # if arr[0]=1 then count[1] := count[1] + 1;
# if (arr[1]==0) ++count[0];    # if arr[1]=0 then count[0] := count[0] + 1;
# if (arr[1]==1) ++count[1];    # if arr[1]=1 then count[1] := count[1] + 1;
# if (arr[2]==0) ++count[0];    # if arr[2]=0 then count[0] := count[0] + 1;
# if (arr[2]==1) ++count[1];    # if arr[2]=1 then count[1] := count[1] + 1;
# Артемий Сидорович хочет оценить время, за которое Петечкин справится с заданием. Известно, что Петечкин пишет одну
# строчку кода за одну секунду (не правда ли, очень быстро?). Артемий Сидорович точно не знает, какими M и N можно
# ограничиться. Ваша цель — написать программу, которая подсчитает число секунд, которые потребуется Петечкину на
# написание кода.
# Исходные данные - Единственная строка содержит целые числа N (0 ≤ N ≤ 40000) и M (0 ≤ M ≤ 40000).
# Результат - Выведите число секунд, требуемых Петечкину на написание функции.
a, b = map(int, input().split())
print(a * (b + 1))


# 1293 - Эния
# Неспокойно сейчас на стапелях шестого дока межгалактического порта планеты Торна. Всего через месяц закончится
# реконструкция малого броненесущего корвета «Эния». И снова этому боевому кораблю и его доблестной команде предстоят
# тяжелые бои за контроль над плутониевыми рудниками Сибелиуса. Работа не прекращается ни на секунду, лазерные
# сварочные аппараты работают круглые сутки. От непрерывной работы плавятся шарниры роботов-ремонтников. Но задержаться
# нельзя ни на секунду. И вот в этой суматохе обнаруживается, что термозащитные панели корвета вновь требуют срочной
# обработки сульфидом тория. Известно, что на обработку одного квадратного метра панели требуется 1 нанограмм
# сульфида. Всего необходимо обработать N прямоугольных панелей размером A на B метров. Вам необходимо как можно
# скорее подсчитать, сколько всего сульфида необходимо на обработку всех панелей «Энии». И не забудьте, что панели
# требуют обработки с обеих сторон.
# Исходные данные - Единственная строка содержит целые числа N (1 ≤ N ≤ 100), A (1 ≤ A ≤ 100), B (1 ≤ B ≤ 100).
# Результат - Выведите вес необходимого для обработки сульфида тория в нанограммах.
a, b, c = map(int, input().split())
print(2 * a * (b * c))


# 1313. К вопросу о спорте
# Уральские медики очень озабочены состоянием здоровья молодежи. Как показали исследования, многие талантливые студенты
# вместо того, чтобы играть в футбол, кататься на коньках или велосипедах, занимаются олимпиадами по программированию.
# Так они это еще и спортивным программированием называют! Ну какой же это спорт, сидеть перед монитором и думать по
# пять часов в день! И ладно бы только на соревнованиях два раз в год, так ведь при подготовке к очередному чемпионату
# у них на сидение за компьютером уходит по несколько дней в неделю! И пусть бы это были разгильдяи какие-то, так ведь
# лучшие студенты, говорят, что и на мировом уровне результаты показывают приличные — жалко молодежь!
# Чтобы отучить студентов от вредной привычки часами сидеть у компьютеров, уральские медики придумали принципиально
# новую разработку — монитор с диагональной разверткой! В скором будущем его будут вручать победителям и призерам
# чемпионатов Урала. В специально разработанном квадратном мониторе электронный луч должен проходить экран не по
# горизонталям, а по диагоналям. Поскольку длины диагоналей разные, нестандартные параметры мерцания и нелинейные
# искажения изображения быстро отучат оболтусов пялиться в экран. Разумеется, им ничего не останется делать, кроме как
# идти и заниматься спортом. Проблема в том, что большинство видеокарт подают на вход монитору нормальную развертку.
# Для успешного внедрения нового типа монитора нужна программа-адаптер, которая преобразует квадратное изображение в
# формат, требуемый для ввода в квадратный монитор. Программа должна быть надежной и быстрой, поэтому её разработкой
# будут заниматься самые лучшие программисты — участники чемпионата Урала по спортивному программированию.
# Исходные данные - В первой строке записано целое число N (1 ≤ N ≤ 100) — количество пикселей на стороне квадратного
# монитора. Далее идут N строк, в каждой по N целых чисел в пределах от 1 до 100, разделенных пробелом. Это
# изображение, которое выводит обычная видеокарта (как видно, глубина цветности у нового монитора небольшая, все равно
# нормальному программисту больше ста цветов и не надо).
# Результат - На выходе преобразователя должна получиться последовательность для ввода в новый монитор. Пиксели
# нумеруются от левого верхнего угла, по диагоналям, слева-направо и снизу-вверх. Подробнее объяснять тут долго и
# неинтересно, посмотрите на пример, дальше сами догадаетесь.
n = int(input())
a = [input().split() for i in range(n)]
r = ''
for i in range(n):
    k = i
    j = 0
    while k >= 0:
        r += (a[k][j] + ' ')
        k -= 1
        j += 1
for i in range(1, n):
    k = n - 1
    j = i
    while j != n:
        r += (a[k][j] + ' ')
        k -= 1
        j += 1
print(r)


# 1409. Два бандита
# Бандиты Гарри и Ларри отдыхали на природе. Решив пострелять, они выставили на бревно несколько банок из-под пива
# (не больше 10). Гарри начал простреливать банки по порядку, начиная с самой левой, Ларри — с самой правой. В какой-то
# момент получилось так, что они одновременно прострелили одну и ту же последнюю банку. Гарри возмутился и сказал, что
# Ларри должен ему кучу денег за то, что тот лишил его удовольствия прострелить несколько банок. В ответ Ларри сказал,
# что Гарри должен ему еще больше денег по тем же причинам. Они стали спорить кто кому сколько должен, но никто из них
# не помнил сколько банок было в начале, а искать простреленные банки по всей округе было неохота. Каждый из них помнил
# только, сколько банок прострелил он сам. Определите по этим данным, сколько банок не прострелил Гарри и сколько банок
# не прострелил Ларри.
# Исходные данные - В единственной строке записано 2 числа — количество банок, простреленных Гарри и Ларри
# соответственно.
# Результат - Выведите 2 числа — количество банок, не простреленных Гарри и Ларри соответственно.
a, b = map(int, input().split())
print(b - 1, a - 1)
# Или
a, b = input().split()
print(int(b) - 1, int(a) - 1)
# Или
a, b = input().split()
a, b = int(b) - 1, int(a) - 1
print(a, b)


# 1639. Шоколад 2
# Малыш обиделся на Карлсона. Тот без спроса съел в доме всё сладкое и даже к соседям залезть успел. И вновь — только
# родители принесли домой большую шоколадку размера m × n, а Карлсон тут как тут! Малыш твёрдо решил, что на этот раз
# ни кусочка шоколада этому обжоре не достанется. Известно, что кроме еды у Карлсона есть ещё одна слабость: он любит
# играть в азартные игры и иногда ради возможности сыграть даже готов пожертвовать своим желудком. Поэтому Малыш
# предложил Карлсону следующую игру: за один ход игрок должен взять один из кусков шоколада и разломить его на два
# куска вдоль линий, разделяющих дольки. Игроки ходят по очереди; проигрывает тот, кто не может сделать ход, так как
# остались только куски шоколада размера 1 × 1. Победитель забирает весь шоколад себе. Однако Карлсона так просто не
# проведёшь! Он быстро смекнул, должен ли он ходить первым или уступить право первого хода Малышу, чтобы гарантированно
# выиграть. А Вы бы смогли определить это на его месте?
# Исходные данные - В единственной строке через пробел записаны целые числа m и n (1 ≤ m, n ≤ 50) — длина и ширина
# шоколадки в дольках.
# Результат - Если для того, чтобы выиграть, Карлсону нужно ходить первым, выведите в единственной строке «[:=[first]»,
# иначе выведите «[second]=:]».
a, b = map(int, input().split())
print('[:=[first]' if a * b % 2 == 0 else '[second]=:]')


# 1785. Трудности локализации
# Компания Lavin Interactive, разработчик пошаговой стратегии Losers-V, постоянно расширяет рынки сбыта и создает
# локализации своей игры даже на самые малоизвестные языки. В том числе, их заинтересовал язык племени австралийских
# аборигенов аниндилъяква. Но в языке аниндилъяква нет числительных. Как же, например, перевести на него фразу «у вас
# семь черных драконов, а у вашего врага — сорок»? Локализаторы решили перевести ее так: «у вас немного черных драконов,
# а у вашего врага — толпа». Они составили таблицу, в которой указали правила замены чисел, обозначающих количество
# монстров, на существительные и местоимения:
# Количество	Обозначение на русском языке	Обозначение на языке аниндилъяква
# от 1 до 4	несколько	few
# от 5 до 9	немного	several
# от 10 до 19	отряд	pack
# от 20 до 49	толпа	lots
# от 50 до 99	орда	horde
# от 100 до 249	множество	throng
# от 250 до 499	сонмище	swarm
# от 500 до 999	полчище	zounds
# от 1000	легион	legion
# Помогите локализаторам автоматизировать процесс — напишите программу, которая по количеству монстров выдаст
# соответствующее этому количеству слово.
# Исходные данные - В единственной строке записано целое число n (1 ≤ n ≤ 2000) — количество монстров.
# Результат - Выведите слово, соответствующее данному количеству монстров на языке аниндилъяква.
n = int(input())
a = ['few', 'several', 'pack', 'lots', 'horde', 'throng', 'swarm', 'zounds', 'legion']
if n >= 1000:
    n = 8
elif n >= 500:
    n = 7
elif n >= 250:
    n = 6
elif n >= 100:
    n = 5
elif n >= 50:
    n = 4
elif n >= 20:
    n = 3
elif n >= 10:
    n = 2
elif n >= 5:
    n = 1
else:
    n = 0
print(a[n])


# 1820. Уральские бифштексы
# После личного первенства довольные, но голодные программисты зашли в ресторан «Уральские бифштексы» и заказали себе
# n фирменных бифштексов. Для того чтобы приготовить бифштекс, повар должен прожарить каждую из его сторон на
# сковороде в течение одной минуты. К сожалению, у повара есть только одна сковорода, и на ней можно одновременно
# жарить не более k бифштексов. Определите, сколько минут понадобится повару, чтобы выполнить заказ программистов.
# Исходные данные - В единственной строке через пробел записаны целые числа n и k (1 ≤ n, k ≤ 1000).
# Результат - Выведите минимальное количество минут, за которое повар сможет приготовить n бифштексов.
a, b = map(int, input().split())
c = a * 2
print(2 if a <= b else c // b if c % b == 0 else c // b + 1)


# 1877. Велосипедные коды
# У Дена есть два четырехзначных кодовых замка для велосипеда. Каждый вечер он ставит велосипед на сигнализацию и
# пристегивает к специальной стойке одним из замков. Ден никогда не использует один и тот же замок два вечера подряд.
# В некоторую ночь злоумышленник попытался с помощью кода 0000 открыть висящий на велосипеде замок. Сработала
# сигнализация, и вор поспешил скрыться. На следующую ночь он решил попробовать код 0001, затем 0002 и так далее в
# порядке возрастания номера. Известно, что Ден не меняет кодов и в ночь, когда вор пришел впервые, велосипед был
# пристегнут первым замком.
# Исходные данные - В первой строке записан код, установленный на первом замке, во второй строке — код, установленный
# на втором замке. Оба кода — строки длины 4, состоящие из цифр от 0 до 9.
# Результат - Выведите «yes», если злоумышленник рано или поздно взломает замок, и «no» в противном случае.
print('yes' if int(input()) % 2 == 0 or int(input()) % 2 != 0 else 'no')
# Или
a = int(input()) % 2
b = int(input()) % 2
print('yes' if a == 0 or b != 0 else 'no')
# Или
a = int(input())
b = int(input())
print('yes' if a % 2 == 0 or b % 2 != 0 else 'no')


# 1880. Собственные числа Psych Up
# Шёл очередной контест Петрозаводских сборов. Игроки команды Psych Up быстро нашли простую задачу, и Федя сел за
# компьютер. Через пять минут решение было готово. Не тратя времени на тестирование, Федя отправил его на проверку и
# через несколько секунд получил вердикт Time Limit Exceeded. Федя скомкал условие задачи и вышел из класса, хлопнув
# дверью. Что-то шло не так, нужно было развеяться. По пути в туалет он услышал разговор авторов контеста. Паша
# обсуждал со своим другом решение той самой задачи. Федя смог разобрать из их разговора только слова «собственные
# числа». Федя подумал и решил, что у него, конечно же, есть собственные числа. Например, дата рождения, номер
# квартиры, оценка на последнем экзамене, количество поездок на соревнования. Но ведь контест командный. А что такое
# собственные числа команды? Естественно, что число является собственным для команды, если оно собственное для каждого
# из её участников. С такими радостными мыслями Федя направился назад в аудиторию.
# Исходные данные - Входные данные состоят из трёх блоков по две строки. Первая строка каждого блока содержит целое
# число n —количество собственных чисел очередного игрока (1 ≤ n ≤ 4 000). Во второй строке блока записано n целых
# различных чисел в порядке возрастания — собственные числа очередного игрока. Все собственные числа — целые,
# положительные и не превосходят 109.
# Результат - Выведите количество собственных чисел команды Psych Up.
n = 3
d = dict()
while n > 0:
    a = int(input())
    b = input().split()
    for i in range(a):
        d[b[i]] = d.get(b[i], 0) + 1
    n -= 1
for k in d:
    if d[k] == 3:
        n += 1
print(n)


# 1910. Руины титанов: сокрытый вход
# Сорен и Альба — известные и влиятельные маги. В своё время именно они основали магическую гильдию, которая
# объединила магов Северных земель и позволила им получить свободу и независимость от Южной империи. И несмотря на свой
# почтенный возраст, они всё ещё активно участвуют во всех важных событиях. Когда исследователи Осинских ущелий
# обнаружили там следы построек древних титанов, сотворителей этого мира, Сорен и Альба были одними из первых магов,
# кто прибыл к месту находки. Ведь титаны были самыми могущественными магами, и почти любое изучение их следов давало
# мощный толчок к развитию современной магии и помогало понять природу магии в целом. Когда Сорен и Альба добрались
# до руин титанов, то они увидели лишь немного выступающую из скалы глухую стену, разделённую на небольшие одинаковые
# секции. Где же вход? Спросил Сорен. — Очевидно, замаскирован — ответил Альба — не думал же ты, что титаны встретят
# тебя открытыми вратами. Они всегда достаточно серьёзно относились к собственной безопасности. Но я почти уверен, что
# где-то среди этих секций есть настоящая дверь. Причём во всех известных нам постройках титанов, насколько я помню,
# двери всегда шириной ровно в три таких секции. Это всё, конечно, хорошо, но как нам их найти? Стена длинная, а
# заклинание рассеивания подобных иллюзий потребует большого количества магических сил, применить его ко всей стене нам
# явно не удастся. Я чувствую, что хоть вдоль всей стены и действует заклинание маскировки, сила его весьма
# неравномерна. И я почти уверен, что сильнее всего оно именно там, где находятся двери. Я уже запустил заклинание
# сканирования магических полей, и скоро у нас будет информация о том, с какой силой поле действует на каждой из
# секций. Останется лишь выбрать из них три подряд идущие с максимальной суммарной силой поля, и применить к ним
# заклинание рассеивания.
# Исходные данные - В первой строке дано единственное целое число n — количество секций стены (3 ≤ n ≤ 1000). Во
# второй строке через пробел записаны n положительных целых чисел ai — сила магического поля на каждой из секций
# (1 ≤ ai ≤ 106).
# Результат - Выдайте через пробел два числа — максимальную суммарную силу поля возле трёх подряд идущих секций стены
# и номер средней из них. Гарантируется, что ответ всегда однозначен.
a = int(input())
b = list(map(int, input().split()))
s = 0
p = 0
for i in range(1, a - 1):
    t = sum(b[i - 1:i + 2])
    if t > s:
        s, p = t, i + 1
print(s, p)
# Или
a = int(input())
b = list(map(int, input().split()))
s = 0
p = 0
for i in range(1, a - 1):
    t = b[i - 1] + b[i] + b[i + 1]
    if t > s:
        s, p = t, i + 1
print(s, p)


# 1924. Четыре чертёнка
# Мир в опасности. Один известный мошенник по имени Остап умер, и, попав в ад, решил заключить сделку с дьяволом. Игра
# простая: четыре чертёнка делятся на две команды — «чёрные» и «чумазые» — и выходят на игровое поле. На игровом поле
# написаны в ряд числа от 1 до n, и игроки начинают по очереди ставить между ними чёрными чернилами знаки + или −.
# Задача «чёрных» — сделать так, чтобы после расстановки всех знаков результат стал чётным, а «чумазых» — чтобы
# результат стал нечётным. Все четыре чертёнка — профессионалы в этой игре, поэтому они всегда будут делать оптимальные
# ходы. «Чёрные» ходят первыми. Условия сделки таковы: если Остап правильно угадает, какая команда выиграет, его
# пустят в рай. Если неправильно — дьявол получит власть над всем миром. Ставки велики, поэтому вам придётся помочь
# Остапу.
# Исходные данные - На вход подаётся целое число n (1 ≤ n ≤ 50).
# Результат - Если выиграют «чёрные», вывести «black», иначе вывести «grimy».
print('black' if sum(range(int(input()) + 1)) % 2 == 0 else 'grimy')
# Или
a = sum(range(int(input()) + 1))
print('black' if a % 2 == 0 else 'grimy')


# 2001. Математики и ягоды
# Шли как-то два математика по лесу и собирали ягоды. Час шли, два шли, а потом вдруг остановились и решили ягодами
# помериться. Достали они весы (какой же математик пойдет в лес без весов?) и взвесили свои корзины с собранным
# урожаем, а потом записали полученные числа a1 и b1 на листочек. После этого второй математик пересыпал все ягоды в
# корзину к первому (полностью опустошив свою корзину), и они снова взвесили свои корзины, получив числа a2 и b2
# соответственно. Наконец, первый математик пересыпал все ягоды в корзину ко второму (полностью опустошив свою
# корзину); после взвешивания они получили числа a3 и b3 соответственно. Этих данных оказалось достаточно для
# определения победителя, и довольные математики пошли дальше. Вам же предстоит вычислить массу ягод в корзине каждого
# из математиков до совершения всех пересыпаний.
# Исходные данные - Входные данные состоят из трех строк. В i-й строке (1 ≤ i ≤ 3) записаны целые числа ai и bi
# (0 ≤ ai, bi ≤ 10 000).
# Результат - В единственной строке выведите пару целых чисел через пробел — сколько ягод собрали, соответственно,
# первый и второй математик.
a, b = input().split()
c, d = input().split()
e, f = input().split()
print(int(a) - int(e), int(b) - int(d))


# 2012. Про Гришу Н.
# Гриша Н. сказал двум своим товарищам по команде, что даже если они не придут на четвертьфинал чемпионата мира, он
# решит на соревновании все предложенные задачи. Сокомандники Грише не поверили, и тогда он рассказал им план, как он
# собирается это сделать.
# За первый час он хочет решить f задач. Если до конца первого часа еще останется время, Гриша просто пойдет гулять по
# коридору. Начиная со второго часа Гриша хочет тратить на каждую из оставшихся задач ровно по 45 минут. Если план Гриши
# удастся, сможет ли он решить за 5 часов соревнования все 12 предложенных задач?
# Исходные данные - В единственной строке записано целое число f — сколько задач хочет решить Гриша за первый час
# соревнования (1 ≤ f ≤ 11).
# Результат - Выведите «YES», если Грише в одиночку удастся решить все предложенные задачи, и «NO» в противном случае.
print('YES' if int(input()) >= 7 else 'NO')


# 2023. Дональд-почтальон
# Дональд Дак работает почтальоном в студии Диснея, доставляя письма детей со всего мира своим друзьям — героям
# мультфильмов. В студии есть три шкафа для писем, в каждом из которых девять секций. Все секции подписаны именами
# адресатов. Шкафы стоят в ряд так, как показано на рисунке снизу.
# Сегодня Дональд принёс n писем. Исходно он стоит у самого левого шкафа, и для перехода к соседнему шкафу ему нужно
# сделать один шаг. Сколько шагов он сделает, пока не разложит все письма, если будет раскладывать их в том порядке,
# в котором они лежат в стопке?
# Исходные данные - В первой строке записано целое число n — количество писем (1 ≤ n ≤ 1 000). В следующих n строках
# перечислены адресаты писем в том порядке, в котором они лежат в стопке у Дональда.
# Результат - Выведите количество шагов, которое нужно сделать Дональду, чтобы разложить все письма по ящикам.
s = 1
c = 0
for i in range(int(input())):
    w = input()[0]
    if s != 1 and w in 'APOR':
        c += 1 if s == 2 else 2
        s = 1
    elif s != 2 and w in 'BMS':
        c += 1
        s = 2
    elif s != 3 and w in 'DGJKTW':
        c += 1 if s == 2 else 2
        s = 3
print(c)
# Или
n = int(input())
s = 1
c = 0
while n > 0:
    w = input()[0]
    if s != 1 and w in 'APOR':
        c += 1 if s == 2 else 2
        s = 1
    elif s != 2 and w in 'BMS':
        c += 1
        s = 2
    elif s != 3 and w in 'DGJKTW':
        c += 1 if s == 2 else 2
        s = 3
    n -= 1
print(c)
# Или
n = int(input())
s = 1
c = 0
while n > 0:
    w = input()[0]
    if w in 'APOR':
        if s == 2:
            c += 1
        elif s == 3:
            c += 2
        s = 1
    elif w in 'BMS':
        if s == 1:
            c += 1
        elif s == 3:
            c += 1
        s = 2
    else:
        if s == 1:
            c += 2
        elif s == 2:
            c += 1
        s = 3
    n -= 1
print(c)


# 2066. Простое выражение
# Вы наверняка уже знаете, что Алексей — серьёзный математик, и он любит решать серьёзные задачи. Вот ещё одна из этих
# задач. Даны три неотрицательных числа a, b, c. Нужно расставить их в некотором порядке и поставить между ними знаки
# +, − или × таким образом, чтобы результат получившегося арифметического выражения был минимален. Между каждой парой
# соседних чисел должен быть один знак, унарный минус и скобки использовать нельзя. Приоритет операций стандартный
# (сначала умножение).
# Исходные данные - Даны целые неотрицательные числа a, b, c в неубывающем порядке (0 ≤ a ≤ b ≤ c ≤ 100), каждое в
# отдельной строке.
# Результат - Выведите одно целое число — минимальное значение выражения.
a = int(input())
b = int(input())
c = int(input())
print(min(a - b - c, a - b * c))


# 2100. Свадебный обед
# Маршалл и Лили женятся! Они отослали всем друзьям приглашения на свадьбу. На каждом приглашении можно отметить +one
# — это значит, что друг хочет прийти со своей парой (не из числа приглашённых). Все друзья ответили на приглашения,
# и теперь Лили хочет узнать, на сколько гостей организовывать обед в ресторане. Все гости будут сидеть за одним
# большим столом. Маршалл очень суеверный, поэтому если за столом окажутся ровно 13 человек (включая Маршалла и Лили),
# то Лили попросит сотрудников ресторана посадить манекен и обслуживать его наравне со всеми. Сколько же потратит
# молодая пара на этот обед, если обслуживание одного человека (или манекена) стоит $100?
# Исходные данные - В первой строке вводится одно целое число n — количество друзей Маршалла и Лили, которым они
# отослали приглашение (1 ≤ n ≤ 20). Затем в n строках описываются ответы на приглашения. Каждый ответ имеет вид
# name[+one]. Это имя приглашённого друга и +one, если друг отметил этот вариант. Гарантируется, что длина каждого
# имени не превосходит 20, и каждое имя состоит только из букв латинского алфавита.
# Результат - Выведите одно целое число — стоимость обеда в долларах.
n = int(input())
a = 200
while n > 0:
    b = input()
    a += 200 if '+' in b else 100
    n -= 1
print(a + 100 if a == 1300 else a)
